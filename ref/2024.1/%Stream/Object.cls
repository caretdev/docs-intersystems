/// <p><b>For information on this class</b>, see
/// <a target="_top" href="/csp/docbook/Doc.View.cls?FIND=CLASSES+%25Stream.Object">Working with Streams</a>.</p>
/// The <CLASS>%Stream.Object</CLASS> class provides the basic mechanism by
/// which stream objects are stored to and retrieved from a database.
///
/// <p>A stream represents an arbitrary array of characters (or bytes) and
/// a current position. The basic stream interface provides the ability to
/// read data from a stream, write data to the stream, and rewind the
/// current position to the beginning of the stream.
///
/// <p>Within InterSystems IRIS, streams are used to create large (greater than 32K)
/// object attributes.
Class %Stream.Object Extends %Library.RegisteredObject [ Abstract, ClassType = stream, MemberSuper = %Compiler.Type.Stream, System = 2 ]
{

Parameter DEFAULTCONCURRENCY = "$zu(115,10)";

Property %Concurrency As %RawString [ InitialExpression = {$zu(115,10)}, Private, Transient ];

/// The <var>AtEnd</var> property is set to true (1) when, during a read,
/// a stream has reached the end of its data source.
Property AtEnd As %Boolean [ InitialExpression = 1 ];

/// <var>Id</var> is the unique identifier for a stream within the <var>%Location</var>.
Property Id As %String;

/// <var>LastModified</var> is a read-only property containing the <class>%TimeStamp</class> of
/// the last modification to this stream. If the stream is null then it will report "".
Property LastModified As %TimeStamp [ Calculated ];

/// <var>%Location</var> is place where stream data is stored. For global streams this will
/// be a global reference. For file streams it may be a directory. This is not the location
/// of this specific stream, but the root location of what may be multiple streams.
Property %Location As %String(MAXLEN = 1024);

Method %LocationSet(val As %String) As %Status
{
}

/// %Locked is an integer that indicates whether or not the object is currently locked.
Property %Locked As %Integer [ InitialExpression = 0, Internal, Private, Transient ];

/// %LockRef is the global reference used for locking this stream object. This value is generated by calling
/// %GetLockRef(<var>Location</var>,<var>Id</var>) where <var>Location</var> is the value of the
/// %Location property and <var>Id</var> is the value of the Id property.
/// If this value is null then no locks are taken out. All retained locks are
/// shared locks. Exclusive locks are acquired and released in %Save and in %Delete.
/// %LockRef must be set in order for any locking to occur. This property is not
/// set typically until the stream is locked.
Property %LockRef As %RawString [ Internal, Private, Transient ];

/// <var>Size</var> is a read-only property containing the current size of the stream (in bytes
/// for a binary stream and characters for a character stream).
///
/// <p>If a specific stream implementation cannot determine the size of the stream then
/// <var>Size</var> will be equal to -1.<br>
Property Size As %Integer [ Calculated ];

/// Return true if this is a character stream and false if it is a binary stream.
ClassMethod IsCharacter() As %String [ CodeMode = generator ]
{
}

/// Returns the persistent object Id, if there is one, of this object.
/// <p>Returns a null string if there is no object Id.
Method %Id() As %String
{
}

/// Deletes the stored version of the object with OID <var>oid</var> from the database.
/// It does not remove any in-memory versions of the object that may be present.
///
/// Refer to <a href="/csp/docbook/DocBook.UI.Page.cls?KEY=GOBJ_concurrency" target="_blank">Object Concurrency Options</a> for more details
/// on the optional <var>concurrency</var> argument.
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
///
/// <p>Internally, <METHOD>%Delete</METHOD> initiates a transaction and then invokes the storage
/// interface method <METHOD>%DeleteData</METHOD>. If <METHOD>%DeleteData</METHOD> succeeds, the
/// transaction is committed, otherwise it is rolled back.
ClassMethod %Delete(oid As %ObjectIdentity = "", concurrency As %Integer) As %Status [ Final ]
{
}

/// Deletes the stored version of the object with ID <var>id</var> from the database.
///
/// <p><METHOD>%DeleteId</METHOD> is identical in operation to the <METHOD>%Delete</METHOD> method except
/// that it uses and Id value instead of an OID value to find an object.
///
/// Refer to <a href="/csp/docbook/DocBook.UI.Page.cls?KEY=GOBJ_concurrency" target="_blank">Object Concurrency Options</a> for more details
/// on the optional <var>concurrency</var> argument.
ClassMethod %DeleteId(id As %String, concurrency As %Integer) As %Status [ CodeMode = expression, Final ]
{
}

/// Loads an object from the database into memory and returns an OREF referring to the object.
/// <var>oid</var> is the OID value of the object to load. If <var>oid</var> is a partially-formed OID,
/// that is it does not include a class name, then <METHOD>%Open</METHOD> does the following:
/// it assumes the class name is
/// the same as the object class on which <METHOD>%Open</METHOD> was called.
/// <p>If a version of the specified object is already in memory, then <METHOD>%Open</METHOD> increments
/// the object's reference count and returns the OREF value referring to this version.
/// <METHOD>%Open</METHOD> also an optional concurrency argument which specifies the concurrency setting
/// for this object (and sets the value of the <var>%Concurrency</var> attribute). If the
/// <var>concurrency</var> argument is omitted then the system default value (1: <i>Atomic</i>) is used.
///
/// Refer to <a href="/csp/docbook/DocBook.UI.Page.cls?KEY=GOBJ_concurrency" target="_blank">Object Concurrency Options</a> for more details
/// on the optional <var>concurrency</var> argument.
///
/// <p><METHOD>%Open</METHOD> returns an OREF value that refers to the in-memory object instance or
/// a null reference ($$$NULLOREF) if it cannot find or otherwise load the object.
ClassMethod %Open(soid As %ObjectIdentity, concurrency As %Integer, ByRef sc As %Status = {$$$OK}) As %ObjectHandle [ Final ]
{
}

Method %LoadInit(concurrency As %Integer, soid As %ObjectIdentity) As %Status [ CodeMode = generator, Final, Internal, Private ]
{
}

/// Loads an object from the database into memory and returns an OREF referring to the object.
/// <var>id</var> is the Id (not a full OID) value of the object to load.
///
/// <p><METHOD>%OpenId</METHOD> is identical in operation to the <METHOD>%Open</METHOD> method except
/// that it uses and Id value instead of an OID value to find an object instance.
///
/// Refer to <a href="/csp/docbook/DocBook.UI.Page.cls?KEY=GOBJ_concurrency" target="_blank">Object Concurrency Options</a> for more details
/// on the optional <var>concurrency</var> argument.
///
/// <p><METHOD>%OpenId</METHOD> returns an OREF value that refers to the in-memory object instance or
/// a null reference ($$$NULLOREF) if it cannot find or otherwise load the object.
ClassMethod %OpenId(id As %String, concurrency As %Integer, ByRef sc As %Status = {$$$OK}) As %ObjectHandle [ CodeMode = expression, Final ]
{
}

/// Delete all instances of this class from its extent. On exit <var>instancecount</var>
/// contains the original number of instances while <var>deletecount</var> contains
/// the number of instances actually deleted.
///
/// <p>Internally, <METHOD>%DeleteExtent</METHOD> iterates over the set of instances in the
/// collection and invokes the <METHOD>%Delete</METHOD> method.
///
/// Refer to <a href="/csp/docbook/DocBook.UI.Page.cls?KEY=GOBJ_concurrency" target="_blank">Object Concurrency Options</a> for more details
/// on the optional <var>concurrency</var> argument.
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
ClassMethod %DeleteExtent(concurrency As %Integer, ByRef deletecount, ByRef instancecount) As %Status [ CodeMode = generator ]
{
}

/// Changes the concurrency level of an instance in memory to a lower level
/// by changing the lock type specified in the <METHOD>%Open</METHOD> method for the object's
/// instance. Fails if it cannot lower the concurrency level.
///
/// Refer to <a href="/csp/docbook/DocBook.UI.Page.cls?KEY=GOBJ_concurrency" target="_blank">Object Concurrency Options</a> for more details
/// on the <var>concurrency</var> argument.
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %DowngradeConcurrency(concurrency) As %Status [ Final, Internal ]
{
}

/// <METHOD>%GetSwizzleObject</METHOD> is used to obtain a state of the object that can
/// later be used to restore the object. In the case of a persistent object, it returns the OID.
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %GetSwizzleObject(force As %Integer = 0, ByRef oid As %ObjectIdentity) As %Status [ Final ]
{
}

/// %LockStream()
/// 	Obtain a shared lock on the current stream object. %Locked is set to 1 if the stream was successfully locked. If the stream
/// 	cannot be locked then %Locked is set to 0. No lock is attempted unless %GetLockReference returns a non-null value. If a lock
/// 		is attempted but cannot be acquired (lock timeout expires) then this method will throw an exception. The caller is expected
/// 		to catch the exception and process it appropriately.
///
/// Throws %Exception.AbstractException, most often a StatusException.
Method %LockStream() [ ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// %UnlockStream()
/// 	Release the shared lock on the current stream object. If the immediate argument is 1 then
/// 	the lock is released using the "I" flag.
Method %UnlockStream(immediate As %Boolean = 0) [ ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// Returns the global reference used to lock the current stream object
/// Throws %Exception.AbstractException
ClassMethod %GetLockReference(pLocation As %String(MAXLEN="") = "", pId As %String(MAXLEN="") = "") As %String(MAXLEN="") [ Private ]
{
}

/// Returns the OID of this object.
Method %Oid() As %ObjectIdentity
{
}

/// Returns an full id value (including class name) with which the Stream implementation has stored
/// the stream.
Method GetStreamId() As %String [ CodeMode = call ]
{
}

/// %Reload is an instance method that re-reads an object from disk into the
/// current instance. Calling %Reload is similar to calling <METHOD>%Close</METHOD> and then
/// <METHOD>%Open</METHOD>, but it uses the same OREF.
///
/// <p>After %Reload is called, there are no swizzled references for the object,
/// and <METHOD>%IsModified</METHOD> returns 0.
///
/// <p>%Reload performs the following steps. First, all swizzled objects for the
/// instance are unswizzled. Then the object is reloaded from disk, using the
/// <METHOD>%Id</METHOD> of the current object. Finally, the modified bit for each property is
/// cleared.
Method %Reload() As %Status [ CodeMode = generator ]
{
}

/// This method is called by <METHOD>%Save</METHOD> when a transaction is rolled back.
/// It will invoke a user-supplied <METHOD>%OnRollBack</METHOD> method if it exists.
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %RollBack() As %Status
{
}

/// Stores an in-memory version of an object to disk. If the object was stored
/// previously (and thus, already has an OID), <METHOD>%Save</METHOD> updates the on-disk version.
/// Otherwise, <METHOD>%Save</METHOD> saves the object and generates a new OID for it.
///
/// <p>The <var>related</var> argument specifies how <METHOD>%Save</METHOD> handles references to other objects.
/// It can take the following values:
/// <table cols=2>
/// <tr>
/// <td width="33%" valign="top">0: <i>Shallow Save</i></td>
/// <td valign="top">
/// If this object has been modified then save it. Only save related objects if they have never been saved (do not have an OID value) and must be
/// saved in order to allocate the OID needed by this object.
/// </td>
/// </tr>
///
/// <tr>
/// <td width="33%" valign="top">1: <i>Deep Save</i></td>
/// <td valign="top">
/// Save this object and all "related" objects that have been edited. In this case,
/// "related" means any in-memory objects it refers to, and any in-memory objects
/// they in turn refer to, and so on. However, only objects that have been changed
/// (<METHOD>%IsModified</METHOD> returns true) will actually be saved to the database, including
/// the object upon which <METHOD>%Save</METHOD> was initially called.
/// </table>
/// </td>
/// </tr>
///
/// <p><METHOD>%Save</METHOD> automatically detects and handles circular references between objects.
/// For example, <METHOD>%Save</METHOD> will detect if object A refers to object B and object B likewise refers to object A.
/// In this case it will avoid falling into an infinite, recursive loop.
///
/// <p>Note that either reference attribute, A to B or B to A, can be specified as being
/// a required attribute but not both of them. If both reference attributes are required
/// then <METHOD>%Save</METHOD> will fail.
///
/// <p>By default <METHOD>%Save</METHOD> automatically manages transactions. You can enable and disable
/// automatic transaction support using the <code>$$SetTransactionMode^%apiOBJ()</code> routine.
///
/// <p>When <METHOD>%Save</METHOD> saves an object to the database, it initiates one transaction
/// (by calling TSTART) for the entire set of saves, including the original object
/// and any related objects. If the save operation is successful, <METHOD>%Save</METHOD> will issue a
/// TCOMMIT command to commit the transaction and write the data to the database.
/// If <METHOD>%Save</METHOD> encounters a problem when saving the original object or any of its
/// related objects, it rolls back the entire transaction and performs the following actions:
/// <ul>
/// <li>It issues a TROLLBACK command to rollback any changes to the database that may
/// have occurred. (In the case of the <CLASS>%Storage.Persistent</CLASS> class, changes to the on-disk
/// counter value, used to determine the next available object id number, are not rolled back.)
/// <li>It restores the in-memory state of all the objects involved in the transaction to
/// their pre-transaction state. This includes restoring any modified flags, and
/// restoring to null ("") any OID values that have been assigned during the course of
/// the transaction. Additional property values changed during the course of the
/// transaction are not restored, however.
/// <li>It calls the <METHOD>%RollBack</METHOD> method on each object involved with the transaction.
/// The order in which the <METHOD>%RollBack</METHOD> methods are called is undefined. <METHOD>%RollBack</METHOD> will
/// call a user-written <METHOD>%OnRollback</METHOD> method if it is present.
/// </ul>
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %Save(related As %Integer = 1) As %Status [ Final, GenerateAfter = (%OnBeforeSave, %OnAfterSave) ]
{
}

/// Elevates the concurrency level of an instance in memory to a higher level
/// by changing the lock type specified in the <METHOD>%Open</METHOD> method for the object's
/// instance. Fails if it cannot elevate the concurrency level.
///
/// Refer to <a href="/csp/docbook/DocBook.UI.Page.cls?KEY=GOBJ_concurrency" target="_blank">Object Concurrency Options</a> for more details
/// on the <var>concurrency</var> argument.
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %UpgradeConcurrency(concurrency) As %Status [ Final, Internal ]
{
}

/// Acquires a lock for the current instance.
///
/// <p>The <var>locktype</var> argument specifies the type of lock to acquire.
/// It can take the following values:
/// <table cols=2>
/// <tr>
/// <td width="33%" valign="top">"e": <i>Exclusive</i></td>
/// <td valign="top">
/// An exclusive lock will prevent any other process from acquiring any type of lock
/// on this object.
/// </td>
/// </tr>
///
/// <tr>
/// <td width="33%" valign="top">"s": <i>Shared</i></td>
/// <td valign="top">
/// A shared lock will allow other processes to acquire shared locks but will
/// prevent other processes from acquiring an exclusive lock.
/// </table>
/// </td>
/// </tr>
///
/// Fails if the locktype parameter is not one of the values described above.
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %AcquireLock(locktype) As %Status [ Private ]
{
}

ClassMethod %CheckUnique(idxlist As %List = "") As %Status
{
}

Method %LoadData(soid As %String) As %Status [ Private ]
{
}

Method %SaveData(ByRef id As %String) As %Status [ Private ]
{
}

ClassMethod %DeleteData(soid As %String, concurrency As %Integer) As %Status [ Private ]
{
}

Method %OnConstructClone(object As %RegisteredObject, deep As %Boolean = 0, ByRef cloned As %String) As %Status [ CodeMode = expression, Private ]
{
}

/// Checks to see if the object identified by the OID <var>oid</var> exists in the extent.
///
/// <p>Returns <CLASS>%Boolean</CLASS> TRUE is it exists, FALSE if it does not.
ClassMethod %Exists(soid As %ObjectIdentity) As %Boolean
{
}

/// Checks to see if the object identified by the ID <var>id</var> exists in the extent.
///
/// <p>Returns <CLASS>%Boolean</CLASS> TRUE is it exists, FALSE if it does not.
ClassMethod %ExistsId(id As %String) As %Boolean [ CodeMode = expression ]
{
}

ClassMethod %KillExtent() As %Status
{
}

/// Releases a lock for the current instance.
///
/// <p>The <var>locktype</var> argument specifies the type of lock to release.
/// It can take the following values:
/// <table cols=2>
/// <tr>
/// <td width="33%" valign="top">"e": <i>Exclusive</i></td>
/// <td valign="top">
/// An exclusive lock will prevent any other process from acquiring any type of lock
/// on this object.
/// </td>
/// </tr>
///
/// <tr>
/// <td width="33%" valign="top">"s": <i>Shared</i></td>
/// <td valign="top">
/// A shared lock will allow other processes to acquire shared locks but will
/// prevent other processes from acquiring an exclusive lock.
/// </table>
/// </td>
/// </tr>
///
/// Fails if the locktype parameter is not one of the values described above.
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method %ReleaseLock(locktype) As %Status
{
}

/// This callback method is invoked by the <METHOD>%Delete</METHOD> method to
/// provide notification that the object specified by <VAR>oid</VAR> is being deleted.
///
/// <P>If this method returns an error then the object will not be deleted.
ClassMethod %OnDelete(oid As %ObjectIdentity) As %Status [ Private, ServerOnly = 1 ]
{
}

/// This callback method is invoked by the <METHOD>%Save</METHOD> method to
/// provide notification that the object is being saved. It is called before
/// any data is written to disk.
///
/// <P><VAR>insert</VAR> will be set to 1 if this object is being saved for the first time.
///
/// <P>If this method returns an error then the call to <METHOD>%Save</METHOD> will fail.
Method %OnBeforeSave(insert As %Boolean) As %Status [ Abstract, Private, ServerOnly = 1 ]
{
}

/// This callback method is invoked by the <METHOD>%Save</METHOD> method to
/// provide notification that the object is being saved. It is called after
/// the object's data has been successfully written to disk.
///
/// <P><VAR>insert</VAR> will be set to 1 if this object is being saved for the first time.
///
/// <P>If this method returns an error then the call to <METHOD>%Save</METHOD> will fail.
Method %OnAfterSave(insert As %Boolean) As %Status [ Abstract, Private, ServerOnly = 1 ]
{
}

/// This callback method is invoked by the <METHOD>%Open</METHOD> method to
/// provide notification that the object specified by <VAR>oid</VAR> is being opened.
///
/// <P>If this method returns an error then the object will not be opened.
Method %OnOpen() As %Status [ Private, ServerOnly = 1 ]
{
}

/// This callback method is invoked by the <METHOD>%Reload</METHOD> method to
/// provide notification that the object specified by <VAR>oid</VAR> was reloaded.
/// <method>%Reload</method> is invoked by %Open when the object identified by the OID
/// is already in memory.
/// <br>
/// <P>If this method returns an error then the object will not be opened.
Method %OnReload() As %Status [ Abstract, Private, ServerOnly = 1 ]
{
}

/// This callback method is invoked by the <METHOD>%Close</METHOD> method to
/// provide notification that the current object is being closed.
///
/// <P>The return value of this method is ignored.
Method %OnClose() As %Status [ Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// This callback method is invoked by the <METHOD>%Save</METHOD> method to
/// provide notification that a save transaction is being rolled back.
///
/// <P>If this method returns an error then the rollback operation will be aborted.
Method %OnRollBack() As %Status [ Private, ServerOnly = 1 ]
{
}

/// Reads up to <var>len</var> characters from the current position
/// in the stream. The current position is advanced by the number of
/// characters read. Upon exit, <var>len</var> is set to the actual
/// number of characters read. If a read occurs when the stream position
/// is at the end of the stream, <var>len</var> will be set to -1 and
/// <method>Read</method> will return a null string (""). If no <var>len</var>
/// is passed in, ie. '<method>Read</method>()' then it is up to the Read implementation as to
/// how much data to return. Some stream classes use this to optimize the amount of
/// data returned to align this with the underlying storage of the stream.
///
/// <p>You must call <method>Rewind</method> if you want to read a stream from the beginning
/// again. Calling <method>Read</method> after <method>Write</method> implicitly ends the <method>Write</method>
/// operation and rewinds to the start of the stream.
///
/// <p>Returns a string up to <var>len</var> characters long. The byref argument <var>sc</var> will
/// return a %Status if any error occurred during the read.
Method Read(ByRef len As %Integer = 32656, ByRef sc As %Status) As %RawString
{
}

/// Read a line from the stream. This will look for the line terminator in the stream and
/// once it finds the terminator it will return the string minus the terminator character/s. If it reaches the
/// end of the stream before it finds a terminator it will return the data it has so far, and if you specify a
/// maximum size in <var>len</var> it will only read up to this number of characters. On exit <var>len</var>
/// will contain the actual number of characters read. The byref argument <var>sc</var> will
/// return a <method>%Status</method> if any error occured during the read and the byref argument <var>eol</var>
/// is true if it found the line terminator and false otherwise. So for example you can read in a stream
/// a line at a time and output the results to the current device with:
/// <EXAMPLE>While 'stream.AtEnd { Write stream.ReadLine(,.sc,.eol) If $$$ISERR(sc) { Write "ERROR" Quit } If eol { Write ! } }</EXAMPLE>
Method ReadLine(ByRef len As %Integer = 32000, ByRef sc As %Status, ByRef eol As %Boolean) As %RawString
{
}

Method ReadLineIntoStream(ByRef sc As %Status) As %Stream.Object
{
}

/// Appends the string <var>data</var> to the stream and advances the
/// current stream position by the number of characters in <var>data</var>.
///
/// <p>Note that a write operation immediately following a read or rewind
/// will clear out the existing data in the stream.
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method Write(data As %RawString) As %Status
{
}

/// Appends the string <var>data</var> along with a line terminator to the stream and advances the
/// current stream position by the number of characters in <var>data</var> plus the line terminator.
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method WriteLine(data As %RawString = "") As %Status [ CodeMode = expression ]
{
}

/// Copies the contents of <i>source</i> into this Stream.
/// Does not call <METHOD>Rewind</METHOD> on this Stream before copying.
/// <p>For example, you can copy <var>oldstream</var> into a new stream:
/// <EXAMPLE>
/// Set newstream=##class(%GlobalCharacterStream).%New()
/// Do newstream.CopyFrom(oldstream)
/// </EXAMPLE>
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method CopyFrom(source As %Stream.Object) As %Status
{
}

/// Clear the contents of this Stream from permanent storage. This will remove the permanent stream storage and
/// any temporary stream and initialise the stream to its initial state that it starts in, including removing all
/// the stream attributes.
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method Clear() As %Status
{
}

/// Move to the end of the stream so the next <METHDO>Write</METHOD> will be appended to the end.
/// This allows you to read from a stream, then MoveToEnd() and append new data, where just calling
/// <METHOD>Write</METHOD> after a read will clear the stream before writing new data.
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
Method MoveToEnd() As %Status
{
}

/// Write out <var>len</var> characters of the stream to the current device starting from the current position. This
/// method is optimised for performance by the various sub classes. If <var>len</var> is omitted or set to -1 then
/// it will write out the entire stream starting at the beginning.
Method OutputToDevice(ByRef len As %Integer = -1) As %Status
{
}

/// Input <var>len</var> characters from the current device into the stream. This is equivalent to doing a series of
/// reads and calling <METHOD>Write</METHOD> for each of them but it may be optimised by the subclasses. On return
/// <var>len</var> will be the number of characters still to read in (if no timeout has occured this should be 0).
Method InputFromDevice(ByRef len As %Integer = 0, timeout As %Integer = 20) As %Status
{
}

Method LastModifiedGet() As %TimeStamp [ CodeMode = expression ]
{
}

/// Output the stream to the current device starting at <var>position</var> of length
/// <var>length</var>. The length if passed is the number of characters to output, if
/// not passed it will output from <var>position</var> to the end of the stream.
Method OutputToDeviceAt(position As %Integer, ByRef length As %Integer) As %Status
{
}

/// Find the first occurrence of target in the stream, starting the search at position. The method returns the
/// position of this match, counting from the beginning of the stream, and leaves the stream positioned at an
/// indeterminate location. If it does not find the target string, it returns -1.<p>
/// If <var>position</var>=-1 then it starts searching from the location found in the previous search and returns the offset
/// from the last search. This is useful for searching through the entire file. If you are doing this, you should pass in
/// <var>tmpstr</var> by reference in every call. This is used to store the last buffer read, so the next call will start where the last one left off.
/// If <var>caseinsensitive</var>=1 then the search will be case insensitive, rather than the default case-sensitive search.
Method FindAt(position As %Integer, target As %RawString, ByRef tmpstr As %RawString = "", caseinsensitive As %Boolean = 0) As %Integer
{
}

/// Move to this <var>position</var> in the stream. If this suceeds then return
/// true, else return false. Note this implementation is not efficient because it
/// searches from the start of the stream, it can be improved upon in specific subclasses.
/// Note that moving to position 1 will be at the start of the stream, position 2 will be
/// at the second character of the stream, etc.
Method MoveTo(position As %Integer) As %Boolean
{
}

/// Go back to the start of the stream.
Method Rewind() As %Status
{
}

/// Flush any output in the stream not already saved.
Method Flush() As %Status
{
}

/// Returns true if this is a "NULL" stream; that is, a stream which has never
/// been written to and saved and has no stream attributes. This is used by the InterSystems IRIS ODBC server.
Method IsNull() As %Boolean [ CodeMode = call ]
{
}

/// Returns true if this is a "NULL" stream; that is, a stream which has never
/// been written to and saved and has no stream attributes. This is used by the InterSystems IRIS ODBC server.
Method %IsNull() As %Boolean [ CodeMode = expression ]
{
}

/// Return true if this stream oid is a null stream and false if the stream is not null
ClassMethod %ObjectIsNull(soid As %ObjectIdentity) As %Boolean
{
}

/// Copy the stream from <var>source</var> into the current stream ignoring anything already in the current stream
/// and save the result to the permanent location. This is used to optimise the copying of say a
/// <CLASS>%GlobalCharacterStream</CLASS> to another <CLASS>%GlobalCharacterStream</CLASS> to avoid copying into
/// temporary storage first and then moving this to the permanent storage when <METHOD>SaveStream</METHOD> is called.<p>
/// Note that any locking or transaction handling must be done by the caller.
Method CopyFromAndSave(source As %Stream.Object) As %Status
{
}

/// SerializeToSyncSet copies the stream value from the current object to the sync set global. When the sync set is imported into another system
/// the stream value will be copied from the global back to a stream of the container property's current type.
Method SerializeToSyncSet(ss As %SYNC.SyncSet, iPtr As %Integer, property As %String) As %Status [ CodeMode = generator ]
{
}

/// SyncStreamIn copies the stream value from the sync set global into the current object.
Method SyncStreamIn(ss As %SYNC.SyncSet, iPtr As %Integer, property As %String) As %Status
{
}

Method SizeGet() As %Integer
{
}

/// SQL specific method for reading stream data
Method ReadSQL(start As %Integer = 1, end As %Integer = -1) As %String
{
}

/// Return true if this stream oid is a null stream and false if the stream is not null
ClassMethod StreamOIDIsNull(soid As %ObjectIdentity) As %Boolean [ CodeMode = call ]
{
}

/// Returns the size of the stream pointed to by soid in the most efficient way possible.
ClassMethod %ObjectSize(soid As %ObjectIdentity) As %Integer
{
}

ClassMethod %ObjectSizeInternal(soid As %ObjectIdentity) As %Integer [ Private ]
{
}

/// Given a <var>soid</var> if the length is <= <var>prefetchsize</var> then return the data
/// in <var>data</var>.
/// The return value is 0 meaning the stream is over this size,
///                     1 for character stream
///                     2 for binary stream.
///                     3 for non-NULL empty Stream (Size=0)
ClassMethod %LOBPrefetch(soid As %ObjectIdentity, prefetchsize As %Integer, ByRef data As %String) As %Integer
{
}

ClassMethod %LOBPrefetchInternal(soid As %ObjectIdentity, prefetchsize As %Integer, ByRef data As %String) As %Integer [ Private ]
{
}

}
