/// This class contains the storage interface methods
/// for the default storage structure. The storage interface
/// methods, which are implemented as method generators, work in conjunction
/// with the persistent interface methods of the <class>%Persistent</class> class to
/// provide persistent behavior for objects.
///
/// <p>The methods of this class are not meant to be called directly.
/// Use the methods of the <class>%Persistent</class> class which, in turn, call the
/// appropriate method.
Class %Storage.Persistent Extends %Storage [ Abstract, Not ProcedureBlock, System = 2 ]
{

Parameter STORAGECOMPILERCLASS = "%Compiler.Storage.Persistent";

/// STORAGEINTERFACE defines the type of serialization implemented by this class.
/// The value has to match the classtype of the class that is inheriting the serialization
/// interface.
Parameter STORAGEINTERFACE As STRING [ Constraint = ",persistent,serial", Flags = ENUM ] = "persistent";

/// %AncestryStorageToLogical
ClassMethod "%%CLASSNAMEStorageToLogical"(%val) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// %AncestryLogicalToStorage
ClassMethod "%%CLASSNAMELogicalToStorage"(%val) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

ClassMethod %BMEBuilt(ByRef bmeName As %String) As %Boolean [ CodeMode = generator, ServerOnly = 1 ]
{
}

/// This method will build the indexes requested for the range of ID's requested. If it is prudent to do this work in the background
/// using multiple processes then it will be done using $system.WorkMgr.
/// If doing the work in the background then the extent will be partitioned using one of four different algorithms.
/// 1) Integer ID, no bitmap extent index present - compute the difference between the first ID and the last, divide by partition size;
/// 2) Integer ID, bitmap extent index present - chunk up using bitmap chunk size and the bitmap extent;
/// 3) Single non-integer property -
/// 4) Composite ID on non-integer property -
ClassMethod %BuildIndices(pIndexList As %RawString = "", pAutoPurge As %Integer = 1, pLockFlag As %Integer = 0, pJournalFlag As %Integer = "", pStartID As %RawString = "", pEndID As %RawString = "", pIgnoreIndexList As %RawString = "", pKeepSelectability As %Integer = 0, pNumberJobs As %Integer = "") As %Status [ CodeMode = generator, Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

ClassMethod %BuildDeferredIndices(lockFlag As %Integer = 0, journalFlag As %Integer = 1) As %Status [ CodeMode = generator, Internal, ProcedureBlock = 1 ]
{
}

/// This function generates the code to iterate over a range of ID values, invoking the index filer for each ID.
ClassMethod %BuildIndicesSegment(pStartID As %Integer, pEndID As %Integer, ByRef pIndexHandle As %Binary = 0, pLockFlag As %Integer = 1, pFirstRange As %Boolean = 0, pJob As %RawString = "") As %Status [ CodeMode = generator, Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

ClassMethod %BuildDeferredSegment(chunkPtr As %Integer, chunk As %Binary, pLockFlag As %Integer = 1, pJob As %RawString = "") As %Status [ CodeMode = generator, Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// %DeleteData()
/// 	Delete object from persistent storage
/// 	The caller is responsible for calling %IdSet()
/// 	Don't include class name with id in input parameter
ClassMethod %DeleteData(id As %String, concurrency As %Integer) As %Status [ CodeMode = generator, Final, Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// %Exists()
/// 	Check to see if an OID exists in the extent of this class...
ClassMethod %Exists(oid As %ObjectIdentity = "") As %Boolean [ Final, ProcedureBlock = 1, ServerOnly = 0 ]
{
}

/// %ExistsId()
/// 	Check to see if an ID exists in the extent of this class...
ClassMethod %ExistsId(id As %String) As %Boolean [ CodeMode = generator, Final, ProcedureBlock = 1, ServerOnly = 0 ]
{
}

/// Files each index for the object identified by <var>id</var>. <var>pIndexHandle</var> is for internal use only.
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
/// This method is normally generated by the storage class for persistent classes using
/// <class>%Storage.Persistent</class> or <class>%Storage.SQL</class>.
ClassMethod %FileIndices(id As %String(MAXLEN=""), ByRef pIndexHandle As %Binary = 0, ByRef pVectorBuffer As %RawString) As %Status [ CodeMode = generator, Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

ClassMethod %FileIndicesBuffered(id As %String(MAXLEN=""), ByRef pIndexHandle As %Binary = 0, ByRef pIndexBuffer As %RawString = "", ByRef pVectorBuffer As %RawString) As %Status [ CodeMode = generator, Internal, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// Initialize the data global for extent root classes.
/// Return an error if the class is not the extent root class.
ClassMethod %InitExtentData() As %Status [ CodeMode = generator, Final, ServerOnly = 1 ]
{
}

/// Kill the data, index, and idlocations for extent root classes. Return an error if the class
/// is not the extent root class.
/// If <var>killstreams</var> is true (default is false) it will also kill the default stream storage global.
/// If <var>reinitialize</var> is true (default is false) it will also call %InitExtent to re-define the globals.
ClassMethod %KillExtentData(killstreams As %Boolean = 0, reinitialize As %Boolean = 0) As %Status [ CodeMode = generator, Final, ServerOnly = 1 ]
{
}

/// 	Load object from persistent storage into memory. The caller is responsible for calling %IdSet()
/// 	Don't include class name with id in input parameter
Method %LoadData(id As %String) As %Status [ CodeMode = generator, Final, Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// 	Load object from persistent storage into memory. The caller is responsible for calling %IdSet()
/// 	Don't include class name with id in input parameter
/// 	state is the physical data where the structure of state mirrors the structure of the object on disk
/// 	obj is an array, subscripted by property name where each array element is equal to the property value named as the subscript.
ClassMethod %LoadFromMemory(id As %String, ByRef objstate As %String, ByRef obj As %String) As %Status [ Final, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

Method %LoadDataFromMemory(id As %String, ByRef objstate As %String, ByRef obj As %String) As %Status [ CodeMode = generator, Final, Internal, Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// 	Load object from persistent storage into memory.  The caller is responsible for calling %IdSet()
/// 	Don't include class name with id in input parameter
ClassMethod %PhysicalAddress(id As %String, ByRef paddr As %String) As %Status [ CodeMode = generator, Final, ServerOnly = 1 ]
{
}

/// %OnDetermineClass - find the most-specific-type-class for the given OID.
ClassMethod %OnDetermineClass(oid As %ObjectIdentity, ByRef class As %String) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

ClassMethod %PurgeIndices(idxlist As %List = "", lockExtent As %Boolean = 0, pIgnoreIndexList As %RawString = "", pJournalFlag As %Library.Integer = "") As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// Acquire (s)hared or (e)xclusive locks based on locktype parameter
ClassMethod %LockExtent(shared As %Boolean = 0) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// Release (s)hared or (e)xclusive locks based on locktype parameter
ClassMethod %UnlockExtent(shared As %Boolean = 0, immediate As %Boolean = 0) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// %LockId() - Obtain an exclusive or shared lock on the object identified by <var>id</var>.  The type	of lock obtained is determined by <var>shared</var>.  This method overrides the implementation from %Library.Persistent.
ClassMethod %LockId(id As %String, shared As %Boolean = 0, timeout As %Integer = {$$$LockTimeout}) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 0 ]
{
}

/// %UnlockId() - Release an exclusive or shared lock on the object identified by <var>id</var>.  The type of lock released is determined by <var>shared</var>.  This method overrides the implementation from %Library.Persistent.
ClassMethod %UnlockId(id As %String, shared As %Boolean = 0, immediate As %Boolean = 0) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 0 ]
{
}

/// %SaveData() - Save the object to a persistent state (e.g. store it on disk).
/// Returns: oid or "" if save fails
Method %SaveData(id As %String) As %Status [ CodeMode = generator, Final, Private, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

ClassMethod %InsertBatch(objects As %List, concurrency As %Integer = 0, useTransactions As %Boolean = 0) As %List [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// %SaveDirect() - saves an object to disk, checks uniqueness and referential
/// integrity constraints, and maintains index structures. This method is
/// implemented by the storage class.
ClassMethod %SaveDirect(ByRef id As %String = "", idList As %List = "", ByRef data As %Binary, concurrency As %Integer = -1) As %Status [ CodeMode = generator, Final, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

/// Files the indices for all objects whose ID is in the range defined by <var>pStartId</var> and <var>pEndId</var>.
/// If <var>pEndID</var> is null then it defaults to <var>pStartId</var>. If <var>pStartId</var> is null then the
/// range is empty and no filing will occur.
///
/// If <var>lockExtent</var> is true then an extent lock will be acquired before the indices
/// are built. If the lock cannot be acquired then an error is returned. The lock is released
/// after the index filing is completed.
///
///
/// <p>Returns a <CLASS>%Status</CLASS> value indicating success or failure.
ClassMethod %SaveIndices(pStartId As %String(MAXLEN="") = "", pEndId As %String(MAXLEN="") = "", lockExtent As %Boolean = 0) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 0 ]
{
}

/// %SortBegin()
/// This method will start a system merge sort for all indices (idxlist is null) or for specified indices
ClassMethod %SortBegin(idxlist As %List = "", excludeunique As %Integer = 0) As %Status [ CodeMode = generator, ServerOnly = 1 ]
{
}

/// %SortEnd()
/// This method will end a system merge sort for all indices (idxlist is null) or for specified indices
ClassMethod %SortEnd(idxlist As %List = "", commit As %Integer = 1, excludeunique As %Integer = 0) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 1 ]
{
}

}
