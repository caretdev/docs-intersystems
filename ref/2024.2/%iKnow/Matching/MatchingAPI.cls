/// <p>The InterSystems IRIS NLP iKnow technology is now deprecated. Please see the
/// <a href="https://docs.intersystems.com/irislatest/csp/docbook/DocBook.UI.Page.cls?KEY=GIKNOW">product
/// documentation</a> for more detail.</p>
///  This is the main entry point for driving the iKnow Smart Matching mechanisms
Class %iKnow.Matching.MatchingAPI Extends %iKnow.Queries.AbstractAPI [ Deprecated, System = 4 ]
{

///  <p>Match the unique entities in this domain to all Dictionary Terms and Formats in the list of
///  Dictionaries specified through <i>dictIds</i> that haven't been matched in earlier operations.
///  This method is called automatically at the start of a call to <method>MatchSource</method> or
///  <method>MatchSources</method>.</p>
///  <p>Specifying "" for <i>dictIds</i> will match against all Dictionaries in this domain.</p>
///  <p>If a Virtual Source is specified, the entities of this Virtual Source will be matched.</p>
ClassMethod MatchEntityUniques(domainId As %Integer, dictIds As %List = "", vSrcId As %Integer = 0) As %Status
{
}

ClassMethod MatchEntityUniquesJob(domainId As %Integer, dictIds As %List, pMaxEntUniId As %Integer, procN As %Integer = 0, vSrcId As %Integer = 0, xDomDicts As %Boolean = 0, pUseStemming As %Boolean = 0) As %Status [ Internal ]
{
}

///  Checks for a given string to which dictionary elements it matches and stores the result
///  in ^||%IK.DEMatches(i) = $lb(dictId, dictElementId, matchScore, matchedWordBits, isScattered[, language])
///  Using <var>append</var>=1 will leave existing values in ^||%IK.DEMatches untouched.
/// If <var>xDomDicts</var> = 1, we expect negative dictId indices in <var>dictIds</var> and
/// <var>skipDEs</var>, and will output negative dictIds and dictElementIds
ClassMethod CheckDictionaryElementMatches(domainId As %Integer, ByRef string As %String, ByRef dictIds, fullMatchOnly As %Integer = -1, skipDEs = "", append As %Boolean = 0, outVar As %String = "^||%IK.DEMatches", xDomDicts As %Boolean = 0, nGramMatches As %Boolean = 0) As %Status [ Internal ]
{
}

Parameter MatchSourcesEXP [ Internal ] = 1;

///  <p>Matches all sources in the domain, optionally restricted to those satisfying the criteria of a
///  <class>%iKnow.Filters.Filter</class> object provided as <i>filter</i>, against the list of
///  Dictionary IDs passed in <i>dictIds</i>. Use negative numbers to mark cross-domain dictionaries.</p>
///  <p>A Matching Profile to calculate match scores can be specified either by passing in an
/// 	 <class>%iKnow.Matching.MatchingProfile</class> object, or a Matching Profile ID. When
///  passing in the ID, a negative number is treated as a namespace-wide profile, whereas
///  a positive ID will be looked up within the context of the domain.</p>
///  <p>Specifying "" for <i>dictIds</i> will match against all Dictionaries in this domain and
///  passing $$$ALLXDOMDICTIONARIES will match against all cross-domain dictionaries.</p>
ClassMethod MatchSources(domainId As %Integer, filter As %iKnow.Filters.Filter = "", dictIds As %List = "", overrideProfile As %iKnow.Matching.MatchingProfile = "") As %Status
{
}

///  Merges the temporary globals generated by the different processes into the real ones
ClassMethod MergeTempGlobals(domainId As %Integer, procN As %Integer) As %Status [ Internal, Private ]
{
}

Parameter MatchSourceEXP [ Internal ] = 1;

///  <p>Matches an individual source against the list of Dictionary IDs passed in <i>dictIds</i>.
///  Use negative numbers to identify any cross-domain dictionaries to match against.
///  A Matching Profile to calculate match scores can be specified either by passing in an
/// 	 <class>%iKnow.Matching.MatchingProfile</class> object, or a Matching Profile ID. When
///  passing in the ID, a negative number is treated as a namespace-wide profile, whereas
///  a positive ID will be looked up within the context of the domain.</p>
///  <p>Specifying "" for <i>dictIds</i> will match against all Dictionaries in this domain and
///  passing $$$ALLXDOMDICTIONARIES will match against all cross-domain dictionaries.</p>
///  <p>A negative Source ID is interpreted as a Virtual Source.</p>
ClassMethod MatchSource(domainId As %Integer, srcId As %Integer, dictIds As %List = "", overrideProfile As %iKnow.Matching.MatchingProfile = "") As %Status
{
}

ClassMethod MatchSourceJob(domainId As %Integer, filterString As %String = "", dictIds As %List = "", overrideProfile As %iKnow.Matching.MatchingProfile = "", procN As %Integer = 1, xDomDicts As %Boolean = 0) As %Status [ Internal ]
{
}

ClassMethod ProcessCandidates(srcId, vSrcId, ByRef matchIdGlo, ByRef matchIncGlo, ByRef dictToMatchGlo, ByRef entOccToMatchGlo, ByRef dictItemToMatchGlo, ByRef dictToSrcGlo, ByRef srcToMatchGlo, ByRef sentToMatchGlo, sentId, matchScoreMargin) As %Status [ Internal ]
{
}

/// domainId = 0 and deId < 0 for cross-domain dictionaries; returned ids are also <0
ClassMethod GetCachedElement(domainId, deId, Output deInfo, Output dtId = "", Output diId = "", Output dictId = "") As %Status [ Internal, Private ]
{
}

/// domainId = 0 and dtId < 0 for cross-domain dictionaries; returned ids are also <0
ClassMethod GetCachedTerm(domainId, dtId, Output diId = "", Output dictId = "", getElems, Output elems = "", Output relCount = "") As %Status [ Internal ]
{
}

ClassMethod GetCachedTermLength(domainId, dtId, profile, Output conceptCount As %Integer = -1, Output relCount As %Integer = -1) As %Integer [ Internal, Private ]
{
}

ClassMethod ProcessAggregate(domainId, targetType, targetId, ByRef dictProfiles, srcId, vSrcId, ByRef matchIdGlo, ByRef matchIncGlo, ByRef dictToMatchGlo, ByRef entOccToMatchGlo, ByRef dictItemToMatchGlo, ByRef dictToSrcGlo, ByRef srcToMatchGlo, targetLength, ByRef sentToMatchGlo, sentId, matchScoreMargin, stdFormLangId, ikpMatSkipRelations) As %Status [ Internal, Private ]
{
}

///  Update the bitstrings based on IKT gobals generated in the MatchSource* methods
ClassMethod UpdateBitStrings(domainId As %Integer, currentDictElemsArray, vSrcId As %Integer = 0, xDomDicts As %Boolean = 0) As %Status [ Internal, Private ]
{
}

Parameter InvalidateMatchingResultsEXP [ Internal ] = 1;

///  <p>Deletes all current matching results for the list of Dictionary IDs passed in <var>dictIds</var>.</p>
///  <p>Specifying "" for <i>dictIds</i> will drop results for all Dictionaries in this domain.</p>
///  <p><var>pMode</var> can be used to specify whether to keep intermediary (not source-related)
///  matching results as follows:<ul><li>0: only source-related matching results are erased (default)</li>
///  <li>1: the matching results for unique entities are also erased</li><li>2: the matching
///  results for unique entities and indexing results for dictionary terms are all erased (only available if dictIds="")</li></ul>
///  This parameter is mostly for internal use.</p>
///  <p>Note: <var>pMode</var>=2 will not erase the indexing results for dictionary terms of
///  cross-domain dictionaries.<br/>
///  Note: matching results for virtual sources are always completely dropped, regardless of the
///  value of <var>dictIds</var> and with the same effect as <var>pMode</var>=1</p>
ClassMethod InvalidateMatchingResults(domainId As %Integer, dictIds As %List = "", pMode As %Integer = 0) As %Status
{
}

/// Clears all the matching results for a particular Dictionary Item <var>pDictItemId</var> in
/// Dictionary <var>pDictId</var>, optionally narrowed down to a Dictionary Term <var>pDictTermId</var>.
/// <var>pMode</var> values: 0 drops source-level results, 1 drops EU mappings as well and 2
/// also drops the term's indexing results (dictionary elements).
/// If dropping the results for a cross-domain item in a specific domain, all IDs passed in should
/// be negative.
/// This method is for internal use only, as it does not update ^IRIS.IK.Mat.DictMatchStatus!
ClassMethod InvalidateMatchingResultsInternal(pDomainId As %Integer, pDictId As %Integer, pDictItemId As %Integer = "", pMode As %Integer = 0, pDictTermId As %Integer = 0) As %Status [ Internal ]
{
}

///  <p>Push Dictionary Terms for the given dictionaries through the engine and generate appropriate
///  Dictionary Elements, if the Term hadn't been processed before. If <var>domainId</var> = 0,
///  terms for all cross-domain dictionaries will be processed.</p>
///  <p>Internal method, not to be invoked by custom code.</p>
///  <p>NOTE: <var>pDictIds</var> is ignored as from 2013.1! (domain version >=3)</p>
ClassMethod IndexDictionaryTerms(domainId As %Integer, pDictIds As %List = "") As %Status [ Internal ]
{
}

ClassMethod IndexDictionaryTermsJob(pDomainId As %Integer, pDictIds As %List = "", pMaxDictTermId As %Integer, pProcN As %Integer = 0) As %Status [ Internal ]
{
}

/// <p>This method has been deprecated. Use GetHighlighted() in <class>%iKnow.Queries.SentenceAPI</class>.</p>
///  <p>Returns a HTML representation of the given sources sentences in which all matched elements are
///  highlighted according to the parameters specified in this method invocation. At lower subscript
///  levels, all composing parts, literals and matching result info is specified to enable custom
///  highlighting as well.</p>
///  <ul>
///  		<li>Setting <i>displayEveryMatch</i> to 1 will generate markup for every individual match,
///  		whereas 0 (the default) will display at most 1 match per entity to limit the complexity of the output</li>
///  		<li>Through the <i>entOccJSAction</i> and <i>matchJSAction</i> parameters, a JavaScript
///  		method name can be provided to be rendered as onclick actions for either the entity occurrences
///  	or individual matches, taking their respective IDs as arguments.</li>
///  		<li>The <i>dictStyles</i> and <i>matchScoreStyles</i> parameters can be used to supply local
///  		arrays specifying additional style classes to apply to matches for specific dictionaries
///  	and match score windows respectively.</li>
///  </ul>
///  <p>If a negative Source ID is supplied, it is interpreted as a Virtual Source.</p>
/// <p><b>Note:</b> if no JavaScript injection is required, the GetHighlighted() method in
/// <class>%iKnow.Queries.SentenceAPI</class> is a more versatile alternative to this method,
/// supporting simultaneously highlighting matches, attributes, entities, etc. </p>
ClassMethod GetHighlightedSentences(ByRef result, domainId As %Integer, srcId As %Integer, page As %Integer = 1, pageSize As %Integer = 10, filter As %iKnow.Matching.MatchFilter = "", displayEveryMatch = 0, entOccJSAction As %String = "", matchJSAction As %String = "", dictStyles = "", matchScoreStyles = "") As %Status [ Deprecated, Internal ]
{
}

Parameter GetMatchElementsRT = "position:%Integer,entOccId:%Integer,entUniId:%Integer,literal:%String,role:%Integer,matchScore:%Numeric,dictElementId:%Integer,dictElement:%String,matchedWordBits:%String,isScattered:%Boolean,formatOutput:%String,negated:%Boolean";

///  <p>Returns a detailed overview of all the elements in the match target, be it an entity-level,
///  CRC-level or path-level match. The elements that are matched get annotated with the matched
///  elements ID, value and eventually the output from a <class>%iKnow.Matching.Formats.Format</class>
///  class if it was responsible for the match.</p>
///  <p>If a Virtual Source ID is supplied, the query runs in the context of that virtual source.</p>
ClassMethod GetMatchElements(ByRef result, domainId As %Integer, matchId As %Integer, vSrcId As %Integer = 0) As %Status
{
}

Parameter GetMatchesByEntOccRT = "matchId:%Integer,dictId:%Integer,dictItemId:%Integer,dictItemURI:%String,dictTermId:%Integer,targetType:%String,targetId:%Integer,matchScore:%Numeric,matchingConceptCount:%Integer,matchingRelationCount:%Integer,partialMatchCount:%Integer,firstMatchedPosInPath:%Integer,lastMatchedPosInPath:%Integer,isOrdered:%Boolean,negatedEntityCount:%Integer";

///  <p>Returns all the matches for the given Entity Occurrence. Use <i>includeCrcMatches</i>,
///  <i>includePathMatches</i> and <i>includeSentenceMatches</i> to also include any matches for the CRC, Path or Sentence in which this Entity
///  Occurrences participates.</p>
///  <p>Specifying "" for <i>dictIds</i> will return results for all Dictionaries in this domain.</p>
ClassMethod GetMatchesByEntOcc(ByRef result, domainId As %Integer, entOccId As %Integer, dictIds As %List = "", page As %Integer = 1, pageSize As %Integer = 10, includeCrcMatches As %Boolean = 1, includePathMatches As %Boolean = 1, includeSentenceMatches As %Boolean = 1, vSrcId As %Integer = 0) As %Status
{
}

Parameter GetMatchesByPathRT = "matchId:%Integer,dictId:%Integer,dictItemId:%Integer,dictItemURI:%String,dictTermId:%Integer,targetType:%String,targetId:%Integer,matchScore:%Numeric,matchingConceptCount:%Integer,matchingRelationCount:%Integer,partialMatchCount:%Integer,firstMatchedPosInPath:%Integer,lastMatchedPosInPath:%Integer,isOrdered:%Boolean,negatedEntityCount:%Integer";

///  <p>Returns all the matches for the given Path. Use <i>includeEntityMatches</i>,
///  <i>includeCRCMatches</i> and <i>includeSentenceMatches</i> to also include any matches for the Entities this path is composed of
///  and the CRCs or Sentences these Entities participate in.</p>
///  <p>Specifying "" for <i>dictIds</i> will return results for all Dictionaries in this domain.</p>
ClassMethod GetMatchesByPath(ByRef result, domainId As %Integer, pathId As %Integer, dictIds As %List = "", page As %Integer = 1, pageSize As %Integer = 10, includeEntityMatches As %Boolean = 1, includeCrcMatches As %Boolean = 1, includeSentenceMatches As %Boolean = 1) As %Status
{
}

Parameter GetMatchesBySentenceRT = "matchId:%Integer,dictId:%Integer,dictItemId:%Integer,dictItemURI:%String,dictTermId:%Integer,targetType:%String,targetId:%Integer,matchScore:%Numeric,matchingConceptCount:%Integer,matchingRelationCount:%Integer,partialMatchCount:%Integer,firstMatchedPosInPath:%Integer,lastMatchedPosInPath:%Integer,isOrdered:%Boolean,negatedEntityCount:%Integer";

///  <p>Returns all the matches for the given Sentence. Use <i>includeEntityMatches</i>,
///  <i>includeCrcMatches</i> and <i>includePathMatches</i> to control which (target) types of
///  matches should be included in the result.</p>
///  <p>Specifying "" for <i>dictIds</i> will return results for all Dictionaries in this domain.</p>
ClassMethod GetMatchesBySentence(ByRef result, domainId As %Integer, sentenceId As %Integer, dictIds As %List = "", page As %Integer = 1, pageSize As %Integer = 10, includeEntityMatches As %Boolean = 1, includeCrcMatches As %Boolean = 1, includePathMatches As %Boolean = 1) As %Status
{
}

Parameter GetMatchesByCrcOccRT = "matchId:%Integer,dictId:%Integer,dictItemId:%Integer,dictItemURI:%String,dictTermId:%Integer,targetType:%String,targetId:%Integer,matchScore:%Numeric,matchingConceptCount:%Integer,matchingRelationCount:%Integer,partialMatchCount:%Integer,firstMatchedPosInPath:%Integer,lastMatchedPosInPath:%Integer,isOrdered:%Boolean,negatedEntityCount:%Integer";

///  <p>Returns all the matches for the given CRC Occurrence. Use <i>includeEntityMatches</i>,
///  <i>includePathMatches</i> and <i>includeSentenceMatches</i> to also include any matches for the Entities this CRC is composed of
///  and the Paths these Entities participate in.</p>
///  <p>Specifying "" for <i>dictIds</i> will return results for all Dictionaries in this domain.</p>
ClassMethod GetMatchesByCrcOcc(ByRef result, domainId As %Integer, crcOccId As %Integer, dictIds As %List = "", page As %Integer = 1, pageSize As %Integer = 10, includeEntityMatches As %Boolean = 1, includePathMatches As %Boolean = 1, includeSentenceMatches As %Boolean = 1) As %Status
{
}

Parameter GetMatchesBySourceRT = "matchId:%Integer,dictId:%Integer,dictItemId:%Integer,dictItemURI:%String,dictTermId:%Integer,targetType:%String,targetId:%Integer,matchScore:%Numeric,matchingConceptCount:%Integer,matchingRelationCount:%Integer,partialMatchCount:%Integer,firstMatchedPosInPath:%Integer,lastMatchedPosInPath:%Integer,isOrdered:%Boolean,negatedEntityCount:%Integer";

///  <p>Returns all the matches for the given Source, as identified by its external ID.</p>
///  <p>Specifying "" for <i>dictIds</i> will return results for all Dictionaries in this domain.</p>
ClassMethod GetMatchesBySource(ByRef result, domainId As %Integer, externalId As %String, dictIds As %List = "", page As %Integer = 1, pageSize As %Integer = 10) As %Status
{
}

Parameter GetMatchesBySourceIdRT = "matchId:%Integer,dictId:%Integer,dictItemId:%Integer,dictItemURI:%String,dictTermId:%Integer,targetType:%String,targetId:%Integer,matchScore:%Numeric,matchingConceptCount:%Integer,matchingRelationCount:%Integer,partialMatchCount:%Integer,firstMatchedPosInPath:%Integer,lastMatchedPosInPath:%Integer,isOrdered:%Boolean,negatedEntityCount:%Integer";

///  <p>Returns all the matches for the given Source, as identified by its Source ID (interpreted as a Virtual Source if a negative
///  value is supplied).</p>
///  <p>Specifying "" for <i>dictIds</i> will return results for all Dictionaries in this domain.</p>
ClassMethod GetMatchesBySourceId(ByRef result, domainId As %Integer, srcId As %Integer, dictIds As %List = "", page As %Integer = 1, pageSize As %Integer = 10) As %Status
{
}

Parameter GetDictionaryMatchesRT = "dictId:%Integer,dictItemId:%Integer,dictItemURI:%String,dictTermId:%String,dictTerm:%String,dictElementId:%String,type:%String,matchScore:%Numeric,matchedWordBits:%String,isScattered:%Boolean,formatOutput:%String";

///  <p>Returns all potential matches for a given string. This string is treated as if it
///  were a single entity and matched against single-entity Dictionary Terms. To find the
///  matches for a full sentence, first index it and then call <method>GetMatchesBySource</method>
///  using the source ID corresponding to the indexed sentence.</p>
///  <p>A Matching Profile to be used when calculating match scores can be specified either by passing in an
/// 	 <class>%iKnow.Matching.MatchingProfile</class> object, or a Matching Profile ID. When
///  passing in the ID, a negative number is treated as a namespace-wide profile, whereas
///  a positive ID will be looked up within the context of the domain. If no profile is
///  specified, the default profile for this domain will be used.</p>
///  <p>Specifying "" for <i>dictIds</i> will return results for all Dictionaries in this domain.</p>
ClassMethod GetDictionaryMatches(ByRef result As %Integer, domainId As %Integer, string As %String, dictIds As %List = "", page As %Integer = 1, pageSize As %Integer = 10, fullMatchOnly As %Integer = -1, profile As %iKnow.Matching.MatchingProfile = "", language As %String = "", nGramMatches As %Integer = -1) As %Status
{
}

Parameter GetDictionaryMatchesByIdRT = "dictId:%Integer,dictItemId:%Integer,dictItemURI:%String,dictTermId:%String,dictTerm:%String,dictElementId:%String,type:%String,matchScore:%Numeric,matchedWordBits:%String,isScattered:%Boolean,formatOutput:%String";

///  <p>Returns all potential matches for the given entity ID.</p>
///  <p>A Matching Profile to be used when calculating match scores can be specified either by passing in an
/// 	 <class>%iKnow.Matching.MatchingProfile</class> object, or a Matching Profile ID. When
///  passing in the ID, a negative number is treated as a namespace-wide profile, whereas
///  a positive ID will be looked up within the context of the domain. If no profile is
///  specified, the default profile for this domain will be used.</p>
///  <p>Specifying "" for <i>dictIds</i> will return results for all Dictionaries in this domain.</p>
ClassMethod GetDictionaryMatchesById(ByRef result As %Integer, domainId As %Integer, entUniId As %Integer, dictIds As %List = "", page As %Integer = 1, pageSize As %Integer = 10, fullMatchOnly As %Integer = -1, profile As %iKnow.Matching.MatchingProfile = "", language As %String = "") As %Status
{
}

Parameter GetTotalDictionaryScoresBySourceRT = "dictId:%Integer,dictionary:%String,matchCount:%Integer,totalScore:%Numeric";

///  Returns summary information for all matches in a given source (identified by External ID), organized per Dictionary.
ClassMethod GetTotalDictionaryScoresBySource(ByRef result, domainId As %Integer, externalId As %String, sortType As %Integer = {$$$SORTBYFREQUENCY}) As %Status
{
}

Parameter GetTotalDictionaryScoresBySourceIdRT = "dictId:%Integer,dictionary:%String,matchCount:%Integer,totalScore:%Numeric";

///  Returns summary information for all matches in a given source (identified by Source ID), organized per Dictionary.
ClassMethod GetTotalDictionaryScoresBySourceId(ByRef result, domainId As %Integer, srcId As %Integer, sortType As %Integer = {$$$SORTBYFREQUENCY}) As %Status
{
}

Parameter GetTotalItemScoresBySourceRT = "dictId:%Integer,dictionary:%String,dictItemId:%Integer,item:%String,URI:%String,matchCount:%Integer,totalScore:%Numeric";

///  <p>Returns summary information for all matches in a given source (identified by External ID), organized per Dictionary Item.</p>
///  <p>Specifying "" for <i>dictIds</i> will return results for all Dictionaries in this domain.</p>
ClassMethod GetTotalItemScoresBySource(ByRef result, domainId As %Integer, externalId As %String, dictIds As %List = "", sortType As %Integer = {$$$SORTBYFREQUENCY}) As %Status
{
}

Parameter GetTotalItemScoresBySourceIdRT = "dictId:%Integer,dictionary:%String,dictItemId:%Integer,item:%String,URI:%String,matchCount:%Integer,totalScore:%Numeric";

///  <p>Returns summary information for all matches in a given source (identified by Source ID), organized per Dictionary Item.</p>
///  <p>Specifying "" for <i>dictIds</i> will return results for all Dictionaries in this domain.</p>
ClassMethod GetTotalItemScoresBySourceId(ByRef result, domainId As %Integer, srcId As %Integer, dictIds As %List = "", sortType As %Integer = {$$$SORTBYFREQUENCY}) As %Status
{
}

///  Checks which of the supplied dictionary IDs still needs matching for this source and returns
///  the remaining ones in a %List. If "" is supplied as the list of dictionary IDs, it will
///  check against all dictionaries for this domain. Supports virtual sources (negative sourceId).
ClassMethod GetNonMatchedDictsForSource(domainId As %Integer, srcId As %Integer, dictIds As %List = "") As %List [ Internal ]
{
}

Parameter GetTopItemsRT = "dictId:%Integer,dictItemId:%Integer,name:%String,URI:%String,frequency:%Integer,spread:%Integer,score:%Numeric";

///  <p>Returns the Dictionary Items for which most matches have been found in this domain (optionally
///  narrowed down through a <class>%iKnow.Filters.Filter</class> object passed in through <var>filter</var>).
///  Result sort order is controlled by <var>sortType</var>:</p>
///  <ul>
///  		<li>$$$SORTBYFREQUENCY will sort by the number of actual matches for a Dictionary Item</li>
///  		<li>$$$SORTBYSPREAD will sort by the number of distinct documents in which at least one match for the Dictionary Item occurs.</li>
///  		<li>$$$SORTBYSCORE will sort by the total match score of all matches for a Dictionary Item</li>
///  </ul>
///  <p>Specifying "" for <var>dictIds</var> will return results for all Dictionaries in this domain.</p>
ClassMethod GetTopItems(ByRef result, domainId As %Integer, page As %Integer = 1, pageSize As %Integer = 10, filter As %iKnow.Filters.Filter = "", dictIds As %List = "", sortType As %Integer = {$$$SORTBYFREQUENCY}, vSrcId As %Integer = 0) As %Status
{
}

Parameter GetTopTermsByItemIdRT = "dictTermId:%Integer,name:%String,frequency:%Integer,spread:%Integer,score:%Numeric";

///  <p>For a given Dictionary Item, returns all its Dictionary Terms sorted by the number of
///  matches they have, optionally narrowed down through a <class>%iKnow.Filters.Filter</class>
///  object passed in through <var>pFilter</var>).
///  Result sort order is controlled by <var>pSortType</var>:</p>
///  <ul>
///  		<li>$$$SORTBYFREQUENCY will sort by the number of actual matches for the Dictionary Term
///  		<li>$$$SORTBYSPREAD will sort by the number of distinct documents in which at least one match for the Dictionary Term occurs.</li>
///  		<li>$$$SORTBYSCORE will sort by the total match score of all matches for a Dictionary Term</li>
///  </ul>
ClassMethod GetTopTermsByItemId(ByRef pResult, pDomainId As %Integer, pDictItemIds As %List, pFilter As %iKnow.Filters.Filter = "", pSortType As %Integer = {$$$SORTBYFREQUENCY}, vSrcId As %Integer = 0) As %Status
{
}

///  Builds an inverse index of the form index(entUniId) = $lb(dictIds,...) containing all dictionaries
///  that still need to be matched to EUs for entUniId values. The index also contains a second
///  subscript level index(entUniId, dictId) = lastDictElemId indicating that all DEs <= lastDictElemId
///  for that dictId can be skipped while treating larger entUniId values, UP TO the next entUniId entry.
///  For cross-domain dictionaries, dictIds are negative, but corresponding lastDictElemId are positive.
/// Note that this will be StemUniIds when $$$IKPSTEMMING '= 0 !!!
ClassMethod BuildInvertedEntUniMatchedIndex(domainId As %Integer, dictIds As %List, Output index) As %Status [ Internal, Private ]
{
}

ClassMethod GetAllDictsAsList(domainId As %Integer) As %List [ Internal ]
{
}

ClassMethod GetAllDictsAsArray(pDomainId As %Integer, Output pDicts) As %Status [ Internal, Private ]
{
}

ClassMethod GetCurrentDictElems(domainId As %Integer, dictIds As %List, Output asArray = "") As %Status [ Internal, Private ]
{
}

ClassMethod IsFullyMatched(domainId As %Integer, srcId As %Integer, dictIds As %List = "", Output details = "") As %Boolean [ Internal ]
{
}

Parameter GetErrorsRT = "sourceId:%Integer,externalId:%String,errorMessage:%String,date:%Date";

///  Returns any errors registered during the Matching process
ClassMethod GetErrors(ByRef result, domainId As %Integer, since As %Date = 0) As %Status
{
}

Parameter ClearLogsEXP [ Internal ] = 1;

///  Clears any matching-related logfiles for the specified domain.
ClassMethod ClearLogs(domainId As %Integer) As %Status
{
}

///  Clears any temp globals used during previous runs, including aborted ones
///  (processes finishing successfully would clean up themselves)
ClassMethod ClearTemps(domainId As %Integer) As %Status [ Internal ]
{
}

Parameter GetMatchesByDictionaryItemURIRT = "matchId:%Integer,dictTermId:%Integer,sourceId:%Integer,externalId:%String,targetType:%String,targetId:%Integer,targetUniId:%Integer,targetValue:%String,matchScore:%Numeric,matchingConceptCount:%Integer,matchingRelationCount:%Integer,partialMatchCount:%Integer,firstMatchedPosInPath:%Integer,lastMatchedPosInPath:%Integer,isOrdered:%Boolean,negatedEntityCount:%Integer";

///  <p>This query returns all the match occurrences for the Dictionary Item
///  specified through <var>dictItemURI</var>.</p>
///  <p>Specifying a <class>%iKnow.Filters.Filter</class> object as <var>filter</var> will
///  restrict the search space to only those sources satisfying the filters criteria.
///  Through <var>targetTypes</var>, the desired target types can be specified in a %List
///  (defaults to all types).</p>
ClassMethod GetMatchesByDictionaryItemURI(ByRef result, domainId As %Integer, dictItemURI As %String, page As %Integer = 1, pageSize As %Integer = 10, filter As %iKnow.Filters.Filter = "", targetTypes As %List = "", xDomDicts As %Boolean = 0) As %Status
{
}

Parameter GetMatchesByDictionaryItemIdRT = "matchId:%Integer,dictTermId:%Integer,sourceId:%Integer,externalId:%String,targetType:%String,targetId:%Integer,targetUniId:%Integer,targetValue:%String,matchScore:%Numeric,matchingConceptCount:%Integer,matchingRelationCount:%Integer,partialMatchCount:%Integer,firstMatchedPosInPath:%Integer,lastMatchedPosInPath:%Integer,isOrdered:%Boolean,negatedEntityCount:%Integer";

///  <p>This query returns all the match occurrences for the Dictionary Item
///  specified through <var>dictItemId</var>.</p>
///  <p>Specifying a <class>%iKnow.Filters.Filter</class> object as <var>filter</var> will
///  restrict the search space to only those sources satisfying the filters criteria.
///  Through <var>targetTypes</var>, the desired target types can be specified in a %List
///  (defaults to all types).</p>
ClassMethod GetMatchesByDictionaryItemId(ByRef result, domainId As %Integer, dictItemId As %Integer, page As %Integer = 1, pageSize As %Integer = 10, filter As %iKnow.Filters.Filter = "", targetTypes As %List = "", ensureMatched As %Boolean = 1) As %Status
{
}

Parameter GetMatchesByDictionaryTermIdRT = "matchId:%Integer,sourceId:%Integer,externalId:%String,targetType:%String,targetId:%Integer,targetUniId:%Integer,targetValue:%String,matchScore:%Numeric,matchingConceptCount:%Integer,matchingRelationCount:%Integer,partialMatchCount:%Integer,firstMatchedPosInPath:%Integer,lastMatchedPosInPath:%Integer,isOrdered:%Boolean,negatedEntityCount:%Integer";

///  <p>This query returns all the match occurrences for the Dictionary Term
///  specified through <var>pDictTermId</var>.</p>
///  <p>Specifying a <class>%iKnow.Filters.Filter</class> object as <var>pFilter</var> will
///  restrict the search space to only those sources satisfying the filters criteria.
///  Through <var>pTargetTypes</var>, the desired target types can be specified in a %List
///  (defaults to all types).</p>
ClassMethod GetMatchesByDictionaryTermId(ByRef pResult, pDomainId As %Integer, pDictTermId As %Integer, pPage As %Integer = 1, pPageSize As %Integer = 10, pFilter As %iKnow.Filters.Filter = "", pTargetTypes As %List = "", pEnsureMatched As %Boolean = 1) As %Status
{
}

Parameter GetTopMatchesByDictionaryItemURIRT = "targetType:%Integer,targetUniId:%Integer,targetValue:%String,frequency:%Integer,spread:%Integer,bestScore:%Numeric";

///  <p>This query returns the "best" matching results for the Dictionary Item
///  specified through <var>dictItemURI</var>, aggregated by matched unique target
///  (entity, CRC, path or sentence). The meaning of "best" is defined by <var>sortType</var>:
///  if set to $$$SORTBYFREQUENCY or $$$SORTBYSPREAD, results are sorted by decreasing
///  number of matched occurrences, whereas $$$SORTBYSCORE will rank them according to the
///  highest match score. The first two options will yield the most relevant results for
///  entities and CRCs, with the score ranking a better fit for paths and sentences, as they
///  inherently have frequency and spread equal to 1.</p>
///  <p>Specifying a <class>%iKnow.Filters.Filter</class> object as <var>filter</var> will
///  restrict the search space to only those sources satisfying the filters criteria.
///  Through <var>targetTypes</var>, the desired target types can be specified in a %List
///  (defaults to all types).</p>
ClassMethod GetTopMatchesByDictionaryItemURI(ByRef result, domainId As %Integer, dictItemURI As %String, page As %Integer = 1, pageSize As %Integer = 10, filter As %iKnow.Filters.Filter = "", targetTypes As %List = "", sortType As %Integer = {$$$SORTBYFREQUENCY}, xDomDicts As %Boolean = 0) As %Status
{
}

Parameter GetTopMatchesByDictionaryItemIdRT = "targetType:%Integer,targetUniId:%Integer,targetValue:%String,frequency:%Integer,spread:%Integer,bestScore:%Numeric";

///  <p>This query returns the "best" matching results for the Dictionary Item
///  specified through <var>dictItemId</var>, aggregated by matched unique target
///  (entity, CRC, path or sentence). The meaning of "best" is defined by <var>sortType</var>:
///  if set to $$$SORTBYFREQUENCY or $$$SORTBYSPREAD, results are sorted by decreasing
///  number of matched occurrences, whereas $$$SORTBYSCORE will rank them according to the
///  highest match score. The first two options will yield the most relevant results for
///  entities and CRCs, with the score ranking a better fit for paths and sentences, as they
///  inherently have frequency and spread equal to 1.</p>
///  <p>Specifying a <class>%iKnow.Filters.Filter</class> object as <var>filter</var> will
///  restrict the search space to only those sources satisfying the filters criteria.
///  Through <var>targetTypes</var>, the desired target types can be specified in a %List
///  (defaults to all types).</p>
ClassMethod GetTopMatchesByDictionaryItemId(ByRef result, domainId As %Integer, dictItemId As %Integer, page As %Integer = 1, pageSize As %Integer = 10, filter As %iKnow.Filters.Filter = "", targetTypes As %List = "", sortType As %Integer = {$$$SORTBYDOMAINDEFAULT}) As %Status
{
}

/// Utility method to retrieve the Sentence ID for a given match target, as specified by its target type
/// (either of $$$DMTARGETENTITY, $$$DMTARGETCRC, $$$DMTARGETPATH or $$$DMTARGETSENT) and ID.
ClassMethod GetSentenceIdForMatchTarget(domainId As %Integer, targetType As %Integer, targetId As %Integer, vSrcId As %Integer = 0) As %Integer
{
}

/// Utility method to retrieve the Source ID for a given match target, as specified by its target type
/// (either of $$$DMTARGETENTITY, $$$DMTARGETCRC, $$$DMTARGETPATH or $$$DMTARGETSENT) and ID.
ClassMethod GetSourceIdForMatchTarget(domainId As %Integer, targetType As %Integer, targetId As %Integer) As %Integer
{
}

ClassMethod StandardizedForm(pString As %String, pLanguage As %String, pFunction As %String = {$$$IKPMATSTANDARDIZEDFORMTEXT}) As %String [ Internal ]
{
}

Parameter GetTopSourcesByDictionaryRT = "srcId:%Integer,externalId:%String,matchCount:%Integer,totalScore:%Numeric";

/// <p>Returns the sources best matching a given list of dictionaries specified through
/// <var>pDictIds</var>, optionally filtered through <var>pFilter</var>. "Best matching" is
/// defined as having the highest number of matches (if <var>pSortType</var> = $$$SORTBYFREQUENCY)
/// or the highest total match score (if <var>pSortType</var> = $$$SORTBYSCORE).</p>
/// <p>If <var>pNormalizeLength</var> is set to a nonzero value, this number is used as the power
/// of the sources length in entities (occurrences) to normalize the score.</p>
ClassMethod GetTopSourcesByDictionary(ByRef pResult, pDomainId As %Integer, pDictIds As %List, pPage As %Integer = 1, pPageSize As %Integer = 10, pFilter As %iKnow.Filters.Filter = "", pSortType As %Integer = {$$$SORTBYFREQUENCY}, pNormalizeLength As %Numeric = 0) As %Status
{
}

}
