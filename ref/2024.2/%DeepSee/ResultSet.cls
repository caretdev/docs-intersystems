/// This class provides an API for executing queries against DeepSee cubes
/// and viewing the results.<br/>
/// This class extends Zen data model so that it can efficiently
/// work within the Zen MVC framework.
Class %DeepSee.ResultSet Extends %ZEN.DataModel.DataModel [ System = 4 ]
{

/// Debugging flag. If true write out tracing information to the console.
Property %Trace As %Boolean [ InitialExpression = 0 ];

/// Run-time query object that will serve as the source for this result set.
Property %Query As %DeepSee.Query.query [ Internal ];

/// Name of the cube this query is based on.
Property %Cube As %DeepSee.Datatype.string [ Internal ];

/// Canonic (index) name of the cube this query is based on.
Property %CubeKey As %DeepSee.Datatype.string [ Internal ];

/// Query key for the current query.
Property %QueryKey As %DeepSee.Datatype.string [ Internal ];

/// Array of timing and performance statistics for the current query.
Property %Statistics As %DeepSee.Datatype.string [ MultiDimensional ];

/// If true, then use results caching for this query.
Property %UseCache As %Boolean [ InitialExpression = 1 ];

/// If true recompute previously run queries whose data has been updated
/// otherwise return old values.
Property %Recompute As %Boolean [ InitialExpression = 1 ];

/// Holds the number of axes in the current query.
Property %AxisCount As %Integer [ Internal ];

/// Array of named parameters with current values.
/// These are set by the <method>%SetParameterContext</method> method.<br/>
Property %NamedParameters As %Integer [ Internal, MultiDimensional ];

/// This holds the SQL query generated by a DRILLTHROUGH query.
/// Use the <method>%GetListingSQL</method> to get this.
Property %ListingSQL As %String(MAXLEN = 32000) [ Private ];

/// This holds the SQL StatementResult object created by a DRILLTHROUGH query.
/// Use the <method>%GetListingResult</method> to get this.
Property %ListingResult As %SQL.StatementResult [ Private ];

/// List of fields to display for a DRILLTHROUGH query.
/// Use the <method>%GetListingResult</method> to get this.
Property %ListingFields As %List [ Private ];

/// Indicates this is being run within the context of a plugin calculation.
Property %IsPlugIn As %Integer [ InitialExpression = 0 ];

/// Used in plugin concurrency protection
Property %PlugInListingKey As %String;

/// Used in plugin concurrency protection
Property %PlugInContextName As %String;

/// Used in plugin concurrency protection
Property %PlugInContextProp As %String;

/// Used in plugin concurrency protection
Property %PlugInFilters As %ZEN.Datatype.string(XMLPROJECTION = "NONE") [ MultiDimensional, Transient ];

/// Used in plugin concurrency protection
Property %PlugInArguments As %ZEN.Datatype.string(XMLPROJECTION = "NONE") [ MultiDimensional, Transient ];

/// If set, this is the name of a listing within the current cube to use for detail listings.
Property listing As %String(MAXLEN = 255);

/// Number of rows in the current listing query.
Property listingRows As %Integer [ InitialExpression = 0 ];

/// Number of rows within a listing query "page".
Property listingPageSize As %Integer [ InitialExpression = 1000 ];

/// Current "page" of listing query.
Property listingPage As %Integer [ InitialExpression = 1 ];

/// Formatting string to apply to listing results.
Property listingFormatList As %String(MAXLEN = 5000);

/// Store the keys of any locks taken out by this query.
Property %LockKeys As %String [ MultiDimensional ];

/// Store the keys of any locks taken out by ancestors of this query in a lookup index.
/// The presence of locks in this index will mean the locks are already protected at the time
/// of execution for this ResultSet.
Property %AncestorLockKeys As %String [ MultiDimensional ];

/// Lock mode determines whether this resultset is operating in read or write mode.
/// Do not change this property directly - use <method>%SetLockMode</method>.
Property %LockMode As %String [ InitialExpression = "exclusive" ];

/// Current state of the resultset locks.
Property %LocksEngaged As %Boolean [ InitialExpression = 0 ];

/// If true, a private copy of the resultset is available.
Property %UseLocal As %Boolean [ InitialExpression = 0 ];

/// This points to the global location that has the results portion of the resultset.
Property %ResultCacheLocation As %String [ InitialExpression = {$Name($$$DeepSeeResultsGLVN)} ];

/// This points to the global location that has the axis portion of the resultset.
Property %AxisCacheLocation As %String [ InitialExpression = {$Name($$$DeepSeeAxisGLVN)} ];

/// A unique session key for the current resultset.
Property %SessionKey As %String [ InitialExpression = {$I($$$DeepSeeLocalResultsGLVN("session"))} ];

/// Container for the subquery resultsets of this execution.
Property %SubqueryResultSets As %DeepSee.ResultSet [ MultiDimensional ];

/// If true, the private copy of the resultset will not be deleted after the resultset is closed
Property %KeepLocalResults As %Boolean [ InitialExpression = 0 ];

/// Convenience method.<br/>
/// Creates a result set, prepares the query <var>pMDX</var>, and executes it.<br/>
/// Returns an instance of the result set.
ClassMethod %ExecuteDirect(pMDX As %String, ByRef pParms, Output pSC As %Status, pAsync = 0, pWait = 1) As %DeepSee.ResultSet
{
}

/// Given the text of a DeepSee MDX query, <var>pMDX</var>,
/// parse it, convert it to a DeepSee run-time query object, and
/// prepare it so that it can then be executed.<br/>
/// <var>pVariables</var> is an optional list of pivot variable names and their current values.
/// These are substituted for any pivot variable references within the query before it is parsed.<br/>
/// <var>pResolvedMDX</var> is the query text after any pivot variable references have been resolved.
Method %PrepareMDX(pMDX As %String = "", ByRef pVariables, Output pResolvedMDX) As %Status
{
}

/// Given a DeepSee run-time query, <var>pQuery</var>,
/// prepare it so that it can then be executed.
Method %PrepareObject(pQuery As %DeepSee.Query.query, ByRef pVariables) As %Status
{
}

/// Given a DeepSee query key, <var>pQueryKey</var>,
/// (returned by a previous query prepare),
/// restore the state of the query so that it can
/// be executed.<br/>
Method %PrepareKey(pCubeName As %String = "", pQueryKey As %String = "", ByRef pParms, pOriginalMDX As %String = "") As %Status
{
}

/// Specify which listing to use for detail listings.
Method %SetListing(pListing As %String) As %Status
{
}

/// Take a pre-defined set of named parameters and apply them to MDX
/// queries executed against this result set.<br/>
/// This makes it possible to add defined parameters to a query without
/// adding them to the query text. This is different than supplying run-time values
/// for parameters when executing the query.<br/>
/// The named parameter context is an array subscripted by UPPER CASE parameter
/// name and parameter attribute (which can be "VALUE","TYPE",or "CAPTION").<br/>
/// For example:<br/>
/// pContext("CITY","VALUE") = "New York"<br/>
/// Call this before preparing a query.
Method %SetParameterContext(ByRef pContext) As %Status
{
}

/// Return the DeepSee run-time query object currently in use
/// as the source for this result set.
Method %GetQuery() As %DeepSee.Query.query
{
}

/// Return the current Query Key for this Result Set.
/// The result set must be prepared before calling this.
Method %GetQueryKey() As %String
{
}

/// Return the name of the cube this ResultSet is executing against.
/// The result set must be prepared before calling this.
Method %GetCubeName() As %String
{
}

/// Output the cube last data update date in the XMLA format
Method %GetLastDataUpdate() As %String
{
}

/// Output the cube last schema update date in the XMLA format
Method %GetLastSchemaUpdate() As %String
{
}

/// Prepare and execute the listing query for the current MDX statement.
/// Return an SQL ResultSet that can be used to iterate over the listing.
/// If <var>pFieldList</var> is not empty, then it is a $List of fields that
/// should be selected and displayed from the result set.
Method %GetListingResultSet(Output pRS As %SQL.StatementResult, Output pFieldList As %List) As %Status
{
}

/// Return the SQL statement needed to drill into the source table for a DRILLTHROUGH statement.
/// This may return the name of the DataConnector class if that is how the listing is defined.
Method %GetListingSQL() As %String
{
}

/// Test if this is a DRILLTHROUGH statement.
Method %IsDrillThrough() As %Boolean
{
}

/// Return the text of the query currently associated with this result set.
/// This text is generated from the query parse tree and represents the canonic form
/// of the query.
Method %GetQueryText() As %String
{
}

/// Given a cube name and a query key (as returned by the <method>%ExecuteAsync</method>)
/// return the current status of the query.<br/>
/// 0 indicates that nothing has been done; 100 indicates that
/// query execution is complete and that results are ready; a value
/// in between means that work is ongoing.
ClassMethod %GetQueryStatus(pCubeName As %String, pQueryKey As %String, Output pPercentComplete As %Double, Output pSC As %Status, Output pPendingResults As %Boolean) As %Integer
{
}

/// Given a cube name and a query key (as returned by the <method>%ExecuteAsync</method>)
/// return the number of result cells that are returned by the query.<br/>
Method %GetCellCount(pCubeName As %String, pQueryKey As %String, Output pSC As %Status) As %Integer
{
}

/// Cancel the query, if running, specified by the cube name and query key.
ClassMethod %CancelQuery(pCubeName As %String, pQueryKey As %String) As %Status
{
}

/// Instance method version of <method>%GetQueryStatus</method>.
Method %GetStatus(Output pPercentComplete As %Double, Output pSC As %Status, Output pPendingResults As %Boolean) As %Integer
{
}

/// Return the set of named parameters values defined by the query.
Method %GetParameterInfo(Output pParms) As %Status
{
}

/// Execute the current prepared query for this ResultSet.<br/>
/// If defined, <var>pParms</var> is an array of parameter values
/// subscripted by parameter name (case-insensitive). These are supplied
/// to the query and override the default values for any parameters
/// defined by the query.
Method %Execute(ByRef pParms) As %Status
{
}

/// Perform a complete execution of the ResultSet using
/// background agents.<br/>
/// The query must be prepared before calling this method.<br/>
/// If defined, <var>pParms</var> is an array of parameter values
/// subscripted by parameter name (case-insensitive). These are supplied
/// to the query and override the default values for any parameters
/// defined by the query.<br/>
/// If <var>pWait</var> is true, wait for the query to complete execution before
/// returning.<br/>
/// If <var>pAxesOnly</var> is true, then only execute the axes for the query.
Method %ExecuteAsynch(Output pQueryKey As %String, ByRef pParms, pWait As %Boolean = 0, pAxesOnly As %Boolean = 0, pAxesQuery As %String = "") As %Status
{
}

/// Apply the array of parameter values to the currently prepared query.
Method %ExecuteParameters(ByRef pParms) As %Status
{
}

/// Materialize the initial (pre-null-filtered) axes for this ResultSet.
Method %ExecuteAxes() As %Status
{
}

/// Calculate the contents of the result cells for this Result Set.
Method %ExecuteCells() As %Status
{
}

/// For a DRILLTHROUGH query, find the set of source ids that make up
/// the *first* cell in the results and compute the SQL statement needed
/// to fetch the request fields from the source table (either as
/// specified in the query's RETURN clause or the default listing for the cube).
Method %ExecuteListing(pStoreFactBits As %Boolean = 0) As %Status [ Internal ]
{
}

/// Replaces a "tag" in a listing query <var>pSQL</var> (fieldList or straight SQL), using the
/// string in <var>pRewrite</var>. The tag (such as $$$IKSUMMARY) can have zero or more parameters
/// in square brackets, which will be used to replace $$$1, $$$2, etc markers in <var>pRewrite</var>,
/// defaulting to the corresponding positions in <var>pDefaultParams</var> if no value is supplied
/// with the tag. <var>pRewrite</var> is supposed to contain appropriate quotes, as surrounding
/// single and double quotes in the tag itself will be removed.
/// If <var>pDefaultAlias</var> is non-null, it will be appended as the column alias for the rewrite
/// expression. This alias can also contain $$$1, $$$2, etc markers.
/// If <var>pAliasPrefix</var> is set, it will be prepended to any existing (or default) alias.
/// If <var>pStatic</var>=1, the rewrite code is considered to be COS code and run once, with its
/// result then replacing the tag in the query.
ClassMethod RewriteQueryTag(ByRef pSQL As %String, pTagName As %String, pRewrite As %String, pDefaultParams As %List = "", pDefaultAlias As %String = "", pAliasPrefix As %String = "", pStatic As %Boolean = 0) As %Status [ Internal ]
{
}

/// Perform the work of a CREATE or DROP statement.
Method %ExecuteSessionCommand() As %Status [ Internal, Private ]
{
}

/// Return number of visible nodes within the given axis (1-based).
Method %GetAxisSize(pAxis As %Integer) As %Integer
{
}

/// Return the count of columns in results table.
Method %GetColumnCount() As %Integer
{
}

/// Return the count of rows in results table.
Method %GetRowCount() As %Integer
{
}

/// Return number of axes within the result set (not including the slicer).
/// Returns 0 if the query has not been prepared and had its
/// axes executed.<br/>
/// On return, <var>pInfo</var> will contain array of axis number (1-based)
/// to axis top node number.
Method %GetAxisCount(Output pInfo As %Integer) As %Integer
{
}

/// Return true if the current query has to be tested for cell format overrides.
Method %HasCellFormatOverride() As %Boolean
{
}

/// Determine if the format for the given cell has been overridden (such as by
/// currentMember substitution) and return it.
/// <var>pCell...</var> contains the ordinal address of the cell.
Method %GetCellFormatOverride(pCell...) As %String
{
}

/// Get the value of the cell specified by the ordinal cell numbers
/// <var>pCell1</var>, <var>pCell2</var>...<br/>
/// A cell number is the ordinal number of a cell along its axis.<br/>
/// The column axis is axis number 1, the row axis is axis number 2 and so on.<br/>
/// If the result has more dimensions than are provided, or if values are omitted, then the
/// first cell along each additional dimension is used.
Method %GetOrdinalValue(pCell...) As %String
{
}

/// Get the value of the cell specified by the node numbers
/// <var>pNode1</var>, <var>pNode2</var>...
Method %GetValue(pNode...) As %String
{
}

/// Find the axis label(s) for the item with ordinal position
/// <var>pPosition</var> within axis <var>pAxis</var> (1 = cols, 2 = rows).<br/>
/// Returns, via <var>pLabel</var> an array of labels associated with the item
/// from the most specific to the most general.<br/>
/// The return value is the number of labels returned.<br/>
/// Also returns, by reference the format and solve order for the label (higher solve order
/// takes precedence over lower and is used to determine which axis should supply the format for
/// a cell).
/// <var>pClasses</var> an array of classes associated with the item
Method %GetOrdinalLabel(Output pLabel As %String, pAxis As %Integer, pPosition As %Integer, Output pFormat As %String, Output pSolveOrder As %Integer, Output pStyle As %String, Output pHeaderStyle As %String, Output pClasses As %String, Output pTimeFormat As %String) As %Integer
{
}

/// Examine the axis nodes(s) for the item with ordinal position <var>pPosition</var> within axis <var>pAxis</var>,
/// and build an array of nodes contributing to the label at this ordinal position along the axis. The collection of
/// nodes is returned in the format<br>
/// <var>pNodeArray</var>(nodeNumber) = $LB(nodeInfo).
Method %GetOrdinalLabelNodes(pAxis As %Integer, pPosition As %Integer, ByRef pNodeArray) As %Status [ Internal ]
{
}

/// Find the axis key(s) for the item with ordinal position
/// <var>pPosition</var> within axis <var>pAxis</var> (1 = cols, 2 = rows).<br/>
/// Returns, via <var>pKey</var> an array of labels associated with the item
/// from the most specific to the most general.<br/>
/// If the item on the axis has no key (for example, measures), a placeholder "" is inserted into
/// the pKey array to preserve the same structure as returned by <method>%GetOrdinalLabel</method>.<br>
/// The return value is the number of keys returned.<br/>
Method %GetOrdinalKey(Output pKey As %String, pAxis As %Integer, pPosition As %Integer, Output pSpec) As %Integer
{
}

/// Get the total associated with the given row (1-based).<br/>
Method %GetRowTotal(pRow As %Integer, pAgg As %String = "sum") As %String
{
}

/// Get the total associated with the given column (1-based).<br/>
Method %GetColumnTotal(pColumn As %Integer, pAgg As %String = "sum") As %String
{
}

/// Get the grand total for the current query.<br/>
/// This is a simple sum of all cells and not an "aggregate".
Method %GetGrandTotal(pAgg As %String = "sum") As %String
{
}

/// Utility method.<br/>
/// Assemble the query plan for this query.
/// The query must have been successfully executed.
Method %GetPlan(Output pPlan) As %Status
{
}

/// Show plan details for the given query.
/// Do not call this directly.
Method %GetPlanForQuery(ByRef pPlan, pCubeName As %String, pQueryKey As %String, pLevel As %Integer = 0) [ Internal, Private ]
{
}

/// Utility method.<br/>
/// Print out the plan for this query to the console.
/// The query must have been successfully executed.
Method %ShowPlan()
{
}

/// Show plan details for the given query.
Method %ShowPlanForQuery(pCubeName As %String, pQueryKey As %String, pLevel As %Integer = 0) [ Internal, Private ]
{
}

/// Utility method.
/// Print the results of the current query to the console.<br/>
/// If <var>pShowNodeNo</var> is true, show the internal node numbers.<br/>
/// If <var>pMaxRows</var> is defined, limit the number of rows displayed.<br/>
Method %Print(Output pStats, pShowNodeNo As %Boolean = 0, pMaxRows As %Integer = 0) As %Status
{
}

/// Utility method.<br/>
/// For a DRILLTHROUGH query, print out the listing.
Method %PrintListing()
{
}

/// Lower-level function that, given the text of a DeepSee MDX query, <var>pMDX</var>,
/// parses it and converts it to a DeepSee run-time query object without changing
/// the state of this Result Set.
Method %ParseMDX(pMDX As %String, pQuery As %DeepSee.Query.query) As %Status
{
}

/// Get information on the members of a specific axis within the current query.<br/>
/// <var>pAxis</var> is the axis number (1 = cols, 2 = rows, etc.), 0 indicates that
/// information for the slicer axis is to be returned.<br/>
/// Because it is impossible to pre-determine the size of a specific axis, the process
/// private global, <b>^||DeepSee.AxisMembers</b> is used to hold the results.
/// The caller is responsible for killing this global.<br/>
/// On return, <var>pKey</var> contains the top-level subscript for the process private global
/// under which the member information is stored.<br/>
/// The member information takes the form:<br/>
/// ^||DeepSee.AxisMembers(pKey,pAxis,j,k) = $LB(nodeno,text,dimName,hierName,levelName,memberKey,dimNo,hierNo,levelNo,[aggregate])<br/>
/// pKey is the key returned by this method.<br/>
/// pAxis is the axis number.<br/>
/// j is the ordinal position of the tuple within the axis.<br/>
/// k is the ordinal position of the member within the tuple. k is 0 for members that form a stand-alone tuple.
/// Otherwise k starts at 0 and increase towards the end of the tuple.<br/>
/// nodeno is the internal node number corresponding to the member within its axis.<br/>
/// text is the axis caption for the member.<br/>
/// Names are not enclosed within [ ] delimiters.<br/>
/// A fully-qualified name (UNAME) can be constructed by combining the names with the key:<br/>
/// Set tUName = "["_tDimName_"].["_tHierName_"].["_tLevelName_"].&["_tMemberKey_"]"<br/>
/// If <var>pItemNo</var> is provided, then it is the ordinal number of a single member within
/// the axis and only information about this member is returned.<br/>
Method %GetAxisMembers(pAxis As %Integer, Output pKey, pItemNo As %Integer = "") As %Status
{
}

/// Clear out current statistics for this result set.
Method %ClearStatistics()
{
}

/// Get the value of a specific query statistic. e.g. "ParseMDX".<br/>
/// For "query" stats, add "query." to the stat name: e.g. ""query.Slices".
Method %GetStatistic(pStat As %String) As %String
{
}

/// Write out current statistics for this result set.
Method %PrintStatistics()
{
}

/// Apply MDX FORMAT_STRING <var>pFormat</var> to numeric value <var>pValue</var>.
ClassMethod %FormatNumber(pValue As %Decimal, pFormat As %String, Output pType As %String, Output pStyle As %String) As %String
{
}

/// Internal method.<br>
/// Local implementation of DataModel API.
Method %CopyDataFromModel(Output pData, Output pTypes, pSeries As %Integer = "") As %Status [ Internal ]
{
}

/// Internal method.<br>
/// Called by controller to get meta data for the current query.
/// Each metadata value is a csv list.
Method %GetModelInfo(Output pPropNames As %String, Output pPropTypes As %Integer, Output pPropLabels As %String) As %Status [ Internal ]
{
}

/// Find and return an MDX slicer statement that will return the specified range of cells in
/// the current query as a one-cell result.<br/>
/// For convenience, return the measure in play, if possible to determine.
Method %GetSlicerForCellRange(Output pSlicer As %String, pStartRow As %Integer, pStartCol As %Integer, pEndRow As %Integer, pEndCol As %Integer, Output pMeasure As %String) As %Status
{
}

/// Test for %GetFiltersForCellRange.
ClassMethod %TestFilters(pMDX As %String) As %Status [ Internal ]
{
}

/// Find and return a an array of MDX %FILTER statements that will return the specified range of cells in
/// the current query as a one-cell result.<br/>
/// On return, <var>pFilters</var> will contain the filter statement corresponding to each axis (1,2, etc) and the slicer
/// (0).<br/>
/// For convenience, return the measure in play, if possible to determine. For cell ranges with
/// multiple measures, the measure applied to the cell <var>pStartRow</var>, <var>pStartCol</var>
/// is returned.<br/>
Method %GetFiltersForCellRange(Output pFilters As %String, pStartRow As %Integer, pStartCol As %Integer, pEndRow As %Integer, pEndCol As %Integer, Output pMeasure As %String, pAllRows As %Boolean = 0, pAllCols As %Boolean = 0, pSortCol As %Integer = 0, pSortDir As %String = "ASC", ByRef pPluginInfo As %String) As %Status
{
}

/// Provided a (row,col) cell address within this resultset, determine which measure is being applied.
Method %GetCellMetric(pRow As %Integer = 1, pCol As %Integer = 1, pSC As %Status = {$$$OK}) As %String
{
}

/// Output the result of the current query in XML/A
/// format to the current device. The query should be prepared
/// and executed first.<br/>
/// If there is an error, it is assumed that the caller will transform
/// the status value into a SOAP fault.
Method %OutputXMLA() As %Status [ Internal ]
{
}

/// Return the default format string for this result.
/// Also returns the default label (measure name).
Method %GetDefaultFormat(Output pCaption As %String) As %String [ Internal ]
{
}

/// Output the result of the current query in XML/A
/// format to the current device. The query should be prepared
/// and executed first.<br/>
/// If there is an error, it is assumed that the caller will transform
/// the status value into a SOAP fault.
Method %OutputJSON(pPageSize As %Integer, pCurrPage As %Integer, pRowLabels As %List = "", pMaxRows As %Integer = "") As %Status [ Internal ]
{
}

/// If the given query has pending results (such as from plug-ins), update them.
/// Return if there are any additional pending results.
Method %UpdatePendingResults(Output pPending As %Boolean) As %Status
{
}

/// Run the query audit code. (Test version).<br/>
/// This gives customer applications a chance to audit the queries run by DeepSee.
/// This is called whenever a query is executed by %DeepSee.ResultSet.<br/>
/// The query audit code is a valid ObjectScript expression stored in the ^DeepSee.AuditQueryCode global.
/// Audit query code should not write any output to the current device nor
/// should this code kill any % variables required by Zen or DeepSee.<br/>
/// The variable, %dsQuery, will contain the text of the query.
Method %RunQueryAuditCode(pQuery As %DeepSee.Query.query) As %Status
{
}

/// Create an SQL table from DeepSee cube context. Arguments:<br>
/// <var>pCubeName</var> (Required) - The name of the cube the new table should be generated from.<br>
/// <var>pNewTableName</var> (Required) - The name of the table or class definition where the new result is to be stored.
/// This must be a valid Schema.Table or Package.Class name, and the current user must have permission to
/// create this class in the database to which it is mapped.<br>
/// <var>pContext</var> (Optional) - An MDX restriction term which limits the results in the cube. While not required,
/// this is strongly recommended since its ommission will result in the entire cube source being transferred to a table.<br>
/// <var>pListingFields</var> (Optional) - A comma-delimited list of field names to be included in the new table. The field
/// names must exist in the cube's source.<br>
/// <var>pListingName</var> (Optional) - A named listing that is defined for use in the cube. This may be a native listing
/// or a listing defined in a listing group. This will not be used if <var>pListingFields</var> is defined.<br><br>
/// Most commonly this would be called from a KPI Action class. For example, an %OnDashboardAction callback might look like:
/// <example language="cls!member">
///  ClassMethod %OnDashboardAction(pAction As %String, pContext As %ZEN.proxyObject) As %Status
///  {
/// 	Set tSC = $$$OK
/// 	Try {
/// 		Set tFilter = $P(pContext.currFilterSpec," ",2,*)
/// 		Set tNewTableName = "Test.CreateResultTable"
/// 		Set tListingFields = ""
/// 		Set tListingName = "Listing"
/// 		Set tSC = ##class(%DeepSee.ResultSet).%CreateTable(pContext.cubeName, tNewTableName, tFilter, tListingFields, tListingName)
/// 	}
/// 	Catch ex {
/// 		Set tSC = ex.AsStatus()
/// 	}
///
/// 	Quit tSC
///  }
/// </example>
/// For simplicity this example hard codes the name of the new class definition, but this is not recommended in practice. The API will
/// not replace any existing class, returning an error message instead. In order to allow the user to create their own
/// class name, as well as provide the option to set values for tListingFields or tListingName, it is recommended the KPI
/// action launch a popup dialog which manages the user's interaction with these settings and then calls the %CreateTable API.
ClassMethod %CreateTable(pCubeName As %String = "", pNewTableName As %String = "", pContext As %String = "", pListingFields As %String = "", pListingName As %String = "") As %Status
{
}

/// Add a subquery resultset to the list of objects needed to complete this query.
/// Returns zero if there was a failure to set the resultset into the list. Returns
/// the index of the resutlset in the array when successful.
Method %SetSubqueryResultset(pRS As %DeepSee.ResultSet = {$$$NULLOREF}, pStatus As %Status) As %Integer
{
}

/// Initialize this resultset to ready it for executing a new query. This may be called on a newly instantiated
/// ResultSet or on a ResultSet that has already been used to execute a different MDX query.
Method %InitializeResultSet() As %Status
{
}

/// Fill the <property>%LockKeys</property> array for the current query. This will only succeed
/// if the query has been prepared. Keys will be prepended with either "results" or "axis" to indicate
/// whether the particular key applies to the Results cache or the Axis cache, respectively. This does
/// not do the actual work of acquiring locks.<br>
/// Once the locks are determined they are immediately copied to the current %Query object using
/// <method>%CopyLockKeysToQuery</method>. The value of the <var>pWait</var> flag is passed through
/// to this method to maintain proper tracking of the lock hierarchy.
Method %SetLockKeys(pRefreshKeys = 0, pWait = 0) As %Status
{
}

/// Fill the <property>%AncestorLockKeys</property> array for the current ResultSet using the named lock keys defined in
/// <var>pAncestorLocks</var>. This method will support a key set supplied as a comma-delimited string, a $LB, or a COS array.<br>
/// When taking out locks in <method>%AcquireLocks</method> it will be assumed any locks present in this array
/// are held by a waiting parent process and so these particular locks will be exempted.
Method %SetAncestorLockKeys(ByRef pAncestorLocks) As %Status
{
}

/// Clear up the locks held by the process and reset the local state variables. If <var>pLockMode</var> is supplied, use it to set the ResultSet's %LockMode.
Method %ClearLockKeys(pLockMode As %String = "") As %Status
{
}

/// This method copies the current ResultSet's lock keys into the active query to make the
/// references available for subqeries and tasks.
/// If <var>pWait</var> is set, this communicates the current ResultSet intends to wait for results
/// and will maintain a hold on the locks securing the current resources.
Method %CopyLockKeysToQuery(pWait = 0) As %Status
{
}

/// Acquire locks needed to secure access to the shared result and axes caches for this query. The parameter <var>pLockMode</var>
/// controls which type of locks (exclusive/shared) should be attempted, by default this will be the ResultSet's current
/// <property>%LockMode</property> setting. This method returns either<br>
/// 0 - The method was unable to acquire all of the locks associated with this query<br>
/// 1 - The method has successfully acquired all locks needed to safely interact with the shared cache<br>
/// In the event a "0" is returned, any and all locks acquired by this process are released.<br>
/// Optionally the <var>pTimeout</var> parameter may be supplied to instruct this method to wait for a successful lock on the group
/// of lock keys as a whole. The method will return 1 if all locks are obtained before the requested timeout and 0 otherwise.
/// Optional values for this parameter are:<br>
/// -1 [default] - Make one attempt at obtaining the group of locks and return the result.<br>
/// 0 - Wait indefinitely for all locks in the <property>%LockKeys</property> group to be successfully obtained.<br>
/// (positive number) - Wait up to the specified amount of time and return the success status for the <property>%LockKeys</property> group.
Method %AcquireLocks(pStatus As %Status = {$$$OK}, pLockMode As %String = {..%LockMode}, pTimeout = -1) As %Boolean
{
}

/// Release all locks of the type <var>pLockMode</var> held by this ResultSet.
Method %ReleaseLocks(pLockMode As %String = {..%LockMode}) As %Status
{
}

/// Accessor method for changing the <property>%LockMode</property> of this ResultSet.
/// This is protected from changing the mode when locks are engaged.
Method %SetLockMode(pType = "exclusive") As %Status
{
}

/// Create a local copy of the shared Results and Axis caches and reconfigure the location pointers to the private cache data.
Method %SwitchToLocalCache() As %Status
{
}

/// This method returns the pointers to uing the common cache.
Method %SwitchToCommonCache() As %Status
{
}

/// Look at local cache for reading data
Method %SetLocationLocal() As %Status
{
}

/// Look at common cache for reading data
Method %SetLocationCommon() As %Status
{
}

/// This does the actual work of copying results from the shared caches to a local copy unique to this ResultSet's
/// <property>%SessionKey</property>. This operation can only be performed if the ResultSet has locks engaged.
Method %CopyResultToLocal() As %Status
{
}

/// Perform the actual work of deleting the local copies of the Results and Axis caches.
Method %ClearLocalResult() As %Status
{
}

/// This callback method is invoked by the <METHOD>%Close</METHOD> method to
/// provide notification that the current object is being closed.
///
/// <P>The return value of this method is ignored.
Method %OnClose() As %Status [ Private, ServerOnly = 1 ]
{
}

}
