"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[93161],{19949:(e,r,a)=>{a.r(r),a.d(r,{contentTitle:()=>t,default:()=>d,frontMatter:()=>n,toc:()=>o});var s=a(74848),l=a(28453);const n={pagination_prev:null,pagination_next:null},t="%XML.XSLT.Transformer",o=[{value:"XDatas",id:"xdatas",level:2},{value:"ExampleXML",id:"examplexml",level:3},{value:"ExampleXSL",id:"examplexsl",level:3},{value:"Example3XSL",id:"example3xsl",level:3},{value:"Methods",id:"methods",level:2},{value:"BuildParams",id:"buildparams",level:3},{value:"TransformFile",id:"transformfile",level:3},{value:"TransformFileWithCompiledXSL",id:"transformfilewithcompiledxsl",level:3},{value:"TransformStringWithCompiledXSL",id:"transformstringwithcompiledxsl",level:3},{value:"TransformStream",id:"transformstream",level:3},{value:"TransformStreamWithCompiledXSL",id:"transformstreamwithcompiledxsl",level:3},{value:"NormalizeFileName",id:"normalizefilename",level:3},{value:"Example",id:"example",level:3},{value:"Example2",id:"example2",level:3},{value:"Example3",id:"example3",level:3}];function i(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"xmlxslttransformer",children:"%XML.XSLT.Transformer"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"Class %XML.XSLT.Transformer Extends %RegisteredObject [ System = 3 ]\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"For details on using this class"}),", see ",(0,s.jsx)(r.a,{href:"/csp/docbook/Doc.View.cls?FIND=CLASSES+%25XML.XSLT.Transformer",children:"Performing XSLT Transformations"}),"."]}),"\n",(0,s.jsx)(r.p,{children:"Implements an interface to the XSLT Parser. XML contained in a file or binary stream may be transformed"}),"\n",(0,s.jsx)(r.h2,{id:"xdatas",children:"XDatas"}),"\n",(0,s.jsx)(r.h3,{id:"examplexml",children:"ExampleXML"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"XData ExampleXML\n"})}),"\n",(0,s.jsx)(r.h3,{id:"examplexsl",children:"ExampleXSL"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"XData ExampleXSL\n"})}),"\n",(0,s.jsx)(r.h3,{id:"example3xsl",children:"Example3XSL"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"XData Example3XSL\n"})}),"\n",(0,s.jsx)(r.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(r.h3,{id:"buildparams",children:"BuildParams"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"ClassMethod BuildParams(ByRef pParams, pQuoteParams As %Boolean = 1) As %List [ Private ]\n"})}),"\n",(0,s.jsx)(r.h3,{id:"transformfile",children:"TransformFile"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"ClassMethod TransformFile(pSource As %String, pXSL As %String, pOutput As %String, pErrorHandler As %XML.XSLT.ErrorHandler = {$$$NULLOREF}, ByRef pParams = {$$$NULLOREF}, pCallbackHandler = {$$$NULLOREF}, pResolver As %XML.SAX.EntityResolver = {$$$NULLOREF}, pQuoteParams As %Boolean = 0) As %Status\n"})}),"\n",(0,s.jsx)(r.p,{children:"This method transforms a source file according to an XSL stylesheet and writes the output to the specified output file. If errors occur during processing, callbacks will be made to the supplied error handler. If an error handler is not supplied then the default is to use a newly created instance of %XML.XSLT.ErrorHandler. The pParams argument is either a CoS array, or %ArrayOfDataTypes of name/value pairs to be passed as $ variables."}),"\n",(0,s.jsx)(r.h3,{id:"transformfilewithcompiledxsl",children:"TransformFileWithCompiledXSL"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"ClassMethod TransformFileWithCompiledXSL(pSource As %String, pXSL As %XML.XSLT.CompiledStyleSheet, pOutput As %String, pErrorHandler As %XML.XSLT.ErrorHandler = {$$$NULLOREF}, ByRef pParams = {$$$NULLOREF}, pCallbackHandler = {$$$NULLOREF}, pResolver As %XML.SAX.EntityResolver = {$$$NULLOREF}, pQuoteParams As %Boolean = 0) As %Status\n"})}),"\n",(0,s.jsx)(r.p,{children:"This method transforms a source file according to an XSL stylesheet and writes the output to the specified output file. If errors occur during processing, callbacks will be made to the supplied error handler. If an error handler is not supplied then the default is to use a newly created instance of %XML.XSLT.ErrorHandler. The pParams argument is either a CoS array, or %ArrayOfDataTypes of name/value pairs to be passed as $ variables."}),"\n",(0,s.jsx)(r.h3,{id:"transformstringwithcompiledxsl",children:"TransformStringWithCompiledXSL"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"ClassMethod TransformStringWithCompiledXSL(pString As %String, pXSL As %XML.XSLT.CompiledStyleSheet, ByRef pOutput As %String, pErrorHandler As %XML.XSLT.ErrorHandler = {$$$NULLOREF}, ByRef pParams = {$$$NULLOREF}, pCallbackHandler = {$$$NULLOREF}, pResolver As %XML.SAX.EntityResolver = {$$$NULLOREF}, pQuoteParams As %Boolean = 0) As %Status\n"})}),"\n",(0,s.jsx)(r.p,{children:"This method transforms a source file according to an XSL stylesheet and writes the output to the specified output file. If errors occur during processing, callbacks will be made to the supplied error handler. If an error handler is not supplied then the default is to use a newly created instance of %XML.XSLT.ErrorHandler. The pParams argument is either a CoS array, or %ArrayOfDataTypes of name/value pairs to be passed as $ variables."}),"\n",(0,s.jsx)(r.h3,{id:"transformstream",children:"TransformStream"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"ClassMethod TransformStream(pSource As %AbstractStream, pXSL As %AbstractStream, ByRef pOutput As %BinaryStream = {$$$NULLOREF}, pErrorHandler As %XML.XSLT.ErrorHandler = {$$$NULLOREF}, ByRef pParams = {$$$NULLOREF}, pCallbackHandler = {$$$NULLOREF}, pResolver As %XML.SAX.EntityResolver = {$$$NULLOREF}, pQuoteParams As %Boolean = 0) As %Status\n"})}),"\n",(0,s.jsx)(r.p,{children:"This method transforms a source stream according to an XSL stylesheet and writes the output to the supplied binary stream. If errors occur during processing, callbacks will be made to the supplied error handler. If an error handler is not supplied then the default is to use a newly created instance of %XML.XSLT.ErrorHandler. The pParams argument is either a CoS array, or %ArrayOfDataTypes of name/value pairs to be passed as $ variables."}),"\n",(0,s.jsx)(r.h3,{id:"transformstreamwithcompiledxsl",children:"TransformStreamWithCompiledXSL"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"ClassMethod TransformStreamWithCompiledXSL(pSource As %AbstractStream, pXSL As %XML.XSLT.CompiledStyleSheet, ByRef pOutput As %BinaryStream = {$$$NULLOREF}, pErrorHandler As %XML.XSLT.ErrorHandler = {$$$NULLOREF}, ByRef pParams = {$$$NULLOREF}, pCallbackHandler = {$$$NULLOREF}, pResolver As %XML.SAX.EntityResolver = {$$$NULLOREF}, pQuoteParams As %Boolean = 0) As %Status\n"})}),"\n",(0,s.jsx)(r.p,{children:"This method transforms a source stream according to an XSL stylesheet and writes the output to the supplied binary stream. If errors occur during processing, callbacks will be made to the supplied error handler. If an error handler is not supplied then the default is to use a newly created instance of %XML.XSLT.ErrorHandler. The pParams argument is either a CoS array, or %ArrayOfDataTypes of name/value pairs to be passed as $ variables."}),"\n",(0,s.jsx)(r.h3,{id:"normalizefilename",children:"NormalizeFileName"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"ClassMethod NormalizeFileName(pFilename As %String) As %String\n"})}),"\n",(0,s.jsx)(r.h3,{id:"example",children:"Example"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"ClassMethod Example()\n"})}),"\n",(0,s.jsx)(r.p,{children:"Example, Transform a stream. For this example, streams are derived from XDATA blocks within this class. In a real-world scenario streams would come from an external source"}),"\n",(0,s.jsx)(r.h3,{id:"example2",children:"Example2"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"ClassMethod Example2()\n"})}),"\n",(0,s.jsx)(r.p,{children:"Example 2, Transform a stream. For this example, streams are derived from XDATA blocks within this class. In a real-world scenario streams would come from an external source. The XSL specification is first compiled and then is used to transform the source. This is useful for when the same stylesheet needs to be applied to many different xml sources as it can result in considerable performance improvements."}),"\n",(0,s.jsx)(r.h3,{id:"example3",children:"Example3"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-objectscript-class",children:"ClassMethod Example3()\n"})}),"\n",(0,s.jsx)(r.p,{children:"Example3, Transform a stream. For this example, streams are derived from XDATA blocks within this class. In a real-world scenario streams would come from an external source. Here we install the default Callback Handler"})]})}function d(e={}){const{wrapper:r}={...(0,l.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}},28453:(e,r,a)=>{a.d(r,{R:()=>t,x:()=>o});var s=a(96540);const l={},n=s.createContext(l);function t(e){const r=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),s.createElement(n.Provider,{value:r},e.children)}}}]);