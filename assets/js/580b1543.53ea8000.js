"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[72911],{78516:(e,r,n)=>{n.r(r),n.d(r,{contentTitle:()=>s,default:()=>d,frontMatter:()=>a,toc:()=>i});var t=n(74848),o=n(28453);const a={pagination_prev:null,pagination_next:null},s="SYS.MirrorDejournal",i=[{value:"Parameters",id:"parameters",level:2},{value:"%MODULENAME",id:"modulename",level:3},{value:"Properties",id:"properties",level:2},{value:"InCatchupDB",id:"incatchupdb",level:3},{value:"Methods",id:"methods",level:2},{value:"DejournalReader",id:"dejournalreader",level:3},{value:"DejournalProcessFile",id:"dejournalprocessfile",level:3},{value:"CatchupProcessFile",id:"catchupprocessfile",level:3},{value:"RunFilter",id:"runfilter",level:3}];function l(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"sysmirrordejournal",children:"SYS.MirrorDejournal"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-objectscript-class",children:"Class SYS.MirrorDejournal Extends %Library.SystemBase [ Not Final ]\n"})}),"\n",(0,t.jsx)(r.p,{children:"The SYS.MirrorDejournal class is a superclass for users to set up their custom mirror dejournal filter class. The custom class name should start with 'Z' or 'z' so it that is preserved during upgrade. Implement the RunFilter() method and place your filter code in that method."}),"\n",(0,t.jsx)(r.h2,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsx)(r.h3,{id:"modulename",children:"%MODULENAME"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-objectscript-class",children:"Parameter %MODULENAME [ Internal ] = 8;\n"})}),"\n",(0,t.jsx)(r.h2,{id:"properties",children:"Properties"}),"\n",(0,t.jsx)(r.h3,{id:"incatchupdb",children:"InCatchupDB"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-objectscript-class",children:"Property InCatchupDB As %Boolean;\n"})}),"\n",(0,t.jsx)(r.p,{children:"For use in RunFilter. True when dejournaling is occurring as part of a manual database catchup operation; false when dejournaling is occurring automatically during normal mirror operation."}),"\n",(0,t.jsx)(r.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(r.h3,{id:"dejournalreader",children:"DejournalReader"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-objectscript-class",children:"Method DejournalReader(SharedID As %CPP.Integer, JournalPos As %CPP.Integer, FileName As %CPP.String, MirrorFileCount As %CPP.LongLong) As %String [ Final, Internal, Language = cpp ]\n"})}),"\n",(0,t.jsx)(r.p,{children:"Function called after mirror connection is established to primary member by dejournal reader daemon."}),"\n",(0,t.jsx)(r.h3,{id:"dejournalprocessfile",children:"DejournalProcessFile"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-objectscript-class",children:"Method DejournalProcessFile(SharedID As %CPP.Integer, StartPos As %CPP.Integer, FileName As %CPP.String, MirrorFileCount As %CPP.LongLong) As %String [ Final, Internal, Language = cpp ]\n"})}),"\n",(0,t.jsx)(r.p,{children:"Function called before mirror connection is established to primary member. After journal file is retrieved from primary and is applied to mirrored databases."}),"\n",(0,t.jsx)(r.h3,{id:"catchupprocessfile",children:"CatchupProcessFile"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-objectscript-class",children:"Method CatchupProcessFile(SharedID As %CPP.Integer, StartPos As %CPP.Integer, StopPos As %CPP.Integer) As %String [ Final, Internal, Language = cpp ]\n"})}),"\n",(0,t.jsx)(r.p,{children:"Function called by SYS.Mirror.CatchupDB() method, to restore mirror journal records to mirrored databases."}),"\n",(0,t.jsx)(r.h3,{id:"runfilter",children:"RunFilter"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-objectscript-class",children:"Method RunFilter(MirrorDBName As %String, GlobalReference As %String, RecordType As %String, Address As %Integer) As %Integer\n"})}),"\n",(0,t.jsx)(r.p,{children:"When mirror dejournal filtering is enabled, this method is called for every record that is about to be dejournaled. To implement a dejournal filter, override this method and add the code that is to be executed when mirror journal files are dejournaled."}),"\n",(0,t.jsx)(r.p,{children:"Arguments as follows will be passed to this method providing information about the record:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"MirrorDBName - The mirrored database name of the journal record, in the format of :mirror:MIRRORNAME:MIRRORDBNAME"}),"\n",(0,t.jsx)(r.li,{children:"GlobalReference - Global reference in the form of MyGlobal(subscripts), without the leading ^"}),"\n",(0,t.jsx)(r.li,{children:'RecordType - Type of journal record; values are "S" for SET, "s" for SET $BIT, "VS" for SET $VECTOR, "K" for KILL, "k" for ZKILL, and "VK" for KILL $VECTOR'}),"\n",(0,t.jsx)(r.li,{children:"Address - Offset of the record in the journal file"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Return 1 to indicate that the record is to be dejournaled or 0 to request that it be skipped. Skipping the record in this way is only allowed if the FailoverDB flag in the database is cleared, meaning that it is a read-write mirror database. If the FailoverDB flag in the database is set, the return value is ignored, and the record is dejournaled. The RunFilter code executes for each record regardless of the state of the FailoverDB flag; it can perform any operations that do not modify the read-only mirrored databases."}),"\n",(0,t.jsxs)(r.p,{children:["Other information about the journal record can be extracted as needed by using the value of Address in macros provided by the ",(0,t.jsx)(r.strong,{children:"%syJrnRecord"})," include file. In particular:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"$$$JRNPID(Address) - returns the process ID, or if it is a multi-threaded callin process, returns the composite job ID."}),"\n",(0,t.jsx)(r.li,{children:"$$$JRNTSTAMP(Address) - returns the timestamp of the journal record in $HOROLOG format."}),"\n",(0,t.jsx)(r.li,{children:'$$$JRNNEWVAL(Address) - returns the value of the SET record for RecordType "S" only; throws an error on other record types.'}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"If errors are thrown from this method (ie an error occurs and is not handled within the method itself), mirror dejournaling will abort."}),"\n",(0,t.jsx)(r.p,{children:"Dejournaling to mirrored databases occurs both as part of normal mirror operation and as part of manual catchup. The two types of dejournaling can occur concurrently (in different processes) and manual catchup can be working with substantially older journal records. Implementations of RunFilter that need to be sensitive to this difference can inspect the value of InCatchupDB."})]})}function d(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>i});var t=n(96540);const o={},a=t.createContext(o);function s(e){const r=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);