"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[77222],{87758:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>o,default:()=>h,frontMatter:()=>s,toc:()=>a});var i=t(74848),r=t(28453);const s={pagination_prev:null,pagination_next:null},o="%iFind.Synonym",a=[{value:"Properties",id:"properties",level:2},{value:"FromTerm",id:"fromterm",level:3},{value:"ToTerm",id:"toterm",level:3},{value:"Methods",id:"methods",level:2},{value:"GetMatch",id:"getmatch",level:3}];function l(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ifindsynonym",children:"%iFind.Synonym"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"Class %iFind.Synonym Extends %Persistent [ NoExtent ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"To leverage the iFind synonym expansion functionality, users have to create the class which extends  %iFind.Synonym ."}),"\n",(0,i.jsx)(n.p,{children:"Users could define the synonym pair by inserting (FromTerm,ToTerm) pair into the synonym table. Both FromTerm and ToTerm could be just single word or multuple words. If ToTerm consists of multiple word, it is implicitly treated as a iFind positional search phrase after expansion. For Japanese, user should ensure the ToTerm is always an single valid term, since iFind do not support positional search for Japanese"}),"\n",(0,i.jsx)(n.p,{children:'For synonym pair like (New York,NY), "NY" is automatically expanded into your query phrase. For (ISC, Inter*System* Corp),the iFind positional search phrase (Inter*System* Corp) get expanded into the original query.'}),"\n",(0,i.jsx)(n.p,{children:'So if the text contains a phrase like "InterSystems Corp", it is a match. One thing should be noted is that the minimum mathcing unit in the query is the single word or an valid positional search phrase. This means iFind won\'t try to perform query expanion for the single word of the positioal phrase. You have to explicitly specify the whole positional search phrase in the synonym table, (New York, NY) is an example here.'}),"\n",(0,i.jsx)(n.p,{children:"Users could use the default logic implemented in GetMatch() to decide where the term of the indexed text matches to FromTerm or not. Users could also overwrite the default implementation in GetMatch to provide your own matching logic."}),"\n",(0,i.jsx)(n.p,{children:"To supply the synonym tables during query, users should provide a comma seperated list which contain the full qualified name of those synonym tables to the fifth parameter of search_index()."}),"\n",(0,i.jsxs)(n.p,{children:['Suppose users define two synonym tables called "iFind.Sym1" and "iFind.Sym2",',(0,i.jsx)(n.br,{}),"\nThe query leveraing the single synonym table expansion could be like:",(0,i.jsx)(n.br,{}),"\nselect * from Sample.Tab where %ID %FIND search_index(iFind_Index,'query terms',,,'iFind.Sym1')"]}),"\n",(0,i.jsxs)(n.p,{children:["The query leveraing multiple synonym tables expansion could be like:",(0,i.jsx)(n.br,{}),"\nselect * from Sample.Tab where %ID %FIND search_index(iFind_Index,'query terms',,,'iFind.Sym1,iFind.Sym2')"]}),"\n",(0,i.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,i.jsx)(n.h3,{id:"fromterm",children:"FromTerm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"Property FromTerm As %String [ Required ];\n"})}),"\n",(0,i.jsx)(n.h3,{id:"toterm",children:"ToTerm"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"Property ToTerm As %String [ Required ];\n"})}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsx)(n.h3,{id:"getmatch",children:"GetMatch"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod GetMatch(Source As %String, ByRef Matches, ByRef IndexParam) As %Status\n"})}),"\n",(0,i.jsx)(n.p,{children:'This function returns all the ToTerm in the synonym table in which the FromTerm is exactly identical with Source The results are placed in Matches with the format Matches("ToTerm") = ""'}),"\n",(0,i.jsx)(n.p,{children:'The IndexParam should contain all the parameters defined for the specific iFind index in which you would like to perform synonym expansion. For example, if you define "LOWER" for this specific iFind index, the GetMatch would also follow the "LOWER" setting to decide whether this match has be case sensitive or case insensitive.'}),"\n",(0,i.jsx)(n.p,{children:'Note: any wildcard in the Source would be treated as normal character. For example, if the FromTerm is "InterSystems" and the Source is "InterSystem*", the Source would not match this FromTerm. Also, GetMatch performs language independent exact match, this implies each FromTerm could belong to different languages.'})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);