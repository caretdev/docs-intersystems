"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[52058],{36633:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>a,default:()=>o,frontMatter:()=>s,toc:()=>d});var r=n(74848),i=n(28453);const s={pagination_prev:null,pagination_next:null},a="%XML.ImportHandler",d=[{value:"Properties",id:"properties",level:2},{value:"Tree",id:"tree",level:3},{value:"Node",id:"node",level:3},{value:"CurrentText",id:"currenttext",level:3},{value:"PrefixMap",id:"prefixmap",level:3},{value:"DocumentId",id:"documentid",level:3},{value:"DOMName",id:"domname",level:3},{value:"Methods",id:"methods",level:2},{value:"%OnNew",id:"onnew",level:3},{value:"%OnClose",id:"onclose",level:3},{value:"OnPostParse",id:"onpostparse",level:3},{value:"AddWSSecurityIds",id:"addwssecurityids",level:3},{value:"AddIDs",id:"addids",level:3},{value:"GetNextId",id:"getnextid",level:3},{value:"CopyDocument",id:"copydocument",level:3},{value:"KillDocument",id:"killdocument",level:3},{value:"GetAttributeMap",id:"getattributemap",level:3},{value:"SetAttribute",id:"setattribute",level:3},{value:"RemoveAttribute",id:"removeattribute",level:3},{value:"GetNameIndex",id:"getnameindex",level:3},{value:"GetNamespaceIndex",id:"getnamespaceindex",level:3},{value:"ExtendChildList",id:"extendchildlist",level:3},{value:"InsertDescriptor",id:"insertdescriptor",level:3},{value:"RemoveDescriptor",id:"removedescriptor",level:3},{value:"NextChild",id:"nextchild",level:3},{value:"GetNextChild",id:"getnextchild",level:3},{value:"GetPreviousChild",id:"getpreviouschild",level:3},{value:"startDocument",id:"startdocument",level:3},{value:"endDocument",id:"enddocument",level:3},{value:"startElement",id:"startelement",level:3},{value:"endElement",id:"endelement",level:3},{value:"characters",id:"characters",level:3},{value:"startPrefixMapping",id:"startprefixmapping",level:3},{value:"endPrefixMapping",id:"endprefixmapping",level:3},{value:"error",id:"error",level:3},{value:"fatalError",id:"fatalerror",level:3},{value:"warning",id:"warning",level:3},{value:"SaveError",id:"saveerror",level:3},{value:"Dump",id:"dump",level:3},{value:"GetAttribute",id:"getattribute",level:3},{value:"SerializeAttribute",id:"serializeattribute",level:3},{value:"SerializeBase64Attribute",id:"serializebase64attribute",level:3},{value:"SerializeNode",id:"serializenode",level:3},{value:"SerializeBase64Node",id:"serializebase64node",level:3},{value:"hextobin",id:"hextobin",level:3},{value:"output",id:"output",level:3}];function l(e){const t={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"xmlimporthandler",children:"%XML.ImportHandler"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Class %XML.ImportHandler Extends %XML.SAX.ContentHandler [ System = 2 ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"SAX Content handler for ObjectScript XML Implementation."}),"\n",(0,r.jsx)(t.p,{children:"This class and the data structure defined here is used internally by InterSystems IRIS. You should not make direct use of this class or data structure within your applications. The global data structure may be accessed using the macros in %xmlDOM.inc or by using the %XML.Node class. There is no guarantee made about either the behavior or future operation of this class."}),"\n",(0,r.jsx)(t.p,{children:"This content handler stores the XML document as nodes of a tree. The GlobalName property determines where these nodes are stored. The default for the GlobalName property is ^||%xmlTemp. The Tree property determines the specific node used to store the nodes of the tree. The structure of the tree is as follows:"}),"\n",(0,r.jsx)(t.p,{children:"The tree is stored @..GlobalName@(..Tree) which is stored in ..DocumentId. @..GlobalName@(..Tree) - number of nodes. @i%DocumentId@(node) describes the node given by the integer node number."}),"\n",(0,r.jsxs)(t.p,{children:["Each XML DOM node will be described by a 4 character entry node descriptor. Since any node will be the child of an element node, the node descriptor entries will be stored in the childlist of its parent which is in the element descriptor node or one of its extension nodes. The attribute nodes will be first in the element descriptor node in the order that they are presented by Xerces.  Element and character node entries follow in the XML document order. Each element descriptor is limited to the maximum length ObjectScript string. Thus provision is made for extension child lists. The list of element and character nodes is terminated by a next descriptor node which is a reference to the next extension or 0 for the last. Each element descriptor node and element descriptor extension node is structured as follows:",(0,r.jsx)(t.br,{}),"\n@i%DocumentId@(node) is 28 character base followed by the list of node descriptors. @i%DocumentId@(node) = CLparent_CLoffset_name_(prefix|flags)",(0,r.jsx)(t.em,{children:"elementOffset_URI_line_column_ChildList     CLparent($zlchar) is the node number of the parent's child list which contains this node's descriptor.     CLoffset($zlchar) is the 1-based offset in characters in CLparent node of this node's descriptor.     name ($zlchar) - index of element name in the name dictionary.     prefix($zlchar\\16) - index of the prefix part of the QName (including ':') in the name dictionary or 0 if no prefix          If the qname and the unqualified name are the same, then the prefix is not present.     flags($zlchar#16)         right-most bit (1) if xsi:nil or xsi:null specified as true or 1         second bit (2) is skip flag     elementOffset($zwchar) is the offset of the first child element in the child list.          This value is 29+(numAttrs*16) for the first child list and 29 for all subsequent child lists.     URI($zwchar) is index of the URI for this element or not stored.     line($zlchar) part of the location for element node.     column($zlchar) part of the location for element node.      ChildList is list of attribute, element and character entries.  A document node is introduced which represents the document and has as its child the root element of the document. Node 0 is the document node and node 1 is the child list for the document node. @i%DocumentId@(0) = documentBase_documentChildlist @i%DocumentId@(1) = rootElementDescriptor    documentBase:  $zlchar(0,0,0,0,0)"}),"$zwchar(29,0)_$zlchar(0,0)    documentChildList:  $zlchar(16) i.e 1 shifted left 4    rootElementDescriptor:  $zlchar(0,0,0)",(0,r.jsx)(t.em,{children:'name_prefix_elementOffset_URI_line_column       name, URI, prefix, elementOffset, line, column refer to the root element.       See below for definition of element descriptor.  There are 4 types of node descriptors: attribute, element, character and next.  The attribute node descriptor (length 16):  name_prefix_URI_valueURI_value    name($zlchar) is the attribute name    prefix($zlchar) - index of the prefix (including \':\') in the name dictionary or 0 if no prefix    URI($zwchar) - index of the namespace URI for this attriibute or 0 if no namespace.    valueURI($zwchar) - index of the namespace URI corresponding to the prefix when the attribute value is of the form "prefix:value".    value($zlchar) - index of the value of the attribute in the name dictionary  The element node descriptor:  elementDescriptor|type     elementDescriptor($zlchar\\16) is the node number of the elementDescriptor for this element.     type($zlchar#16) of the node: 0 for element  The character node descriptor:  valueindex|type     valueindex($zlchar\\16) - data dictionary index of character value of the node.     type($zlchar#16) of the node: 1 for character data or 2 for character data that is only whitespace.  The next node descriptor:  next|type     next($zlchar\\16) - index of next element descriptor extension.     type($zlchar#16) of the node: 3 for next element descriptor.  Errors and warnings are returned as follows. The SAX parser also returns immediately following a fatal error with an error status: @i%DocumentId@(type)=count where type is "fatalerror", "error" or "warning". @i%DocumentId@(type,index)=message  Elements with "id" attributes are indexed as follows: @i%DocumentId@("i",id)=CLparent'}),'","_CLoffset      id is the value of "id" atribute      CLparent is the node number of the parent\'s child list which contains this node\'s descriptor.      CLoffset is the 1-based offset in characters in CLsub node of this node\'s descriptor.  The name dictionary is used to store prefixes, attribute values and node values as well as names. The name dictionary used in this XML document is maintained as: @i%DocumentId@("d")=the number of names, values, or prefixes including \':\' used by this XML document. @i%DocumentId@("d",index)=name If the value is > than the max node length, then extensions are stored as followed numbered from 1: @i%DocumentId@("d",index,subnodeIndex)=    Reverse "D" name to index is only used for COS code added names.  Not for names added by Xerces parser. @i%DocumentId@("D",name)=index     where name is a name or prefix and     index is the integer index used for this name.  The list of namespaces used in this XML document is maintained as: @i%DocumentId@("n")=the number of namespaces used by this XML document. @i%DocumentId@("n",index)=namespace @i%DocumentId@("N",namespace)=index     where namespace is the the uri for a namespace and     index is the integer index used for this namespace in the "u" and "v" nodes above. @i%DocumentId@("N","',(0,r.jsx)(t.a,{href:"http://www.w3.org/2001/XMLSchema-instance%22)=1",children:'http://www.w3.org/2001/XMLSchema-instance")=1'}),' and @i%DocumentId@("n",1)="',(0,r.jsx)(t.a,{href:"http://www.w3.org/2001/XMLSchema-instance",children:"http://www.w3.org/2001/XMLSchema-instance"}),'" are always true     to allow easy lookup of the schema instance namespace: "',(0,r.jsx)(t.a,{href:"http://www.w3.org/2001/XMLSchema-instance",children:"http://www.w3.org/2001/XMLSchema-instance"}),'"  The version of the internal content handler is given by a single integer in @i%DocumentId@("v")=version integer -- currently 4']}),"\n",(0,r.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,r.jsx)(t.h3,{id:"tree",children:"Tree"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Property Tree As %Integer [ Internal ];\n"})}),"\n",(0,r.jsx)(t.p,{children:"Integer tree id within ..GlobalName global"}),"\n",(0,r.jsx)(t.h3,{id:"node",children:"Node"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Property Node As %Integer [ Internal ];\n"})}),"\n",(0,r.jsx)(t.p,{children:"Current child list node. 0 means the document."}),"\n",(0,r.jsx)(t.h3,{id:"currenttext",children:"CurrentText"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Property CurrentText As %String [ Internal ];\n"})}),"\n",(0,r.jsx)(t.p,{children:"Current characcter data that is being built"}),"\n",(0,r.jsx)(t.h3,{id:"prefixmap",children:"PrefixMap"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Property PrefixMap As %String [ Internal, MultiDimensional ];\n"})}),"\n",(0,r.jsx)(t.p,{children:"Store a stack of prefixes and associated namespaces."}),"\n",(0,r.jsx)(t.h3,{id:"documentid",children:"DocumentId"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Property DocumentId As %String [ Internal ];\n"})}),"\n",(0,r.jsx)(t.p,{children:"DocumentId for XML parse tree."}),"\n",(0,r.jsx)(t.h3,{id:"domname",children:"DOMName"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Property DOMName As %String [ Internal ];\n"})}),"\n",(0,r.jsx)(t.p,{children:"DOMName is used in COS code as the name of the DOM data structure"}),"\n",(0,r.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(t.h3,{id:"onnew",children:"%OnNew"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method %OnNew(globalName As %String, handlerType As %Integer) As %Status [ Internal ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"onclose",children:"%OnClose"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method %OnClose() As %Status [ Internal ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"onpostparse",children:"OnPostParse"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method OnPostParse() As %Status [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"Callback after XML parse complete. Used to set DocumentId."}),"\n",(0,r.jsx)(t.h3,{id:"addwssecurityids",children:"AddWSSecurityIds"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method AddWSSecurityIds() [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"Adds the elements with the wsu:Id to the id table."}),"\n",(0,r.jsx)(t.h3,{id:"addids",children:"AddIDs"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method AddIDs()\n"})}),"\n",(0,r.jsx)(t.p,{children:"Adds the elements with ID attribute to the id table."}),"\n",(0,r.jsx)(t.h3,{id:"getnextid",children:"GetNextId"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method GetNextId(ByRef id As %String) As %String\n"})}),"\n",(0,r.jsx)(t.p,{children:"Gets the next id for this document based on the id table and returns in id argument. The nodeid for the rewturned id is the return value."}),"\n",(0,r.jsx)(t.h3,{id:"copydocument",children:"CopyDocument"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method CopyDocument() As %String\n"})}),"\n",(0,r.jsx)(t.p,{children:"Make a copy of the document to another node in the same global. Return the document id of the copy."}),"\n",(0,r.jsx)(t.h3,{id:"killdocument",children:"KillDocument"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod KillDocument(documentId)\n"})}),"\n",(0,r.jsx)(t.p,{children:"Kill the document specified by the documentId argument"}),"\n",(0,r.jsx)(t.h3,{id:"getattributemap",children:"GetAttributeMap"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod GetAttributeMap(documentId As %String, nodeId As %String) As %Integer [ Internal ]\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Map name to attribute index for all attributes associated with a node.",(0,r.jsx)(t.br,{}),'\nFormat is @documentId@("a",name)=attribute',(0,r.jsx)(t.br,{}),"\nReturn count of attributes"]}),"\n",(0,r.jsx)(t.h3,{id:"setattribute",children:"SetAttribute"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod SetAttribute(documentId As %String, ByRef nodeId As %String, name As %String, value As %String, begin As %Integer, end As %Integer) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"Set the specified part of the internal attribute."}),"\n",(0,r.jsx)(t.h3,{id:"removeattribute",children:"RemoveAttribute"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod RemoveAttribute(documentId As %String, ByRef nodeId As %String, name As %String, namespace As %String) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"Remove the specified attribute."}),"\n",(0,r.jsx)(t.h3,{id:"getnameindex",children:"GetNameIndex"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod GetNameIndex(docId As %String, name As %String, create As %Boolean = 1) As %Integer [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"GetNameIndex returns the index associated with a name in the document's dictionary. If the name does not exist in the dictionary, it is added"}),"\n",(0,r.jsx)(t.h3,{id:"getnamespaceindex",children:"GetNamespaceIndex"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod GetNamespaceIndex(docId As %String, namespace As %String) As %Integer [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"GetNamespaceIndex returns the index associated with a namespace in the document's dictionary. If the namespace does not exist in the dictionary, it is added"}),"\n",(0,r.jsx)(t.h3,{id:"extendchildlist",children:"ExtendChildList"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod ExtendChildList(docId As %String, ByRef CLid As %Integer, desc As %String) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"Get the child list from parent node"}),"\n",(0,r.jsx)(t.h3,{id:"insertdescriptor",children:"InsertDescriptor"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod InsertDescriptor(documentId As %String, attribute As %Boolean, ByRef CLid As %Integer, ByRef offset As %Integer, desc As %String) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"Insert a descriptor in a child list by moving the specified descriptor. CLid and offset are updated for the new value when the node is moved."}),"\n",(0,r.jsx)(t.h3,{id:"removedescriptor",children:"RemoveDescriptor"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod RemoveDescriptor(documentId As %String, CLid As %Integer, offset As %Integer, len As %Integer) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"Remove a descriptor from a child list"}),"\n",(0,r.jsx)(t.h3,{id:"nextchild",children:"NextChild"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod NextChild(docId As %String, parent As %String, ByRef parentChildlist As %String, childId As %String, Output descriptor As %String) As %String [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:'Return the next child of the specified nodeId or "" if none.'}),"\n",(0,r.jsx)(t.h3,{id:"getnextchild",children:"GetNextChild"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod GetNextChild(docId As %String, nodeId As %String, childId As %String, bNext As %Boolean) As %String [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:'Return the next child of the specified nodeId or "" if none.'}),"\n",(0,r.jsx)(t.h3,{id:"getpreviouschild",children:"GetPreviousChild"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod GetPreviousChild(docId As %String, nodeId As %String, childId As %String) As %String [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:'Return the previous child of the specified nodeId or "" if none.'}),"\n",(0,r.jsx)(t.h3,{id:"startdocument",children:"startDocument"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method startDocument() [ Internal ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"enddocument",children:"endDocument"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method endDocument() [ Internal ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"startelement",children:"startElement"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method startElement(uri As %Library.String, localname As %Library.String, qname As %Library.String, attrs As %Library.List) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"Receive notification of the start of an element."}),"\n",(0,r.jsxs)(t.p,{children:["Argument are as follows:",(0,r.jsx)(t.br,{}),"\n@param uri The URI of the associated namespace for this element",(0,r.jsx)(t.br,{}),"\n@param localname the local part of the element name",(0,r.jsx)(t.br,{}),"\n@param qname the QName of this element",(0,r.jsx)(t.br,{}),"\n@param attrs, a list in ",(0,r.jsx)(t.a,{href:"/csp/docbook/Doc.View.cls?FIND=OBJECTSCRIPT+$LIST+FUNCTION",children:"$List"})," format consisting of a repeating group of attributes :- 1) uri The URI of the associated namespace for this attribute",(0,r.jsx)(t.br,{}),"\n2) localname the local part of this attribute",(0,r.jsx)(t.br,{}),"\n3) qname the QName of this attribute",(0,r.jsx)(t.br,{}),"\n4) type the type of this attribute",(0,r.jsx)(t.br,{}),"\n5) value the value of this attribute"]}),"\n",(0,r.jsx)(t.h3,{id:"endelement",children:"endElement"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method endElement(uri As %Library.String, localname As %Library.String, qname As %Library.String) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"characters",children:"characters"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method characters(chars As %Library.String, length As %Library.Integer) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"startprefixmapping",children:"startPrefixMapping"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method startPrefixMapping(prefix As %String, uri As %String) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This method records the current prefix mappings which are in scope Prefixes are automatically handled by SAX on element and attribute names but not within element or attribute content."}),"\n",(0,r.jsx)(t.h3,{id:"endprefixmapping",children:"endPrefixMapping"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method endPrefixMapping(prefix As %String) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"error",children:"error"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method error(message As %String) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"fatalerror",children:"fatalError"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method fatalError(message As %String) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"warning",children:"warning"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method warning(message As %String) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"saveerror",children:"SaveError"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Method SaveError(type As %String, message As %String) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"dump",children:"Dump"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Dump(local, repeatable As %Boolean = 0) [ Internal ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"Formatted dump of iternal structure"}),"\n",(0,r.jsx)(t.h3,{id:"getattribute",children:"GetAttribute"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod GetAttribute(tree As %String, attribute) As %String\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Serialize the value ofthe specified attribute as text string. Note that the attribute value may be of any length.",(0,r.jsx)(t.br,{}),"\ntree is the id of the ML document tree.",(0,r.jsx)(t.br,{}),"\nattribute is the internal form of the attribute specifier as returned by $$$xmliGetAttributeByName or $$$xmlaForEachAttribute."]}),"\n",(0,r.jsx)(t.h3,{id:"serializeattribute",children:"SerializeAttribute"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod SerializeAttribute(tree As %String, attribute, outputStream As %Boolean, ByRef data, lineMode As %Boolean = 0) As %Boolean\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Serialize the value of the specified attribute as text. Note that the attribute value may be of any length.",(0,r.jsx)(t.br,{}),"\ntree is the id of the ML document tree.",(0,r.jsx)(t.br,{}),"\nattribute is the internal form of the attribute specifier as returned by $$$xmliGetAttributeByName or $$$xmlaForEachAttribute.",(0,r.jsx)(t.br,{}),"\noutputStream is true if the serialized output is to be sent to to the existing stream data.",(0,r.jsx)(t.br,{}),"\noutputStream is false if the serialized output is to be be appended to the string data. data is created if it is not already defined.",(0,r.jsx)(t.br,{}),"\nlineMode is true if the stream output should be written in line oriented mode, else the stream output will be written as a continuous block."]}),"\n",(0,r.jsx)(t.h3,{id:"serializebase64attribute",children:"SerializeBase64Attribute"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod SerializeBase64Attribute(tree As %Integer, attribute, outputStream As %Boolean, ByRef data, hex As %Boolean = 0, baseChildlist As %String) As %Boolean\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Serialize the base64 encoded text children of this node as text.",(0,r.jsx)(t.br,{}),"\ntree is the id of the ML document tree.",(0,r.jsx)(t.br,{}),"\nattribute is the internal form of the attribute specifier as returned by $$$xmliGetAttributeByName or $$$xmlaForEachAttribute.",(0,r.jsx)(t.br,{}),"\noutputStream is true if the serialized output is to be sent to to the existing stream data.",(0,r.jsx)(t.br,{}),"\noutputStream is false if the serialized output is to be be appended to the string data. data is created if it is not already defined."]}),"\n",(0,r.jsx)(t.h3,{id:"serializenode",children:"SerializeNode"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod SerializeNode(tree As %String, node As %String, outputStream As %Boolean, mixed As %Integer = 0, ByRef data, includeTop As %Boolean = 0, lineMode As %Boolean = 0, baseChildlist As %String) As %Boolean\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Serialize the children of this node as text.",(0,r.jsx)(t.br,{}),"\ntree is the id of the ML document tree.",(0,r.jsx)(t.br,{}),"\nnode is the id of the node to be serialized.",(0,r.jsx)(t.br,{}),"\noutputStream is true if the serialized output is to be sent to to the existing stream data.",(0,r.jsx)(t.br,{}),"\noutputStream is false if the serialized output is to be be appended to the string data. data is created if it is not already defined.",(0,r.jsx)(t.br,{}),"\nmixed is true if child elements should be serialized, else an error is returned if child elements are found. mixed=1 uses XML translate table. mixed=2 uses HTML translate table.",(0,r.jsx)(t.br,{}),"\nincludeTop is true if the containing element should be included in the returned output.",(0,r.jsx)(t.br,{}),"\nlineMode is true if the stream output should be written in line oriented mode, else the stream output will be written as a continuous block."]}),"\n",(0,r.jsx)(t.h3,{id:"serializebase64node",children:"SerializeBase64Node"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod SerializeBase64Node(tree As %Integer, node As %Integer, outputStream As %Boolean, ByRef data, hex As %Boolean = 0, baseChildlist As %String) As %Boolean\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Serialize the base64 encoded text children of this node as text.",(0,r.jsx)(t.br,{}),"\ntree is the id of the ML document tree.",(0,r.jsx)(t.br,{}),"\nnode is the id of the node to be serialized.",(0,r.jsx)(t.br,{}),"\noutputStream is true if the serialized output is to be sent to to the existing stream data.",(0,r.jsx)(t.br,{}),"\noutputStream is false if the serialized output is to be be appended to the string data. data is created if it is not already defined."]}),"\n",(0,r.jsx)(t.h3,{id:"hextobin",children:"hextobin"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod hextobin(hex As %String) As %String [ Internal, Private ]\n"})}),"\n",(0,r.jsx)(t.h3,{id:"output",children:"output"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod output(text As %String, outputStream As %Boolean, ByRef data, lineMode As %Boolean) As %Boolean [ Internal, Private ]\n"})})]})}function o(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>d});var r=n(96540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);