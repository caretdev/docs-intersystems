"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[1384],{36082:(e,s,r)=>{r.r(s),r.d(s,{contentTitle:()=>i,default:()=>o,frontMatter:()=>l,toc:()=>a});var t=r(74848),n=r(28453);const l={pagination_prev:null,pagination_next:null},i="%SYS.Journal.File",a=[{value:"Parameters",id:"parameters",level:2},{value:"READONLY",id:"readonly",level:3},{value:"DOMAIN",id:"domain",level:3},{value:"Properties",id:"properties",level:2},{value:"Name",id:"name",level:3},{value:"Chan",id:"chan",level:3},{value:"End",id:"end",level:3},{value:"FirstRecord",id:"firstrecord",level:3},{value:"LastRecord",id:"lastrecord",level:3},{value:"LastMarker",id:"lastmarker",level:3},{value:"ClusterStartTime0",id:"clusterstarttime0",level:3},{value:"ClusterStartTime",id:"clusterstarttime",level:3},{value:"Methods",id:"methods",level:2},{value:"%LoadData",id:"loaddata",level:3},{value:"Open",id:"open",level:3},{value:"%OnClose",id:"onclose",level:3},{value:"%OnNew",id:"onnew",level:3},{value:"Use",id:"use",level:3},{value:"EndGet",id:"endget",level:3},{value:"IsValidJournal",id:"isvalidjournal",level:3},{value:"FirstRecordGet",id:"firstrecordget",level:3},{value:"LastRecordGet",id:"lastrecordget",level:3},{value:"ClusterStartTime0Get",id:"clusterstarttime0get",level:3},{value:"ClusterStartTimeGet",id:"clusterstarttimeget",level:3},{value:"GetRecordAt",id:"getrecordat",level:3},{value:"GetRecordAfter",id:"getrecordafter",level:3},{value:"GetRecordBefore",id:"getrecordbefore",level:3},{value:"LastMarkerGet",id:"lastmarkerget",level:3},{value:"GetPrev",id:"getprev",level:3},{value:"GetNext",id:"getnext",level:3},{value:"GetMaxSize",id:"getmaxsize",level:3},{value:"GetGUID",id:"getguid",level:3},{value:"GetSystemGUID",id:"getsystemguid",level:3},{value:"GetMirrorGUID",id:"getmirrorguid",level:3},{value:"CheckIntegrity",id:"checkintegrity",level:3},{value:"CheckIntegrityOne",id:"checkintegrityone",level:3},{value:"Locate",id:"locate",level:3},{value:"SelectRange",id:"selectrange",level:3},{value:"Match",id:"match",level:3},{value:"ExtractFileName",id:"extractfilename",level:3},{value:"Restore",id:"restore",level:3},{value:"RestorePIDList",id:"restorepidlist",level:3},{value:"RequiredForClusterRecovery",id:"requiredforclusterrecovery",level:3},{value:"RequiredForRecovery",id:"requiredforrecovery",level:3},{value:"RequiredForRollback",id:"requiredforrollback",level:3},{value:"LastEncrypted",id:"lastencrypted",level:3},{value:"Purge",id:"purge",level:3},{value:"PurgeAll",id:"purgeall",level:3},{value:"PurgeOne",id:"purgeone",level:3},{value:"Archive",id:"archive",level:3},{value:"ArchiveAll",id:"archiveall",level:3},{value:"ArchiveOne",id:"archiveone",level:3},{value:"TranslateReason",id:"translatereason",level:3},{value:"GetReason",id:"getreason",level:3},{value:"Summary",id:"summary",level:3},{value:"DatabaseListExecute",id:"databaselistexecute",level:3},{value:"DatabaseListFetch",id:"databaselistfetch",level:3},{value:"DatabaseListClose",id:"databaselistclose",level:3},{value:"ByTimeReverseOrderExecute",id:"bytimereverseorderexecute",level:3},{value:"ByTimeReverseOrderFetch",id:"bytimereverseorderfetch",level:3},{value:"ByTimeReverseOrderClose",id:"bytimereverseorderclose",level:3},{value:"MirrorByTimeReverseOrderExecute",id:"mirrorbytimereverseorderexecute",level:3},{value:"MirrorByTimeReverseOrderFetch",id:"mirrorbytimereverseorderfetch",level:3},{value:"MirrorByTimeReverseOrderClose",id:"mirrorbytimereverseorderclose",level:3},{value:"PurgeableExecute",id:"purgeableexecute",level:3},{value:"PurgeableFetch",id:"purgeablefetch",level:3},{value:"PurgeableClose",id:"purgeableclose",level:3},{value:"ClusterListExecute",id:"clusterlistexecute",level:3},{value:"ClusterListFetch",id:"clusterlistfetch",level:3},{value:"ClusterListClose",id:"clusterlistclose",level:3},{value:"SearchExecute",id:"searchexecute",level:3},{value:"SearchFetch",id:"searchfetch",level:3},{value:"SearchClose",id:"searchclose",level:3},{value:"Compress",id:"compress",level:3},{value:"Decompress",id:"decompress",level:3}];function c(e){const s={br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"sysjournalfile",children:"%SYS.Journal.File"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Class %SYS.Journal.File Extends %Persistent [ StorageStrategy = JournalFileStorage, System = 4 ]\n"})}),"\n",(0,t.jsx)(s.p,{children:"Journal file related API"}),"\n",(0,t.jsx)(s.h2,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsx)(s.h3,{id:"readonly",children:"READONLY"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Parameter READONLY = 1;\n"})}),"\n",(0,t.jsx)(s.h3,{id:"domain",children:"DOMAIN"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:'Parameter DOMAIN = "%Utility";\n'})}),"\n",(0,t.jsx)(s.p,{children:"Default Localization Domain"}),"\n",(0,t.jsx)(s.h2,{id:"properties",children:"Properties"}),"\n",(0,t.jsx)(s.h3,{id:"name",children:"Name"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property Name As %SysPath [ ReadOnly ];\n"})}),"\n",(0,t.jsx)(s.p,{children:"Path of the journal file"}),"\n",(0,t.jsx)(s.h3,{id:"chan",children:"Chan"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property Chan As %Integer [ InitialExpression = -1, Internal, ReadOnly ];\n"})}),"\n",(0,t.jsx)(s.h3,{id:"end",children:"End"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property End As %Integer [ Calculated ];\n"})}),"\n",(0,t.jsx)(s.p,{children:"The end of the last valid record in the journal file (applicable to open file only)"}),"\n",(0,t.jsx)(s.h3,{id:"firstrecord",children:"FirstRecord"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property FirstRecord As %SYS.Journal.Record [ Calculated ];\n"})}),"\n",(0,t.jsx)(s.p,{children:"Object reference to the first record in the journal file (applicable to open file only)"}),"\n",(0,t.jsx)(s.h3,{id:"lastrecord",children:"LastRecord"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property LastRecord As %SYS.Journal.Record [ Calculated ];\n"})}),"\n",(0,t.jsx)(s.p,{children:"Object reference to the last record in the journal file (applicable to open file only)"}),"\n",(0,t.jsx)(s.h3,{id:"lastmarker",children:"LastMarker"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property LastMarker As %SYS.Journal.Marker [ Calculated ];\n"})}),"\n",(0,t.jsx)(s.p,{children:"Object reference to the last marker record in the journal file (applicable to open file only)"}),"\n",(0,t.jsx)(s.h3,{id:"clusterstarttime0",children:"ClusterStartTime0"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property ClusterStartTime0 As %Integer [ Calculated ];\n"})}),"\n",(0,t.jsx)(s.p,{children:"Cluster start time in time(0) format (i.e., # of seconds since the Epoch) or 0 if not a cluster journal file"}),"\n",(0,t.jsx)(s.h3,{id:"clusterstarttime",children:"ClusterStartTime"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property ClusterStartTime As %String [ Calculated ];\n"})}),"\n",(0,t.jsx)(s.p,{children:'Cluster start time in %TimeStamp format or "" if not a cluster journal file'}),"\n",(0,t.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(s.h3,{id:"loaddata",children:"%LoadData"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method %LoadData(FileName As %String, flag As %Boolean) As %Status [ Private ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"open",children:"Open"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method Open(FileName As %String) As %Status\n"})}),"\n",(0,t.jsx)(s.p,{children:"To open a journal file for record retrieval"}),"\n",(0,t.jsx)(s.h3,{id:"onclose",children:"%OnClose"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method %OnClose() As %Status [ Private ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"onnew",children:"%OnNew"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method %OnNew() As %Status [ Private ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"use",children:"Use"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method Use() As %Integer\n"})}),"\n",(0,t.jsx)(s.p,{children:"To use an open journal file for record retrieval (necessary when you have multiple journal file instances open at the same time and need to switch from one file to another)."}),"\n",(0,t.jsx)(s.h3,{id:"endget",children:"EndGet"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method EndGet() As %Integer\n"})}),"\n",(0,t.jsx)(s.h3,{id:"isvalidjournal",children:"IsValidJournal"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod IsValidJournal(FileName As %String) As %Status\n"})}),"\n",(0,t.jsx)(s.p,{children:"TRUE if the given FileName is a journal file"}),"\n",(0,t.jsx)(s.h3,{id:"firstrecordget",children:"FirstRecordGet"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method FirstRecordGet() As %SYS.Journal.Record\n"})}),"\n",(0,t.jsx)(s.h3,{id:"lastrecordget",children:"LastRecordGet"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method LastRecordGet() As %SYS.Journal.Record\n"})}),"\n",(0,t.jsx)(s.h3,{id:"clusterstarttime0get",children:"ClusterStartTime0Get"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method ClusterStartTime0Get() As %Integer\n"})}),"\n",(0,t.jsx)(s.h3,{id:"clusterstarttimeget",children:"ClusterStartTimeGet"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method ClusterStartTimeGet() As %String\n"})}),"\n",(0,t.jsx)(s.h3,{id:"getrecordat",children:"GetRecordAt"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method GetRecordAt(Address As %Integer) As %SYS.Journal.Record\n"})}),"\n",(0,t.jsx)(s.p,{children:"Return the object reference to the record at the given journal location (Address)"}),"\n",(0,t.jsx)(s.h3,{id:"getrecordafter",children:"GetRecordAfter"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method GetRecordAfter(Address As %Integer) As %SYS.Journal.Record\n"})}),"\n",(0,t.jsx)(s.p,{children:"Return the object reference to the record after the given journal location (Address)"}),"\n",(0,t.jsx)(s.h3,{id:"getrecordbefore",children:"GetRecordBefore"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method GetRecordBefore(Address As %Integer) As %SYS.Journal.Record\n"})}),"\n",(0,t.jsx)(s.p,{children:"Return the object reference to the record prior to the given journal location (Address)"}),"\n",(0,t.jsx)(s.h3,{id:"lastmarkerget",children:"LastMarkerGet"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method LastMarkerGet() As %SYS.Journal.Record\n"})}),"\n",(0,t.jsx)(s.h3,{id:"getprev",children:"GetPrev"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod GetPrev(FileName As %String = "", ByRef PrevFileName As %String, InSession As %Boolean, MirOnly As %Boolean = 0, MirrorSetName As %String = "") As %Status\n'})}),"\n",(0,t.jsx)(s.p,{children:"Purpose: Get journal file prior to the given journal file"}),"\n",(0,t.jsx)(s.p,{children:"InSession: whether to limit the search within a journal session (default=NO)"}),"\n",(0,t.jsx)(s.h3,{id:"getnext",children:"GetNext"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod GetNext(FileName As %String, ByRef NextFileName As %String, MirOnly As %Boolean = 0, MirrorSetName As %String = "") As %Status\n'})}),"\n",(0,t.jsx)(s.p,{children:"Purpose: Get journal file following the given journal file"}),"\n",(0,t.jsx)(s.h3,{id:"getmaxsize",children:"GetMaxSize"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod GetMaxSize(FileName As %String) As %Integer\n"})}),"\n",(0,t.jsx)(s.p,{children:"Purpose: Get max size of a journal file"}),"\n",(0,t.jsx)(s.h3,{id:"getguid",children:"GetGUID"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod GetGUID(FileName As %String) As %String [ CodeMode = expression ]\n"})}),"\n",(0,t.jsx)(s.p,{children:"Get the GUID assigned to the given journal file."}),"\n",(0,t.jsx)(s.h3,{id:"getsystemguid",children:"GetSystemGUID"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod GetSystemGUID(FileName As %String) As %String [ CodeMode = expression ]\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Get the GUID assigned to this system in the mirror configuration file.",(0,t.jsx)(s.br,{}),"\nThis is used to help people identify which system created the journal file.",(0,t.jsx)(s.br,{}),"\nSince this comes from the config file, it's possible that this can change over time but its not supposed to."]}),"\n",(0,t.jsx)(s.h3,{id:"getmirrorguid",children:"GetMirrorGUID"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod GetMirrorGUID(FileName As %String) As %String [ CodeMode = expression ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"checkintegrity",children:"CheckIntegrity"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod CheckIntegrity(ByRef jrnlist As %String, Detail As %Integer = 0, ByRef SrcDirs As %String, quietly As %Integer = 1) As %Status\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Purpose: Check integrity of the journal file(s)",(0,t.jsx)(s.br,{}),"\njrnlist can be either a file path or, if passed by reference, a number-indexed array of file paths, e.g.:",(0,t.jsx)(s.br,{}),"\njrnlist(1)=path1, jrnlist(2)=path2, etc.",(0,t.jsx)(s.br,{}),'\nThe file paths in the array should be in chronicle order, that is, path1 and path2 are assumed to have been created consecutively in the example above. If it is determined that the files in the given array do not meet that criterion, a single value 0 is returned (for "Invalid Parameter") and the top node of the array is set to the number index of the offending path.',(0,t.jsx)(s.br,{}),"\nDetail: If 1, scan each given journal file forward to locate the last record and verify it is the last record to be expected.",(0,t.jsx)(s.br,{}),"\nIf 2, verify values stored in each record are retrievable.",(0,t.jsx)(s.br,{}),"\nIf SrcDirs is set to 1 and passed by reference, the database directories used in the specified journal file(s) will be stored in SrcDirs array upon return."]}),"\n",(0,t.jsx)(s.h3,{id:"checkintegrityone",children:"CheckIntegrityOne"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod CheckIntegrityOne(path As %String, scan As %Integer = 0, jrnend As %Integer, ByRef jrnsrcdir As %String, quietly As %Integer) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.p,{children:"Purpose: Check integrity of a journal file"}),"\n",(0,t.jsx)(s.h3,{id:"locate",children:"Locate"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod Locate(ByRef LocatedFiles As %String, ByRef JrnFileList As %String, LocDirList As %String) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.p,{children:"Locate journal files given in JrnFileList in the directories given in LocDirList"}),"\n",(0,t.jsx)(s.h3,{id:"selectrange",children:"SelectRange"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod SelectRange(ByRef SelectedFiles As %String, FirstFile As %String = "", LastFile As %String = "", JrnLogPath As %String = "") As %Status [ Internal ]\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Returns OK and a list of local journal files (as SelectedFiles) between FirstFile and LastFile (inclusive). Error if either FirstFile or LastFile is not found.",(0,t.jsx)(s.br,{}),"\nFirstFile (and LastFile) can be a full path, a file name (yyyymmdd.nnn) with or without a prefix or a GUID representing the file.",(0,t.jsx)(s.br,{}),'\nIf FirstFile="" or not specified, it defaults to the first file in journal log.',(0,t.jsx)(s.br,{}),'\nIf LastFile="" or not specified, it defaults to the last file in journal log.']}),"\n",(0,t.jsx)(s.h3,{id:"match",children:"Match"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod Match(File As %String, Path As %String, GUID As %String) As %Status [ Internal ]\n"})}),"\n",(0,t.jsxs)(s.p,{children:["File can be a full path, a file name (yyyymmdd.nnn) or a GUID representing the file.",(0,t.jsx)(s.br,{}),"\nPath is a full path in canonical form on the original platform.",(0,t.jsx)(s.br,{}),"\nReturns"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"0: no match;"}),"\n",(0,t.jsx)(s.li,{children:"1: File matches the full path;"}),"\n",(0,t.jsx)(s.li,{children:"2: File matches the file name (including prefix);"}),"\n",(0,t.jsx)(s.li,{children:"3: File matches the file name without prefix;"}),"\n",(0,t.jsx)(s.li,{children:"4: File matches GUID."}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"extractfilename",children:"ExtractFileName"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ExtractFileName(Path As %SysPath) As %String [ Internal ]\n"})}),"\n",(0,t.jsx)(s.p,{children:"Given the full path of a journal file, extract its file name portion"}),"\n",(0,t.jsx)(s.h3,{id:"restore",children:"Restore"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod Restore(FileName As %String, Detail As %Integer = 0) As %Status\n"})}),"\n",(0,t.jsx)(s.p,{children:"Purpose: (virtually) restore the journal"}),"\n",(0,t.jsx)(s.h3,{id:"restorepidlist",children:"RestorePIDList"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod RestorePIDList(FileName As %String) As %Status\n"})}),"\n",(0,t.jsx)(s.p,{children:"Purpose: Regenerate the jobid->PID translation table based on records stored in the specified journal file"}),"\n",(0,t.jsx)(s.h3,{id:"requiredforclusterrecovery",children:"RequiredForClusterRecovery"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod RequiredForClusterRecovery(ByRef FileName As %String, ByRef FileCount As %Integer, SkipSelf As %Boolean = 0) As %Status\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Return the path of the oldest journal file on each node that is required for cluster recovery, which includes rolling forward and back transactions.",(0,t.jsx)(s.br,{}),"\nFileName = # of nodes where journal recovery is required",(0,t.jsx)(s.br,{}),"\nFileName(csn) = the path of the oldest journal file on node <#csn>",(0,t.jsx)(s.br,{}),"\nIf SkipSelf = 1, skip the node where the method is called (local node is covered by RequiredForRecovery()"]}),"\n",(0,t.jsx)(s.h3,{id:"requiredforrecovery",children:"RequiredForRecovery"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod RequiredForRecovery(ByRef FileName As %String, ByRef FileCount As %Integer) As %Status\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Return the name of the oldest journal file required for crash recovery, which includes rolling forward and backward transactions.",(0,t.jsx)(s.br,{}),'\nFileName="" if journaling is disabled, meaning that none is required, as transactions cannot be rolled forward or backward from a pre-disabling file']}),"\n",(0,t.jsx)(s.h3,{id:"requiredforrollback",children:"RequiredForRollback"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod RequiredForRollback(ByRef FileName As %String, ByRef FileCount As %Integer) As %Status\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Return the path of the oldest journal file containing open transactions.",(0,t.jsx)(s.br,{}),"\nFileName: the oldest file containing open transactions or current journal file",(0,t.jsx)(s.br,{}),"\nFileCount: the file counter value assigned to the file"]}),"\n",(0,t.jsx)(s.h3,{id:"lastencrypted",children:"LastEncrypted"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod LastEncrypted(OldestFile As %String = "", csn As %Integer = -1) As %String\n'})}),"\n",(0,t.jsx)(s.p,{children:"Return the path of the last encrypted file no older than OldestFile if given"}),"\n",(0,t.jsx)(s.h3,{id:"purge",children:"Purge"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod Purge(NDaysOld As %Integer, NBackupsOld As %Integer) As %Status\n"})}),"\n",(0,t.jsx)(s.p,{children:"Purpose: Purge old journal files based on criteria given in number of days or backups, taking care not to purge files required for transaction rollbacks or crash recovery."}),"\n",(0,t.jsx)(s.p,{children:"Parameters:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"NDaysOld: journal files must be at least this # of days old to be purged"}),"\n",(0,t.jsxs)(s.li,{children:["NBackupsOld: journal files must be older than this # of successive successful backups to be purged\nIf both parameters are specified, only one criterion has to be met to qualify a journal file for purging (subject to the restriction about rollback and crash recovery).",(0,t.jsx)(s.br,{}),"\nNote: It is the completion date, rather than the creation date, of a file that must meet the date criterion if specified. Thus, a file may not be OK to purge even though the date in its name appears to meet the date criterion."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"purgeall",children:"PurgeAll"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod PurgeAll() As %Status\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Purge ",(0,t.jsx)(s.em,{children:"all"})," journal files except those required for transaction rollbacks or crash recovery.",(0,t.jsx)(s.br,{}),"\nWarning: Post-backup journal files are not necessarily preserved."]}),"\n",(0,t.jsx)(s.h3,{id:"purgeone",children:"PurgeOne"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod PurgeOne(FilePath As %String, PurgeTimeH As %String, LogOnly As %Integer = 0) As %Status\n"})}),"\n",(0,t.jsx)(s.p,{children:"Purpose: Purge the journal file with the given name"}),"\n",(0,t.jsx)(s.p,{children:"Warning: This method does NOT check for open transactions before deleting the journal file."}),"\n",(0,t.jsxs)(s.p,{children:["FilePath: the full path of the journal file to purge",(0,t.jsx)(s.br,{}),"\nPurgeTimeH: Time of purging in $H format",(0,t.jsx)(s.br,{}),"\nLogOnly: if 1, skip purging and log the purged file only. Default = 0"]}),"\n",(0,t.jsx)(s.h3,{id:"archive",children:"Archive"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod Archive(NSecondsOld As %Integer, NBackupsOld As %Integer) As %Status\n"})}),"\n",(0,t.jsx)(s.p,{children:"Purpose: Archive old journal files based on criteria given in number of seconds or backups, taking care not to archive files required for transaction rollbacks or crash recovery."}),"\n",(0,t.jsx)(s.p,{children:"Parameters:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"NSecondsOld: journal files must be at least this # of seconds old to be archived"}),"\n",(0,t.jsxs)(s.li,{children:["NBackupsOld: journal files must be older than this # of successive successful backups to be archived\nIf both parameters are specified, only one criterion has to be met to qualify a journal file for archiving (subject to the restriction about rollback and crash recovery).",(0,t.jsx)(s.br,{}),"\nNote: It is the completion time, rather than the creation time, of a file that must meet the time criterion if specified. Thus, a file may not be OK to archive even though its timestamp appears to meet the time criterion."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"archiveall",children:"ArchiveAll"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ArchiveAll() As %Status\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Archive ",(0,t.jsx)(s.em,{children:"all"})," journal files except those required for transaction rollbacks or crash recovery.",(0,t.jsx)(s.br,{}),"\nWarning: Post-backup journal files are not necessarily preserved."]}),"\n",(0,t.jsx)(s.h3,{id:"archiveone",children:"ArchiveOne"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ArchiveOne(FilePath As %String) As %Status\n"})}),"\n",(0,t.jsx)(s.p,{children:"Purpose: Archive the journal file with the given name"}),"\n",(0,t.jsx)(s.p,{children:"Warning: This method does NOT check for open transactions before deleting the journal file."}),"\n",(0,t.jsxs)(s.p,{children:["FilePath: the full path of the journal file to archive",(0,t.jsx)(s.br,{}),"\nArchiveTimeH: Time of archiving in $H format",(0,t.jsx)(s.br,{}),"\nLogOnly: if 1, skip archiving and log the archived file only. Default = 0"]}),"\n",(0,t.jsx)(s.h3,{id:"translatereason",children:"TranslateReason"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod TranslateReason(reason As %Integer = 0) As %String\n"})}),"\n",(0,t.jsx)(s.p,{children:"Translate the numeric reason for the creation of a new journal file to string form"}),"\n",(0,t.jsx)(s.h3,{id:"getreason",children:"GetReason"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod GetReason(File As %SysPath) As %String [ CodeMode = expression ]\n"})}),"\n",(0,t.jsx)(s.p,{children:"Return the reason for the creation of the given journal file (File) in string form"}),"\n",(0,t.jsx)(s.h3,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod Summary(FilePath As %String, ByRef DataFields As %String) As %Status\n"})}),"\n",(0,t.jsx)(s.p,{children:"FileCount: the file counter value assigned to the file"}),"\n",(0,t.jsx)(s.h3,{id:"databaselistexecute",children:"DatabaseListExecute"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod DatabaseListExecute(ByRef qHandle As %Binary, FilePath As %String) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.p,{children:"Returns sfn's and paths/names of databases in a journal file"}),"\n",(0,t.jsx)(s.h3,{id:"databaselistfetch",children:"DatabaseListFetch"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod DatabaseListFetch(ByRef qHandle As %Binary, ByRef Row As %List, ByRef AtEnd As %Integer = 0) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"databaselistclose",children:"DatabaseListClose"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod DatabaseListClose(ByRef qHandle As %Binary) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"bytimereverseorderexecute",children:"ByTimeReverseOrderExecute"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod ByTimeReverseOrderExecute(ByRef qHandle As %Binary, FileName As %String = "") As %Status [ Internal ]\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Returns journal file names and file sizes in the reverse order of time (i.e., latest file first)",(0,t.jsx)(s.br,{}),"\nThe file size is the actual size on disk which for compressed files should be smaller than the amount of journal data in the file."]}),"\n",(0,t.jsx)(s.h3,{id:"bytimereverseorderfetch",children:"ByTimeReverseOrderFetch"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ByTimeReverseOrderFetch(ByRef qHandle As %Binary, ByRef Row As %List, ByRef AtEnd As %Integer = 0) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"bytimereverseorderclose",children:"ByTimeReverseOrderClose"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ByTimeReverseOrderClose(ByRef qHandle As %Binary) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"mirrorbytimereverseorderexecute",children:"MirrorByTimeReverseOrderExecute"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod MirrorByTimeReverseOrderExecute(ByRef qHandle As %Binary, FileName As %String = "", MirrorSetName As %String = "") As %Status [ Internal ]\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Returns journal file names and file sizes in the reverse order of time (i.e., latest file first) for the specified mirror",(0,t.jsx)(s.br,{}),"\nThe file size is the actual size on disk which for compressed files should be smaller than the amount of journal data in the file."]}),"\n",(0,t.jsx)(s.h3,{id:"mirrorbytimereverseorderfetch",children:"MirrorByTimeReverseOrderFetch"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod MirrorByTimeReverseOrderFetch(ByRef qHandle As %Binary, ByRef Row As %List, ByRef AtEnd As %Integer = 0) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"mirrorbytimereverseorderclose",children:"MirrorByTimeReverseOrderClose"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod MirrorByTimeReverseOrderClose(ByRef qHandle As %Binary) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"purgeableexecute",children:"PurgeableExecute"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod PurgeableExecute(ByRef qHandle As %Binary, DaysToKeep As %Integer = "") As %Status [ Internal ]\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Returns paths of journal files (along with their mirror names if any) that are eligible for purging based on the default or given criteria.",(0,t.jsx)(s.br,{}),"\nDaysToKeep: How many days of journal files to keep. Use default (current system setting) if left unspecified. If 0, none is purgeable; if <0, all files are purgeable except those required for transaction rollback and crash recovery."]}),"\n",(0,t.jsx)(s.h3,{id:"purgeablefetch",children:"PurgeableFetch"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod PurgeableFetch(ByRef qHandle As %Binary, ByRef Row As %List, ByRef AtEnd As %Integer = 0) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"purgeableclose",children:"PurgeableClose"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod PurgeableClose(ByRef qHandle As %Binary) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"clusterlistexecute",children:"ClusterListExecute"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod ClusterListExecute(ByRef qHandle As %Binary, FileName As %String = "", TimeOrder As %Boolean = 0, CSN As %Integer = -1) As %Status [ Internal, PublicList = (jrninfo, jrninfor) ]\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Information on cluster journal files",(0,t.jsx)(s.br,{}),"\nBy default, files are listed in reverse order of time, unless TimeOrder = 1",(0,t.jsx)(s.br,{}),"\nIf FileName is specified, files are listed until FileName is reached (depend on TimeOrder)",(0,t.jsx)(s.br,{}),"\nIf CSN is given, only files belong to the node are listed."]}),"\n",(0,t.jsx)(s.h3,{id:"clusterlistfetch",children:"ClusterListFetch"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ClusterListFetch(ByRef qHandle As %Binary, ByRef Row As %List, ByRef AtEnd As %Integer = 0) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"clusterlistclose",children:"ClusterListClose"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ClusterListClose(ByRef qHandle As %Binary) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"searchexecute",children:"SearchExecute"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod SearchExecute(ByRef qHandle As %Binary, String As %String, FileName As %String, Offset As %Integer, Backward As %Boolean = 0) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.p,{children:"Returns addresses of records in a given journal file that match a given string"}),"\n",(0,t.jsx)(s.h3,{id:"searchfetch",children:"SearchFetch"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod SearchFetch(ByRef qHandle As %Binary, ByRef Row As %List, ByRef AtEnd As %Integer = 0) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"searchclose",children:"SearchClose"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod SearchClose(ByRef qHandle As %Binary) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"compress",children:"Compress"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod Compress(infile As %String, outfile As %String, enginename As %String = "", chunksz As %Integer = 0) As %Status\n'})}),"\n",(0,t.jsx)(s.p,{children:"Compress a journal file"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"engine is the name of one of the supported compression engines (eg. lz4, zstd or zlib)"}),"\n",(0,t.jsx)(s.li,{children:"chunksz is in MB (range=1-16) and specifies how much uncompressed journal data to pack into one compressed chunk. Larger chunks increase compression efficiency but requires larger buffers and reading more data from disk to access a journal file record.\nThe engine and chunksz parameters use the default system values if omitted."}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["If compression fails a partially created output file is deleted.",(0,t.jsx)(s.br,{}),"\nThe output file must not exist to start with or an error is returned.",(0,t.jsx)(s.br,{}),"\nIn order to compress an encrypted file the encryption key must be active and the output file will be encrypted."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Caution:"})," Be careful with file names. If the intention is to create a compressed version of a journal file with the system's naming scheme by appending a 'z' to the name, specify a temporary output file and then rename/move the resulting file if the operation is succesful to the target name. It is best to avoid having incomplete files with a file name the system might look for. Also take care to ensure the output file has the proper filesystem level protection."]}),"\n",(0,t.jsx)(s.h3,{id:"decompress",children:"Decompress"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod Decompress(infile As %String, outfile As %String) As %Status\n"})}),"\n",(0,t.jsx)(s.p,{children:"Decompress a journal file"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"The output file must not exist or an error is returned"}),"\n",(0,t.jsx)(s.li,{children:"If decompression fails, the output file will be deleted"}),"\n",(0,t.jsxs)(s.li,{children:["To decompress an encrypted file the encryption key must be active and the output file will be encrypted.\n",(0,t.jsx)(s.strong,{children:"Caution:"})," Be careful with file names and locations. If the intention is to create a uncompressed version of a journal file with the system's naming scheme by removing the 'z' from the name it is best to specify a temporary file name and then rename/move the resulting file if the operation is succesful to the desired target name. When opening a journal file the system first tries to open the uncompressed version. If it opens a file which is being generated it may think that the file is smaller than it actually is (the size will be determined when it is opened) and may return incorrect results. Also take care to ensure that the output file has the proper filesystem level protection."]}),"\n"]})]})}function o(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,s,r)=>{r.d(s,{R:()=>i,x:()=>a});var t=r(96540);const n={},l=t.createContext(n);function i(e){const s=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),t.createElement(l.Provider,{value:s},e.children)}}}]);