"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[27656],{50832:(e,t,i)=>{i.r(t),i.d(t,{contentTitle:()=>l,default:()=>o,frontMatter:()=>r,toc:()=>d});var s=i(74848),n=i(28453);const r={pagination_prev:null,pagination_next:null},l="%DeepSee.PMML.Utils.TreeBuilder",d=[{value:"Properties",id:"properties",level:2},{value:"Dataset",id:"dataset",level:3},{value:"TargetField",id:"targetfield",level:3},{value:"Tree",id:"tree",level:3},{value:"SplitsPerNode",id:"splitspernode",level:3},{value:"MinimalSplitCoverage",id:"minimalsplitcoverage",level:3},{value:"TrackDistributions",id:"trackdistributions",level:3},{value:"ConsiderNullValues",id:"considernullvalues",level:3},{value:"SplitScoringAlgorithm",id:"splitscoringalgorithm",level:3},{value:"Methods",id:"methods",level:2},{value:"%OnNew",id:"onnew",level:3},{value:"Reset",id:"reset",level:3},{value:"Build",id:"build",level:3},{value:"GetInvertedFilter",id:"getinvertedfilter",level:3},{value:"MergeFilters",id:"mergefilters",level:3},{value:"GetNodeFilters",id:"getnodefilters",level:3},{value:"SplitNode",id:"splitnode",level:3},{value:"FindSplits",id:"findsplits",level:3},{value:"Print",id:"print",level:3},{value:"GetCondition",id:"getcondition",level:3},{value:"GetFieldList",id:"getfieldlist",level:3}];function a(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"deepseepmmlutilstreebuilder",children:"%DeepSee.PMML.Utils.TreeBuilder"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Class %DeepSee.PMML.Utils.TreeBuilder Extends %RegisteredObject [ System = 4 ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Utility class to build Tree models for a %DeepSee.PMML.Dataset object."}),"\n",(0,s.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,s.jsx)(t.h3,{id:"dataset",children:"Dataset"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Dataset As %DeepSee.PMML.Dataset;\n"})}),"\n",(0,s.jsx)(t.p,{children:"The dataset to mine."}),"\n",(0,s.jsx)(t.h3,{id:"targetfield",children:"TargetField"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property TargetField As %String;\n"})}),"\n",(0,s.jsx)(t.p,{children:"The target field whose value is to be derived through this tree. This field should be part of Dataset."}),"\n",(0,s.jsx)(t.h3,{id:"tree",children:"Tree"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Tree As %Integer [ MultiDimensional ];\n"})}),"\n",(0,s.jsx)(t.p,{children:'..Tree = $i ..Tree(NodeId) = $lb(parent, targetValue, confidence, count, isLeaf) ..Tree(NodeId, "condition") = [AND|OR|$lb(field, operator, value)] ..Tree(NodeId, "ch", ChildNode) = "" ..Tree(NodeId, "distribution", value) = count'}),"\n",(0,s.jsx)(t.h3,{id:"splitspernode",children:"SplitsPerNode"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property SplitsPerNode As %Integer [ InitialExpression = 2 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Default (maximum) number of branches per node"}),"\n",(0,s.jsx)(t.h3,{id:"minimalsplitcoverage",children:"MinimalSplitCoverage"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property MinimalSplitCoverage As %Numeric [ InitialExpression = 0.05 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Minimal % of the total number of records represented by a node that should be covered by a branch. If a branch covers fewer records than this value, it is ignored"}),"\n",(0,s.jsx)(t.h3,{id:"trackdistributions",children:"TrackDistributions"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property TrackDistributions As %Boolean [ InitialExpression = 1 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Whether or not to track distribution information for tree nodes"}),"\n",(0,s.jsx)(t.h3,{id:"considernullvalues",children:"ConsiderNullValues"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property ConsiderNullValues As %Boolean [ InitialExpression = 0 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Whether or not to consider null (missing) values for split criteria"}),"\n",(0,s.jsx)(t.h3,{id:"splitscoringalgorithm",children:"SplitScoringAlgorithm"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Property SplitScoringAlgorithm As %String(VALUELIST = ",Confidence,GiniImpurity,InformationGain") [ InitialExpression = "GiniImpurity" ];\n'})}),"\n",(0,s.jsx)(t.p,{children:'Which metric to use to judge split quality. This metric is returned as the split "score" by FindSplits'}),"\n",(0,s.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(t.h3,{id:"onnew",children:"%OnNew"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %OnNew(pDataset As %DeepSee.PMML.Dataset, pTargetField As %String) As %Status [ Internal, ServerOnly = 1 ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"reset",children:"Reset"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Reset() As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"After changing building parameters, run this method to erase the current tree structure so Build can be run again."}),"\n",(0,s.jsx)(t.h3,{id:"build",children:"Build"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Build(pMaxDepth As %Integer = 3)\n"})}),"\n",(0,s.jsx)(t.p,{children:"Builds a tree structure with a maximum depth of pMaxDepth."}),"\n",(0,s.jsx)(t.p,{children:"If a tree structure was already built, this method silently exits. Use Reset to erase an existing tree structure."}),"\n",(0,s.jsx)(t.h3,{id:"getinvertedfilter",children:"GetInvertedFilter"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method GetInvertedFilter(ByRef pFilter, Output pInverted) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Returns the inverse of pFilter, equivalent to a boolean NOT of the entire pFilter."}),"\n",(0,s.jsx)(t.h3,{id:"mergefilters",children:"MergeFilters"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method MergeFilters(ByRef pFilter, ByRef pOtherFilter, pLogic As %String = "AND") As %Status\n'})}),"\n",(0,s.jsx)(t.p,{children:"Appends pOtherFilter to pFilter using pLogic logic"}),"\n",(0,s.jsx)(t.h3,{id:"getnodefilters",children:"GetNodeFilters"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method GetNodeFilters(pNode As %Integer, Output pFilters) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Returns the combination of filter conditions (pFilters) a record should satisfy to end up in node pNode. This is a combination of the node's own condition, its full ancestry and any prior siblings' conditions."}),"\n",(0,s.jsx)(t.h3,{id:"splitnode",children:"SplitNode"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method SplitNode(pNode As %Integer) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Splits node pNode in SplitsPerNode sub-nodes (or fewer, if not enough candidate splits satisfy coverage and other selection criteria)."}),"\n",(0,s.jsx)(t.h3,{id:"findsplits",children:"FindSplits"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method FindSplits(pNode As %Integer, Output pSplits) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:'Returns an unsorted array of candidate splits for node pNode: pSplits(n) = $lb(score, coverage, targetValue, confidence, recordCount, isLeaf) pSplits(n,"condition") = ...'}),"\n",(0,s.jsx)(t.h3,{id:"print",children:"Print"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Print(pNode As %Integer = 0, pLevel As %Integer = 0, pPrintDistribution As %Boolean = 0) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Prints the tree (starting with pNode) to the terminal."}),"\n",(0,s.jsx)(t.h3,{id:"getcondition",children:"GetCondition"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod GetCondition(ByRef pArray) As %String [ Internal ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"getfieldlist",children:"GetFieldList"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod GetFieldList(ByRef pArray) As %List [ Internal ]\n"})})]})}function o(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>l,x:()=>d});var s=i(96540);const n={},r=s.createContext(n);function l(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);