"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[41137],{41818:(e,n,r)=>{r.r(n),r.d(n,{contentTitle:()=>a,default:()=>c,frontMatter:()=>s,toc:()=>d});var i=r(74848),t=r(28453);const s={pagination_prev:null,pagination_next:null},a="%iFind.Index.Basic",d=[{value:"Defining an iFind index",id:"defining-an-ifind-index",level:2},{value:"Querying an iFind index",id:"querying-an-ifind-index",level:2},{value:"Parameters",id:"parameters",level:2},{value:"FILER",id:"filer",level:3},{value:"IGNOREPUNCTUATION",id:"ignorepunctuation",level:3},{value:"KEEPCHARS",id:"keepchars",level:3},{value:"RANKERCLASS",id:"rankerclass",level:3},{value:"Methods",id:"methods",level:2},{value:"StripCharacters",id:"stripcharacters",level:3},{value:"StrippedWordId",id:"strippedwordid",level:3},{value:"StrippedEntityId",id:"strippedentityid",level:3},{value:"Rank",id:"rank",level:3},{value:"Highlight",id:"highlight",level:3}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ifindindexbasic",children:"%iFind.Index.Basic"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"Class %iFind.Index.Basic Extends %iFind.Index.Minimal [ EmbeddedClass = %iFind.Find.Basic, System = 2 ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"This index class provides text search capabilities to perform word-level searches through text in the %String or %Stream properties being indexed, for persistent classes using default storage."}),"\n",(0,i.jsx)(n.h2,{id:"defining-an-ifind-index",children:"Defining an iFind index"}),"\n",(0,i.jsx)(n.p,{children:"An iFind index can be defined in the class as follows:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Class ThePackage.MyClass Extends %Persistent { Property MyStringProperty As %String; Index MyBasicIndex On (MyStringProperty) As %iFind.Index.Basic; }"})}),"\n",(0,i.jsxs)(n.p,{children:["A number of ",(0,i.jsx)(n.a,{href:"#Anchor%5FParameters",children:"parameters"})," can be configured in order to refine the indexing behavior, such as whether to support case-sensitive search (LOWER), which language to use when indexing the text (LANGUAGE) or whether to enable stemming or decompounding (INDEXOPTION)."]}),"\n",(0,i.jsx)(n.h2,{id:"querying-an-ifind-index",children:"Querying an iFind index"}),"\n",(0,i.jsx)(n.p,{children:"Classes with an iFind index can subsequently be queried in SQL using the following syntax:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"SELECT * FROM ThePackage.MyClass WHERE %ID %FIND search_index(MyBasicIndex, 'interesting')"})}),"\n",(0,i.jsx)(n.p,{children:'This will return all the records containing the word "interesting". The following table lists a few sample search strings illustrating more advanced iFind search syntax.'}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Search string"}),(0,i.jsx)(n.th,{children:"What will be retrieved"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"structure"}),(0,i.jsx)(n.td,{children:'All records containing the word "structure"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"logical structure"}),(0,i.jsx)(n.td,{children:'All records containing both the words "logical" and "structure" (implicit AND)'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"logical structure*"}),(0,i.jsx)(n.td,{children:'Same, but with anything that starts with "structure" (wildcard search)'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'"logical structure"'}),(0,i.jsx)(n.td,{children:'All records containing the word "structure" right behind "logical" (positional search)'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'"logical ? structure"'}),(0,i.jsx)(n.td,{children:'All records containing the words "logical" and "structure" with exactly one word in between (positional search)'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'"logical [0-5] structure"'}),(0,i.jsx)(n.td,{children:"Positional again, but with up to 5 words between"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'[logical, structure, 5]"'}),(0,i.jsx)(n.td,{children:'All records containing the words "logical" and "structure", but with up to 5 words between'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'[logical structure, diagram, 3-6]"'}),(0,i.jsx)(n.td,{children:'All records containing the phrase "logical structure" and the word "diagram" again, with between 3 and 6 words between'})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"It's also possible to use AND, OR and NOT, as well as parentheses to combine words into more complex search strings, other than the implicit AND which is the default behavior for multi-word search:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Search string"}),(0,i.jsx)(n.th,{children:"What will be retrieved"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Fixed"}),(0,i.jsx)(n.td,{children:'All records containing the word "fixed"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Fixed and stored"}),(0,i.jsx)(n.td,{children:'All records containing "fixed" and "stored"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Fixed and not stored"}),(0,i.jsx)(n.td,{children:'All records containing "fixed" but not "stored"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'Fixed and not "stored procedure"'}),(0,i.jsx)(n.td,{children:'All records containing "fixed" but not the positional string "stored procedure"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'fixed and ("stored procedure" or "default parameters")'}),(0,i.jsx)(n.td,{children:'All records containing "fixed" and either "stored procedure" or "default parameters"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Fixed and \\not"}),(0,i.jsx)(n.td,{children:'All records containing the words "fixed" and "not"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Fixed \\and \\not"}),(0,i.jsx)(n.td,{children:'All records containing "fixed", "and" and "not"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"not generated"}),(0,i.jsx)(n.td,{children:'All records not containing "generated"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\\not generated"}),(0,i.jsx)(n.td,{children:'Implicit AND of "not" and "generated"'})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Besides the name of the iFind index and the search string, the search_index() function supports two more optional parameters:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["search_index(",(0,i.jsx)(n.em,{children:"indexname"}),", ",(0,i.jsx)(n.em,{children:"searchstring"})," [, ",(0,i.jsx)(n.em,{children:"searchoption"})," [, ",(0,i.jsx)(n.em,{children:"searchlanguage"}),"]]"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"search_option"})," defines whether to search for exact occurrences of words in the search string (",(0,i.jsx)(n.em,{children:"search_option"}),'=0), which is the default, to look for words that correspond to the same "normalized" form, based on a particular transformation. For example, stemming will normalize conjugated words to their base form and allow you to search for any conjugated form that corresponds to the same base form. Similarly, decompounding will normalize words even further by splitting up compound words in the atomic words it consists of (see also %iKnow.Stemming.DecompoundUtils). The following values can be used for ',(0,i.jsx)(n.em,{children:"search_option"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"search_option"})," = 0 will perform a regular search, without any transformations. This is the default."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"search_option"})," = 1 is a shorthand for stemmed search, using the default stemmer for the current language (see also %iKnow.Stemmer), optionally overridden by the STEMMINGCONFIG"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"search_option"})," = 2 is a shorthand for decompounded search, relying on the same settings as stemming described in the previous bullet"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"search_option"})," = 3 is a shorthand for fuzzy search, which will match any word that has at most 2 characters differing from the search term. (Note that this is not a transformation, strictly speaking)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"search_option"})," = '3:",(0,i.jsx)(n.em,{children:"n"}),"' will also perform fuzzy search, but the maximum edit distance (different characters) is now ",(0,i.jsx)(n.em,{children:"n"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"search_option"})," = 4 will perform a regular expression search"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"search_option"})," = '*' is a shorthand for searching based on all the transformations defined for this index"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:"search_option"})," = '",(0,i.jsx)(n.em,{children:"string"}),"' will perform the tranformation identified by ",(0,i.jsx)(n.em,{children:"string"})," (see also TRANSFORMATIONSPEC)\nWhich values are available for a given index depends on the values of the INDEXOPTION or TRANSFORMATIONSPEC parameters."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"search_language"}),' argument enables filtering records to those in a particular language, in cases where the indexed property contains text in multiple languages (LANGUAGE = "*"). This language is also passed on to an eventual word transformation method when ',(0,i.jsx)(n.em,{children:"search_option"})," != 0."]}),"\n",(0,i.jsx)(n.p,{children:"If the IFINDMAPPINGS index is set to 1, the following additional SQL projections will be generated:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["[",(0,i.jsx)(n.em,{children:"class_name"}),"]_[",(0,i.jsx)(n.em,{children:"index_name"}),"]_WordSpread"]}),": stores the total number of records in which this word appears in this index. See also %iFind.Index.AbstractWordSpread."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["[",(0,i.jsx)(n.em,{children:"class_name"}),"]_[",(0,i.jsx)(n.em,{children:"index_name"}),"]_WordPos"]})," stores which word occurs at which position in a record, so it can be joined to the AttributePos table. See also %iFind.Index.AbstractWordPos."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(n.h3,{id:"filer",children:"FILER"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:'Parameter FILER [ Internal ] = "%iFind.Filer.Basic";\n'})}),"\n",(0,i.jsx)(n.h3,{id:"ignorepunctuation",children:"IGNOREPUNCTUATION"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"Parameter IGNOREPUNCTUATION As BOOLEAN = 0;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"keepchars",children:"KEEPCHARS"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"Parameter KEEPCHARS As STRING = {$$$STRIPKEEP};\n"})}),"\n",(0,i.jsx)(n.p,{children:'This parameter controls which characters are retained at the start and end of a word when calculating the "stripped" version of a word that will be indexed along with the original word as it appeared in the text.'}),"\n",(0,i.jsx)(n.p,{children:"This parameter only applies if IGNOREPUNCTUATION is set to false (the default for Basic, Semantic and Analytic indices)."}),"\n",(0,i.jsx)(n.h3,{id:"rankerclass",children:"RANKERCLASS"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"Parameter RANKERCLASS As STRING = {$$$IFDEFAULTRANKER};\n"})}),"\n",(0,i.jsx)(n.p,{children:'The %iFind.Rank.Abstract implementation to use for ranking search results using the auto-generated rank SQL procedure "[package name].[class name]_[index name]Rank"'}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsx)(n.h3,{id:"stripcharacters",children:"StripCharacters"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod StripCharacters(pWord As %String) As %String [ CodeMode = generator ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Utility method stripping punctuation characters from the start and end of a word, according to the value of the KEEPCHARS index parameter for this index."}),"\n",(0,i.jsx)(n.h3,{id:"strippedwordid",children:"StrippedWordId"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod StrippedWordId(pWord As %String) As %String [ CodeMode = generator ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the Word ID for pWord, after stripping off any punctuation at the start and end of the word, according to the value of KEEPCHARS for this index."}),"\n",(0,i.jsx)(n.h3,{id:"strippedentityid",children:"StrippedEntityId"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod StrippedEntityId(pEntity As %String) As %String [ CodeMode = generator ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the Entity ID for pEntity, after stripping off any punctuation at the start and end of the words making up the entity, according to the value of KEEPCHARS for this index."}),"\n",(0,i.jsx)(n.h3,{id:"rank",children:"Rank"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod Rank(pRecordID As %RawString, pSearchString As %String, pSearchOption As %String = {$$$IFSEARCHNORMAL}) As %Float [ CodeMode = generator, PublicList = (SQLCODE, %msg), ServerOnly = 1, SqlProc ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"This SQL procedure returns the score expressing how well the record identified by pRecordID matches pSearchString, based on the ranking algorithm defined by RANKERCLASS."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"SELECT %ID, Title, FullText, SomePackage.TheTable_MyIndexRank(%ID, 'cocktail* OR (hammock AND NOT bees)') FROM SomePackage.TheTable WHERE %ID %FIND search_index(MyIndex, 'cocktail* OR (hammock AND NOT bees)') ORDER BY 4 DESC"})}),"\n",(0,i.jsx)(n.p,{children:"pSearchOption can be used as in other iFind search operations, for example to also accept fuzzy matches or stem matches when calculating the rank score."}),"\n",(0,i.jsx)(n.h3,{id:"highlight",children:"Highlight"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod Highlight(pRecordID As %RawString, pSearchString As %String, pSearchOption As %String = {$$$IFSEARCHNORMAL}, pTags As %String = {$$$IFDEFAULTHLTAGS}, pLimit As %Integer = 0, Output pSC As %Status) As %String [ CodeMode = generator, ForceGenerate, GenerateAfter = InsertIndex, PublicList = (SQLCODE, %msg), ServerOnly = 1, SqlProc ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"This SQL procedure returns the text indexed by pRecordID, in which all matches of the supplied pSearchString are highlighted using pTags."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"SELECT %ID, Title, SomePackage.TheTable_MyIndexHighlight(%ID, 'cocktail* OR (hammock AND NOT bees)') FROM SomePackage.TheTable WHERE %ID %FIND search_index(MyIndex, 'cocktail* OR (hammock AND NOT bees)') ORDER BY 4 DESC"})}),"\n",(0,i.jsx)(n.p,{children:"pTags is a comma-separated list of tags to use for highlighting. If only a single one is supplied, it will be used to highlight all matches of search terms. If a second one is supplied, it will be used for all terms in a NOT node of the search tree (such as 'bees' in the above example), while the first will be used for all other terms."}),"\n",(0,i.jsx)(n.p,{children:"pLimit can be used to limit the text to a maximum number of hits rather than returning the entire, highlighted text. pSearchOption can be used as in other iFind search operations, for example to also mark fuzzy matches or stem matches."})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>d});var i=r(96540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);