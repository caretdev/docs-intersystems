"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[3377],{16730:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>c,default:()=>l,frontMatter:()=>r,toc:()=>d});var i=t(74848),s=t(28453);const r={pagination_prev:null,pagination_next:null},c="%iFind.Index.Semantic",d=[{value:"Parameters",id:"parameters",level:2},{value:"FILER",id:"filer",level:3},{value:"IFINDATTRIBUTES",id:"ifindattributes",level:3}];function a(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ifindindexsemantic",children:"%iFind.Index.Semantic"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"Class %iFind.Index.Semantic Extends %iFind.Index.Basic [ Deprecated, EmbeddedClass = %iFind.Find.Semantic, System = 2 ]\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The InterSystems IRIS NLP iKnow technology on which this index type is based is now deprecated. Please see the ",(0,i.jsx)(n.a,{href:"https://docs.intersystems.com/irislatest/csp/docbook/DocBook.UI.Page.cls?KEY=GIKNOW",children:"product documentation"})," for more detail. The %iKnow.Index.Basic and %iKnow.Index.Minimal index types remain fully supported."]}),"\n",(0,i.jsx)(n.p,{children:"This index class is a more advanced version of %iFind.Index.Basic, leveraging the semantic output of the iKnow engine processing the text being indexed. In addition to the search options provided by the Basic index, users can now also query for entities and their attributes:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Search string"}),(0,i.jsx)(n.th,{children:"What will be retrieved"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"logical structure"}),(0,i.jsx)(n.td,{children:'All records containing both the words "logical" and "structure" (implicit AND)'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'"logical structure"'}),(0,i.jsx)(n.td,{children:'All records containing the word "structure" right behind "logical" (positional search)'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"{logical structure}"}),(0,i.jsxs)(n.td,{children:["Records containing the actual ",(0,i.jsx)(n.em,{children:"entity"}),' "logical structure"']})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"<{logical structure}"}),(0,i.jsx)(n.td,{children:'Expanded entity search for entities ending with "logical structure" (but something before too)'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"{logical structure}>"}),(0,i.jsx)(n.td,{children:'Expanded entity search for entities starting with "logical structure" (but something after too)'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"<logical structure"}),(0,i.jsx)(n.td,{children:'Implicit AND of entity search on entities ending with "logical" and simple word search on "structure"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"<structure"}),(0,i.jsx)(n.td,{children:'Records containing entities ending with the word "structure"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"<structure*"}),(0,i.jsx)(n.td,{children:'Records containing entities ending with any word beginning with "structure"'})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:'<structure AND NOT "logical structure"'}),(0,i.jsx)(n.td,{children:'Records containing entities ending with the word "structure", except if they also contain the exact string "logical structure" (positional search)'})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Note: In the above table, the first two examples are also supported using a Basic index, but are repeated here for comparison with the new entity search options."}),"\n",(0,i.jsx)(n.p,{children:"If the IFINDMAPPINGS index is set to 1, the following additional SQL projections will be generated:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["[",(0,i.jsx)(n.em,{children:"class_name"}),"]_[",(0,i.jsx)(n.em,{children:"index_name"}),"]_Ent"]}),": stores which entities occur in which records. See also %iFind.Index.AbstractEntity."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["[",(0,i.jsx)(n.em,{children:"class_name"}),"]_[",(0,i.jsx)(n.em,{children:"index_name"}),"]_EntSpread"]}),": stores the total number of records in which each entity occurs. See also %iFind.Index.AbstractEntSpread."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For a detailed description of the other configuration and query options, see the class reference for %iFind.Index.Basic."}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(n.h3,{id:"filer",children:"FILER"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:'Parameter FILER [ Internal ] = "%iFind.Filer.Semantic";\n'})}),"\n",(0,i.jsx)(n.h3,{id:"ifindattributes",children:"IFINDATTRIBUTES"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"Parameter IFINDATTRIBUTES As BOOLEAN = 0;\n"})}),"\n",(0,i.jsxs)(n.p,{children:['Whether or not to store attribute information, such as negation. If set to 1, the following additional projections will be generated in the "[',(0,i.jsx)(n.em,{children:"package_name"}),"]_[",(0,i.jsx)(n.em,{children:"class_name"}),']" package if your IFINDMAPPINGS is set to 1, exposing attribute occurrence details:']}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["[",(0,i.jsx)(n.em,{children:"class_name"}),"]_[",(0,i.jsx)(n.em,{children:"index_name"}),"]_Attribute"]})," stores whether a particular attribute occurs anywhere in a record. See also %iFind.Index.AbstractAttribute."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["[",(0,i.jsx)(n.em,{children:"class_name"}),"]_[",(0,i.jsx)(n.em,{children:"index_name"}),"]_AttributePos"]})," stores for a particular attribute, to which word positions in the record it applies. See also %iFind.Index.AbstractAttributePos."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The attribute values currently supported out of the box are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"1: explicit negation within the entity"}),"\n",(0,i.jsx)(n.li,{children:"-1: negation implied by another entity within the path"}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>d});var i=t(96540);const s={},r=i.createContext(s);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);