"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[24019],{74959:(e,t,i)=>{i.r(t),i.d(t,{contentTitle:()=>a,default:()=>c,frontMatter:()=>r,toc:()=>o});var s=i(74848),n=i(28453);const r={pagination_prev:null,pagination_next:null},a="%iKnow.Classification.Builder",o=[{value:"Properties",id:"properties",level:2},{value:"MinimumSpread",id:"minimumspread",level:3},{value:"MinimumSpreadPercent",id:"minimumspreadpercent",level:3},{value:"Description",id:"description",level:3},{value:"DocumentVectorLocalWeights",id:"documentvectorlocalweights",level:3},{value:"DocumentVectorNormalization",id:"documentvectornormalization",level:3},{value:"Terms",id:"terms",level:3},{value:"Categories",id:"categories",level:3},{value:"TermSelectionMetric",id:"termselectionmetric",level:3},{value:"ClassificationMethod",id:"classificationmethod",level:3},{value:"EntityRole",id:"entityrole",level:3},{value:"MethodBuilder",id:"methodbuilder",level:3},{value:"Methods",id:"methods",level:2},{value:"%AddCategory",id:"addcategory",level:3},{value:"%GetCategoryInfo",id:"getcategoryinfo",level:3},{value:"%GetCategoryPosition",id:"getcategoryposition",level:3},{value:"%GetTerms",id:"getterms",level:3},{value:"%AddTerm",id:"addterm",level:3},{value:"%AddEntity",id:"addentity",level:3},{value:"%AddCRC",id:"addcrc",level:3},{value:"%AddCooccurrence",id:"addcooccurrence",level:3},{value:"%AddTermInternal",id:"addterminternal",level:3},{value:"%GetTermPosition",id:"gettermposition",level:3},{value:"%RemoveTermAtIndex",id:"removetermatindex",level:3},{value:"%RemoveTermEntryAtIndex",id:"removetermentryatindex",level:3},{value:"%RemoveTerm",id:"removeterm",level:3},{value:"%PopulateTerms",id:"populateterms",level:3},{value:"%Reset",id:"reset",level:3},{value:"%OnReset",id:"onreset",level:3},{value:"%GenerateClassifier",id:"generateclassifier",level:3},{value:"%OnGenerateClassifier",id:"ongenerateclassifier",level:3},{value:"%CreateClassifierClass",id:"createclassifierclass",level:3},{value:"%LoadFromDefinition",id:"loadfromdefinition",level:3},{value:"%LoadFromModel",id:"loadfrommodel",level:3},{value:"%OnLoadFromDefinition",id:"onloadfromdefinition",level:3},{value:"%ExportDataTable",id:"exportdatatable",level:3},{value:"GetColumnName",id:"getcolumnname",level:3},{value:"%OnCreateExportTable",id:"oncreateexporttable",level:3},{value:"%OnExportTable",id:"onexporttable",level:3},{value:"%AddTermsFromSQL",id:"addtermsfromsql",level:3},{value:"%GetRecordCount",id:"getrecordcount",level:3},{value:"%GetTermInfo",id:"getterminfo",level:3},{value:"ClassificationMethodSet",id:"classificationmethodset",level:3},{value:"%DispatchSetProperty",id:"dispatchsetproperty",level:3},{value:"%DispatchGetProperty",id:"dispatchgetproperty",level:3},{value:"%DispatchMethod",id:"dispatchmethod",level:3},{value:"%GetCandidateTerms",id:"getcandidateterms",level:3},{value:"%TestClassifier",id:"testclassifier",level:3}];function l(e){const t={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"iknowclassificationbuilder",children:"%iKnow.Classification.Builder"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Class %iKnow.Classification.Builder Extends %RegisteredObject [ Abstract, Deprecated, System = 4 ]\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The InterSystems IRIS NLP iKnow technology is now deprecated. Please see the ",(0,s.jsx)(t.a,{href:"https://docs.intersystems.com/irislatest/csp/docbook/DocBook.UI.Page.cls?KEY=GIKNOW",children:"product documentation"})," for more detail."]}),"\n",(0,s.jsxs)(t.p,{children:["This is the framework class for building Text Categorization models, generating valid %iKnow.Classification.Classifier subclasses.",(0,s.jsx)(t.br,{}),"\nHere's an example using the %iKnow.Classification.IKnowBuilder:"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.code,{children:'// first initialize training and test sets set tDomainId = $system.iKnow.GetDomainId("Standalone Aviation demo") set tTrainingSet = ##class(%iKnow.Filters.SimpleMetadataFilter).%New(tDomainId, "Year", "<", 2007) set tTestSet = ##class(%iKnow.Filters.GroupFilter).%New(tDomainId, "AND", 1) // NOT filter do tTestSet.AddSubFilter(tTrainingSet) // Initialize Builder instance with domain name and test set set tBuilder = ##class(%iKnow.Classification.IKnowBuilder).%New("Standalone Aviation demo", tTrainingSet) // Configure it to use a Naive Bayes classifier set tBuilder.ClassificationMethod = "naiveBayes" // Load category info from metadata field "AircraftCategory" write tBuilder.%LoadMetadataCategories("AircraftCategory") // manually add a few terms write tBuilder.%AddEntity("ultralight vehicle") set tData(1) = "helicopter", tData(2) = "helicopters" write tBuilder.%AddEntity(.tData) write tBuilder.%AddEntity("balloon",, "partialCount") write tBuilder.%AddCooccurrence($lb("landed", "helicopter pad")) // or add them in bulk by letting the Builder instance decide write tBuilder.%PopulateTerms(50) // after populating the term dictionary, let the Builder generate a classifier class write tBuilder.%CreateClassifierClass("User.MyClassifier")'})}),"\n",(0,s.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,s.jsx)(t.h3,{id:"minimumspread",children:"MinimumSpread"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property MinimumSpread As %Integer [ InitialExpression = 3 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"The minimum number of records in the training set that should contain a term before it can get selected by %PopulateTerms. (Can be bypassed for specific terms by adding them through %AddTerm)"}),"\n",(0,s.jsx)(t.h3,{id:"minimumspreadpercent",children:"MinimumSpreadPercent"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property MinimumSpreadPercent As %Double [ InitialExpression = 0.05 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"The minimum fraction of records in the training set that should contain a term before it can get selected by %PopulateTerms, EXCEPT if it occurs in more than 50% of the records in at least one category. (Can be bypassed for specific terms by adding them through %AddTerm)"}),"\n",(0,s.jsx)(t.h3,{id:"description",children:"Description"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Description As %String;\n"})}),"\n",(0,s.jsx)(t.p,{children:"Optional description for the Classifier"}),"\n",(0,s.jsx)(t.h3,{id:"documentvectorlocalweights",children:"DocumentVectorLocalWeights"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Property DocumentVectorLocalWeights As %String(VALUELIST = ",binary,linear,logarithmic") [ InitialExpression = "linear" ];\n'})}),"\n",(0,s.jsx)(t.p,{children:'Local Term Weights for the document vector to register in the ClassificationMethod element. This might be overruled for some classification methods (ie Naive Bayes, which always uses "binary")'}),"\n",(0,s.jsx)(t.h3,{id:"documentvectornormalization",children:"DocumentVectorNormalization"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Property DocumentVectorNormalization As %String(VALUELIST = ",none,cosine") [ InitialExpression = "none" ];\n'})}),"\n",(0,s.jsx)(t.p,{children:'Document vector normalization method to register in the Classification element This might be overruled for some classification methods (ie Naive Bayes, which always uses "none")'}),"\n",(0,s.jsx)(t.h3,{id:"terms",children:"Terms"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Terms As list Of %iKnow.Classification.Definition.Term [ Internal ];\n"})}),"\n",(0,s.jsx)(t.h3,{id:"categories",children:"Categories"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Categories As list Of %List [ Internal ];\n"})}),"\n",(0,s.jsx)(t.p,{children:'Categories.GetAt(i) = $lb("name", "spec", "description", "recordCount")'}),"\n",(0,s.jsx)(t.h3,{id:"termselectionmetric",children:"TermSelectionMetric"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property TermSelectionMetric As %String [ Internal ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"The metric used for selecting terms for this classifier. This is for information purposes only."}),"\n",(0,s.jsx)(t.h3,{id:"classificationmethod",children:"ClassificationMethod"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Property ClassificationMethod As %String(VALUELIST = ",naiveBayes,linearRegression,euclideanDistance,cosineSimilarity,pmml,rules") [ InitialExpression = "naiveBayes" ];\n'})}),"\n",(0,s.jsx)(t.p,{children:"The general method used for classification:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:'"naiveBayes" uses a probability-based approach based on the Naive Bayes theorem,'}),"\n",(0,s.jsx)(t.li,{children:'"rules" runs through a set of straightforward decision rules based on boolean expressions, each contributing to a single category\'s score if they fire. The category with the highest score wins.'}),"\n",(0,s.jsx)(t.li,{children:'"euclideanDistance" treats the per-category term weights as a vector in the same vector space as the document term vector and calculates the euclidean distance between these vectors and the query vector.'}),"\n",(0,s.jsx)(t.li,{children:'"cosineSimilarity" also treats the per-category term weights as a vector in the same vector space as the document term vector and looks at the (cosine of) the angle between these vectors.'}),"\n",(0,s.jsx)(t.li,{children:'"linearRegression" considers the per-category term weights to be coefficients in a linear regression formula for calculating a category score, with the highest value winning'}),"\n",(0,s.jsx)(t.li,{children:'"pmml" delegates the mathematical work to a predictive model defined in PMML. See also %iKnow.Classification.Methods.pmml'}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"entityrole",children:"EntityRole"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property EntityRole As %Integer [ InitialExpression = {$$$ENTTYPECONCEPT}, Internal ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Used by some models to refine the terms selected and/or how their default score is calculated"}),"\n",(0,s.jsx)(t.h3,{id:"methodbuilder",children:"MethodBuilder"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property MethodBuilder As %iKnow.Classification.Methods.Base [ Internal, ReadOnly ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"This object will deliver the actual implementation of the classification method and is instantiated automatically through settting ClassificationMethod."}),"\n",(0,s.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(t.h3,{id:"addcategory",children:"%AddCategory"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method %AddCategory(pName As %String, pSpec As %String, pRecordCount As %Integer = "", pDescription As %String = "") As %Status [ Final ]\n'})}),"\n",(0,s.jsx)(t.p,{children:"Adds an optional category named pName for the classifier being built by this class. The meaning of pSpec depends on the actual builder implementation, but should allow the builder implementation to identify the records in the training set belonging to this category."}),"\n",(0,s.jsx)(t.h3,{id:"getcategoryinfo",children:"%GetCategoryInfo"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %GetCategoryInfo(Output pCategories) As %Status [ Abstract ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Returns all categories added so far: pCategories(n) = $lb([name], [record count])"}),"\n",(0,s.jsx)(t.h3,{id:"getcategoryposition",children:"%GetCategoryPosition"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %GetCategoryPosition(pName As %String) As %Integer [ Internal ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"getterms",children:"%GetTerms"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %GetTerms(Output pTerms) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Returns all terms added so far: pTerms(n) = $lb([string value], [type], [negation policy], [count policy])"}),"\n",(0,s.jsx)(t.h3,{id:"addterm",children:"%AddTerm"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method %AddTerm(pValue As %String, pType As %String = "entity", ByRef pCustomWeights, pNegation As %String = "undefined") As %Status [ Deprecated, Final, Internal ]\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Deprecated: use %AddEntity, %AddCRC or %AddCooccurrence instead"})}),"\n",(0,s.jsx)(t.p,{children:"Adds a term whose presence or frequency is to be considered for categorizing by the classifier being built by this class."}),"\n",(0,s.jsx)(t.h3,{id:"addentity",children:"%AddEntity"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method %AddEntity(ByRef pValue As %String, pNegation As %String = "undefined", pCount As %String = "exactCount", Output pIndex As %Integer) As %Status [ Final ]\n'})}),"\n",(0,s.jsx)(t.p,{children:'Adds one or more entities as a single term to the Text Categorization model\'s term dictionary. The term is to be counted only if it appears in the negation context defined by pNegation. If pCount = "exactCount", only exact occurrences of this entity will be counted to calculate its base score to be fed into the categorization algorithm. If it is set to "partialCount", both exact and partial matches will be considered and if set to "partialScore", the score of all exact and partial matches will be summed as this term\'s base score.'}),"\n",(0,s.jsx)(t.p,{children:"Multiple entities can be supplied either as a one-dimensional array or as a %List"}),"\n",(0,s.jsx)(t.p,{children:"."}),"\n",(0,s.jsx)(t.h3,{id:"addcrc",children:"%AddCRC"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method %AddCRC(ByRef pCRC As %List, pNegation As %String = "undefined", pCount As %String = "exactCount", Output pIndex As %Integer) As %Status [ Final ]\n'})}),"\n",(0,s.jsx)(t.p,{children:'Adds one or more CRCs as a single term to the Text Categorization model\'s term dictionary. The term is to be counted only if it appears in the negation context defined by pNegation. If pCount = "exactCount", only exact occurrences of this CRC will be counted to calculate its base score to be fed into the categorization algorithm. If it is set to "partialCount", both exact and partial matches will be considered and if set to "partialScore", the score of all exact and partial matches will be summed as this term\'s base score.'}),"\n",(0,s.jsx)(t.p,{children:"Multiple CRC can be supplied either as a one-dimensional array of 3-element-%Lists"}),"\n",(0,s.jsx)(t.p,{children:"."}),"\n",(0,s.jsx)(t.h3,{id:"addcooccurrence",children:"%AddCooccurrence"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method %AddCooccurrence(ByRef pValue As %List, pNegation As %String = "undefined", pCount As %String = "exactCount", Output pIndex As %Integer) As %Status [ Final ]\n'})}),"\n",(0,s.jsx)(t.p,{children:'Adds one or more Cooccurrences as a single term to the Text Categorization model\'s term dictionary. The term is to be counted only if it appears in the negation context defined by pNegation. If pCount = "exactCount", only exact occurrences of this cooccurrence\'s entities will be counted to calculate its base score to be fed into the categorization algorithm. If it is set to "partialCount", both exact and partial matches will be considered and if set to "partialScore", the score of all exact and partial matches will be summed as this term\'s base score.'}),"\n",(0,s.jsx)(t.p,{children:"A single cooccurrence can be supplied as a one-dimensional array of strings or a %List. Multiple cooccurrences can be supplied either as a one-dimensional array of %Lists or as a two-dimensional array of strings"}),"\n",(0,s.jsx)(t.p,{children:"."}),"\n",(0,s.jsx)(t.h3,{id:"addterminternal",children:"%AddTermInternal"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %AddTermInternal(pTerm As %iKnow.Classification.Definition.Term, Output pIndex As %Integer) As %Status [ Internal ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Directly add a term object at the last index. (no existence checking!)"}),"\n",(0,s.jsx)(t.h3,{id:"gettermposition",children:"%GetTermPosition"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %GetTermPosition(pTerm As %iKnow.Classification.Definition.Term) As %Integer [ Internal ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"removetermatindex",children:"%RemoveTermAtIndex"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %RemoveTermAtIndex(pIndex As %Integer) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Removes the term at index pIndex. If the term at this position is a composite one, all its entries are dropped along."}),"\n",(0,s.jsx)(t.h3,{id:"removetermentryatindex",children:"%RemoveTermEntryAtIndex"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %RemoveTermEntryAtIndex(pValue As %String, pIndex As %Integer, Output pRemovedTerm As %Boolean) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Removes a specific entry pValue from the term at index pIndex."}),"\n",(0,s.jsx)(t.h3,{id:"removeterm",children:"%RemoveTerm"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method %RemoveTerm(pValue As %String, pType As %String = "entity", pNegation As %String = "undefined", pCount As %String = "exactCount") As %Status\n'})}),"\n",(0,s.jsx)(t.p,{children:"Removes pValue from the first term that contains it meeting the pType pNegation and pCount criteria. If this is the last entry for that term, remove the whole term."}),"\n",(0,s.jsx)(t.h3,{id:"populateterms",children:"%PopulateTerms"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method %PopulateTerms(pCount As %Integer = 100, pType As %String = "entity", pMetric As %String = "NaiveBayes", pPerCategory As %Boolean = 0) As %Status\n'})}),"\n",(0,s.jsx)(t.p,{children:"Adds pCount terms of type pType to this classifier's set of terms, selecting those terms that have a high relevance for the categorization task based on metric pMetric and/or the specifics of this builder implementation."}),"\n",(0,s.jsx)(t.p,{children:"If pPerCategory is 1, (pCount \\ [number of categories]) terms are selected using the specified metric as calculated within each category. This often gives better results, but might not be supported for every metric or builder."}),"\n",(0,s.jsx)(t.p,{children:"Builder implementations should ensure these terms meet the conditions set forward by MinimumSpread and MinimumSpreadPercent. MinimumSpreadPercent can be ignored if pPerCategory = 1"}),"\n",(0,s.jsx)(t.p,{children:'This method implements a populate method for pMetric = "NaiveBayes", selecting terms based on their highest average per-category probability. In this case, the value of pPerCategory is ignored (automatically treated as 1). Implementations for other metrics can be provided by subclasses.'}),"\n",(0,s.jsx)(t.h3,{id:"reset",children:"%Reset"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %Reset() As %Status [ Final ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Resets the term and category lists for this classifier"}),"\n",(0,s.jsx)(t.h3,{id:"onreset",children:"%OnReset"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %OnReset() As %Status [ Private ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"generateclassifier",children:"%GenerateClassifier"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %GenerateClassifier(Output pDefinition As %iKnow.Classification.Definition.Classifier, pIncludeBuilderInfo As %Boolean = 0, pVerbose As %Boolean = 1) As %Status [ Final ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Generates a %iKnow.Classification.Definition.Classifier XML tree based on the current set of categories and terms, with the appropriate weights and parameters calculated by the builder implementation (see %OnGenerateClassifier)."}),"\n",(0,s.jsx)(t.p,{children:'Use pIncludeBuilderInfo to include specifications of how this classifier was built so it can be "reloaded" from the classifier XML to retrain the model.'}),"\n",(0,s.jsx)(t.h3,{id:"ongenerateclassifier",children:"%OnGenerateClassifier"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %OnGenerateClassifier(ByRef pDefinition As %iKnow.Classification.Definition.Classifier, pVerbose As %Boolean = 1, pIncludeBuilderInfo As %Boolean = 0) As %Status [ Private ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Appends the ClassificationMethod element for this type of classifier."}),"\n",(0,s.jsx)(t.h3,{id:"createclassifierclass",children:"%CreateClassifierClass"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %CreateClassifierClass(pClassName As %String, pVerbose As %Boolean = 1, pIncludeBuilderInfo As %Boolean = 1, pOverwrite As %Boolean = 0, pCompile As %Boolean = 1) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Generates a classifier definition and saves it to a %iKnow.Classification.Classifier subclass named pClassName. This will overwrite any existing class with that name if pOverwrite is 1. See also %GenerateClassifier."}),"\n",(0,s.jsx)(t.h3,{id:"loadfromdefinition",children:"%LoadFromDefinition"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod %LoadFromDefinition(pClassName As %String, Output pBuilder As %iKnow.Classification.Builder, pValidateFirst As %Boolean = 1) As %Status [ Final ]\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Loads the categories and terms from an existing Classifier class pClassName.",(0,s.jsx)(t.br,{}),"\nNote: this does not load any (custom) weight information from the definition."]}),"\n",(0,s.jsx)(t.h3,{id:"loadfrommodel",children:"%LoadFromModel"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod %LoadFromModel(pDefinition As %iKnow.Classification.Definition.Classifier, Output pBuilder As %iKnow.Classification.Builder) As %Status [ Final, Internal ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"onloadfromdefinition",children:"%OnLoadFromDefinition"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %OnLoadFromDefinition(pDefinition As %iKnow.Classification.Definition.Classifier) As %Status [ Internal ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"exportdatatable",children:"%ExportDataTable"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %ExportDataTable(pClassName As %String, pOverwrite As %Boolean = 1, pVerbose As %Boolean = 1, pTracking As %Boolean = 0) As %Status [ Final ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Exports the data in the training set to a new table pClassName, with columns containing the weighted score for each term."}),"\n",(0,s.jsx)(t.h3,{id:"getcolumnname",children:"GetColumnName"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod GetColumnName(pTermId As %Integer) As %String [ Internal ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"oncreateexporttable",children:"%OnCreateExportTable"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %OnCreateExportTable(pClassDef As %Dictionary.ClassDefinition, pVerbose As %Boolean) As %Status [ Private ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Callback invoked by %ExportDataTable when creating the export table definition."}),"\n",(0,s.jsx)(t.h3,{id:"onexporttable",children:"%OnExportTable"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %OnExportTable(pClassName As %String, pVerbose As %Boolean, pTracking As %Boolean) As %Status [ Abstract, Private ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Callback invoked by %ExportDataTable to load the data into export table pClassName."}),"\n",(0,s.jsx)(t.h3,{id:"addtermsfromsql",children:"%AddTermsFromSQL"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method %AddTermsFromSQL(pSQL As %String, pType As %String = "entity", pNegationContext As %String = "undefined", pCount As %String = "exactCount") As %Status\n'})}),"\n",(0,s.jsx)(t.p,{children:'Adds all terms selected by pSQL as pType, taking the string value from the column named "term" with negation context pNegationContext and count policy pCount. If there are columns named "type", "negation" or "count" selected by the query, any values in these columns will be used instead of the defaults supplied through the respective parameters.'}),"\n",(0,s.jsx)(t.p,{children:"When adding CRC or Cooccurrence terms, use colons to separate the composing entities."}),"\n",(0,s.jsx)(t.h3,{id:"getrecordcount",children:"%GetRecordCount"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %GetRecordCount(Output pSC As %Status) As %Integer [ Abstract ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"getterminfo",children:"%GetTermInfo"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method %GetTermInfo(Output pTermInfo, pIncludeCategoryDetails As %String = "") As %Status [ Internal ]\n'})}),"\n",(0,s.jsx)(t.p,{children:'Returns an array for the current builder terms: pTermInfo(i, "spread") = [spread in training set] pTermInfo(i, "spread", j) = [spread in training set for category j] pTermInfo(i, "frequency", j) = [freq in training set for category j]'}),"\n",(0,s.jsx)(t.h3,{id:"classificationmethodset",children:"ClassificationMethodSet"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method ClassificationMethodSet(pMethod As %String) As %Status [ Internal, ServerOnly = 1 ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"dispatchsetproperty",children:"%DispatchSetProperty"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %DispatchSetProperty(Property As %String, Val) [ ServerOnly = 1 ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Dispatch unknown property setters to MethodBuilder"}),"\n",(0,s.jsx)(t.h3,{id:"dispatchgetproperty",children:"%DispatchGetProperty"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %DispatchGetProperty(Property As %String) [ ServerOnly = 1 ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Dispatch unknown property getters to MethodBuilder"}),"\n",(0,s.jsx)(t.h3,{id:"dispatchmethod",children:"%DispatchMethod"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %DispatchMethod(Method As %String, Args...) [ ServerOnly = 1 ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Dispatch unknown method calls to MethodBuilder"}),"\n",(0,s.jsx)(t.h3,{id:"getcandidateterms",children:"%GetCandidateTerms"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method %GetCandidateTerms(pType As %String = "entity") As %Status [ Internal ]\n'})}),"\n",(0,s.jsx)(t.p,{children:"INTERNAL - DO NOT INVOKE Used by MethodBuilder.%PopulateTerms() to provide: ^||%IK.TermCandidates(id) = $lb(value, spread) ^||%IK.TermCandidates(id, j) = [spread in category j]"}),"\n",(0,s.jsx)(t.h3,{id:"testclassifier",children:"%TestClassifier"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method %TestClassifier(pTestSet As %RawString, Output pResult, Output pAccuracy As %Double, pCategorySpec As %String = "", pVerbose As %Boolean = 0) As %Status [ Abstract ]\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Utility method to batch-test the classifier against a test set pTestSet. Per-record results are returned through pResult:",(0,s.jsx)(t.br,{}),"\npResult(n) = $lb([record ID], [actual category], [predicted category])"]}),"\n",(0,s.jsx)(t.p,{children:"pAccuracy will contain the raw accuracy (# of records predicted correctly) of the current model. Use %iKnow.Classificaton.Utils for more advanced model testing."}),"\n",(0,s.jsx)(t.p,{children:"If the current model's category options were added through %AddCategory without an appropriate category specification, use pCategorySpec to refer to the actual category values to test against."})]})}function c(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var s=i(96540);const n={},r=s.createContext(n);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);