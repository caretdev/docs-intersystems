"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[40374],{50263:(e,n,a)=>{a.r(n),a.d(n,{contentTitle:()=>s,default:()=>l,frontMatter:()=>o,toc:()=>i});var t=a(74848),r=a(28453);const o={pagination_prev:null,pagination_next:null},s="%iKnow.Stemming.DecompoundUtils",i=[{value:"Training the decompounder",id:"training-the-decompounder",level:2},{value:"Invoking the decompounder",id:"invoking-the-decompounder",level:2},{value:"Methods",id:"methods",level:2},{value:"GetLanguageProperties",id:"getlanguageproperties",level:3},{value:"ClearTrainingData",id:"cleartrainingdata",level:3},{value:"AppendTrainingDataFromFiles",id:"appendtrainingdatafromfiles",level:3},{value:"AppendTrainingDataFromQuery",id:"appendtrainingdatafromquery",level:3},{value:"AppendTrainingDataFromDomain",id:"appendtrainingdatafromdomain",level:3},{value:"GenerateWords",id:"generatewords",level:3},{value:"SaveWords",id:"savewords",level:3},{value:"AddWord",id:"addword",level:3},{value:"RemoveWord",id:"removeword",level:3},{value:"NeverSeparate",id:"neverseparate",level:3},{value:"CleanText",id:"cleantext",level:3},{value:"CleanWordList",id:"cleanwordlist",level:3},{value:"ConvertHiraganaNumbers",id:"converthiragananumbers",level:3},{value:"IsKatakana",id:"iskatakana",level:3},{value:"LoadDefaultPropertiesCSV",id:"loaddefaultpropertiescsv",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"iknowstemmingdecompoundutils",children:"%iKnow.Stemming.DecompoundUtils"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:"Class %iKnow.Stemming.DecompoundUtils [ Deprecated, System = 4 ]\n"})}),"\n",(0,t.jsx)(n.p,{children:'This class contains utility methods to manage the word list used by the decompounding algorithm. Decompounding is about identifying the words making up a compound term, such as the words "thunder" and "storm" in the compound term "thunderstorms". It is used primarily for search purposes, allowing you to find records containing compounds of the search terms too. Lanugages like German, where compounding happens often, require decompounding support for a good search experience.'}),"\n",(0,t.jsx)(n.h2,{id:"training-the-decompounder",children:"Training the decompounder"}),"\n",(0,t.jsxs)(n.p,{children:["The decompounding algorithm supplied here requires a list of candidate words it will try to recognize in to-be-decompounded terms. These candidate words can be added through ",(0,t.jsx)(n.em,{children:"training"})," the algorithm using any of the following methods, which accept free text that will be cut into candidate terms and then stripped of any recognizable compounds:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"AppendTrainingDataFromQuery loads candidate words from a query result set"}),"\n",(0,t.jsx)(n.li,{children:"AppendTrainingDataFromFiles loads candidate words from plaintext files"}),"\n",(0,t.jsx)(n.li,{children:"AppendTrainingDataFromDomain loads candidate words from an iKnow domain"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Alternatively, individual words can be added and removed through the AddWord and RemoveWord methods. Words that should never be separated (returned as a single word) can be registered through the NeverSeparate."}),"\n",(0,t.jsx)(n.h2,{id:"invoking-the-decompounder",children:"Invoking the decompounder"}),"\n",(0,t.jsx)(n.p,{children:"Decompounding is used by iFind indices who have their INDEXOPTION set to 2 (see also %iFind.Index.Basic). When subsequently adding records to such an indexed table, all words will be checked for compounding and additional index structures will be populated to allow retrieving records based on the compounding words."}),"\n",(0,t.jsx)(n.p,{children:"The algorithm can also be invoked directly through a %iKnow.Stemmer object, should there be any requirement to find the compounding words of a given term (ie for debug purposes)."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:' // simple training do ##class(%iKnow.Stemming.DecompoundUtils).AddWord("en", "thunder") do ##class(%iKnow.Stemming.DecompoundUtils).AddWord("en", "storm") // invoke decompounder write ##class(%iKnow.Stemmer).GetDefault("en", .tStemmer) write tStemmer.Decompound("thunderstorms", .tWords) zwrite tWords'})}),"\n",(0,t.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(n.h3,{id:"getlanguageproperties",children:"GetLanguageProperties"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod GetLanguageProperties(pLanguage As %String, Output pProps) [ Internal ]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Loads per-language decompounding properties defined at the system level, appended with any NeverSeparate annotations saved for the current namespace."}),"\n",(0,t.jsx)(n.h3,{id:"cleartrainingdata",children:"ClearTrainingData"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod ClearTrainingData(pLanguage As %String) As %Status\n"})}),"\n",(0,t.jsx)(n.p,{children:"Drops ALL training data for a given language. Use with care."}),"\n",(0,t.jsx)(n.h3,{id:"appendtrainingdatafromfiles",children:"AppendTrainingDataFromFiles"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:'ClassMethod AppendTrainingDataFromFiles(pDirectory As %String = "", pLanguage As %String = "en", pClean As %Boolean = 1, pVerbose As %Boolean = 1) As %Status\n'})}),"\n",(0,t.jsx)(n.p,{children:"Appends word frequency information drawn from the *.txt files in pDirectory to the word dictionary for decompounding in this namespace. Multiple calls to this method (for different directories) will append to the existing info. Use ClearTrainingData if you want to drop all existing data."}),"\n",(0,t.jsx)(n.p,{children:"When pClean=1, the generated word list will automatically be cleaned after loading the new data through a call to CleanWordList. You may use pClean=0 and only call CleanWordList after appending training data from multiple sources, but it should be called once before decompounding any new words through the %iKnow.Stemmer object."}),"\n",(0,t.jsx)(n.h3,{id:"appendtrainingdatafromquery",children:"AppendTrainingDataFromQuery"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:'ClassMethod AppendTrainingDataFromQuery(pResultSet As %ResultSet, pLanguage As %String = "en", pClean As %Boolean = 1, pVerbose As %Boolean = 1) As %Status\n'})}),"\n",(0,t.jsx)(n.p,{children:"Appends word frequency information drawn from the first column of the supplied %ResultSet to the word dictionary for decompounding in this namespace. Multiple calls to this method (for different resultsets) will append to the existing info. Use ClearTrainingData if you want to drop all existing data."}),"\n",(0,t.jsx)(n.p,{children:"When pClean=1, the generated word list will automatically be cleaned after loading the new data through a call to CleanWordList. You may use pClean=0 and only call CleanWordList after appending training data from multiple sources, but it should be called once before decompounding any new words through the %iKnow.Stemmer object."}),"\n",(0,t.jsx)(n.h3,{id:"appendtrainingdatafromdomain",children:"AppendTrainingDataFromDomain"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:'ClassMethod AppendTrainingDataFromDomain(pDomainName As %String, pLanguage As %String = "en", pEntType As %Integer = {$$$ENTTYPEANY}, pClean As %Boolean = 1, pVerbose As %Boolean = 1) As %Status\n'})}),"\n",(0,t.jsx)(n.p,{children:"Appends word frequency information drawn from an existing iKnow domain to the word dictionary for decompounding in this namespace. When pEntType=$$$ENTTYPEANY (default), the full sentence values (with literal info) will be used to derive words. To restrict this to concepts or relations only, use $$$ENTTYPECONCEPT resp. $$$ENTTYPERELATION."}),"\n",(0,t.jsx)(n.p,{children:"Multiple calls to this method (for different resultsets) will append to the existing info. Use ClearTrainingData if you want to drop all existing data."}),"\n",(0,t.jsx)(n.p,{children:"When pClean=1, the generated word list will automatically be cleaned after loading the new data through a call to CleanWordList. You may use pClean=0 and only call CleanWordList after appending training data from multiple sources, but it should be called once before decompounding any new words through the %iKnow.Stemmer object."}),"\n",(0,t.jsx)(n.h3,{id:"generatewords",children:"GenerateWords"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:'ClassMethod GenerateWords(pText As %String = "", ByRef pLangProps, pTrackCaps As %Boolean = 0, pFreq As %Integer = 1) As %Status [ Private ]\n'})}),"\n",(0,t.jsx)(n.p,{children:"Queues words in a PPG ^||%IK.Words, to be saved by SaveWords"}),"\n",(0,t.jsx)(n.h3,{id:"savewords",children:"SaveWords"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod SaveWords(pLangId As %Integer, pVerbose As %Boolean = 0) As %Status [ Private ]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Saves the words queued in ^||%IK.Words by GenerateWords"}),"\n",(0,t.jsx)(n.h3,{id:"addword",children:"AddWord"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod AddWord(pLanguage As %String, pWord As %String, pFrequency As %Integer = 1, pClean As %Boolean = 1, pVerbose As %Boolean = 0) As %Status\n"})}),"\n",(0,t.jsx)(n.p,{children:"Adds a word to the compound dictionary for the supplied language. The supplied word will be treated as a valid compound element the algorithm will no longer try to split in smaller elements. Optionally supply a positive integer frequency value to increase its weight when multiple options are available."}),"\n",(0,t.jsx)(n.p,{children:"If pWord is also present in the list of strings never to split off through a call to NeverSeparate, it will be removed from that list."}),"\n",(0,t.jsx)(n.p,{children:"When performing a lot of manual updates, it is recommended to set pClean=0 and only run the CleanWords method once after all additions, to verify if these new additions indicate particular existing words should be removed as they turn out to be compounds themselves."}),"\n",(0,t.jsx)(n.h3,{id:"removeword",children:"RemoveWord"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod RemoveWord(pLanguage As %String, pWord As %String) As %Status\n"})}),"\n",(0,t.jsx)(n.p,{children:"Removes a word from the compound dictionary for the supplied language. This word will no longer be treated as a valid compound element. Use this to clear the list of eventual composite words added previously."}),"\n",(0,t.jsx)(n.h3,{id:"neverseparate",children:"NeverSeparate"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod NeverSeparate(pLanguage As %String, pString As %String) As %Status\n"})}),"\n",(0,t.jsx)(n.p,{children:"Marks pString as a character sequence that should never be split off and therefore never be returned as a compound element of its own. If this string was also part of the compound dictionary as a candidate, it will be removed automatically as if calling RemoveWord"}),"\n",(0,t.jsx)(n.h3,{id:"cleantext",children:"CleanText"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod CleanText(pText As %String, pKeepCaseAndSent As %Boolean = 0) As %String [ Internal ]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"cleanwordlist",children:"CleanWordList"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:'ClassMethod CleanWordList(pLanguage As %String = "en", pVerbose As %Boolean = 0, pOutputFile As %String = "", pFilter As %String = "") As %Status\n'})}),"\n",(0,t.jsx)(n.p,{children:"Clears any identifiable compounds from the current decompound dictionary for pLanguage. This method should be run at least once between appending data to the training set through any of the Append* methods in this class and using the Decompound() method in a %iKnow.Stemmer object."}),"\n",(0,t.jsx)(n.h3,{id:"converthiragananumbers",children:"ConvertHiraganaNumbers"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod ConvertHiraganaNumbers(pString As %String) As %String [ Internal ]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"iskatakana",children:"IsKatakana"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod IsKatakana(pString As %String) As %Boolean [ Internal ]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"loaddefaultpropertiescsv",children:"LoadDefaultPropertiesCSV"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod LoadDefaultPropertiesCSV(pPath As %String) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Loads default stemming properties from the KB files. FOR INTERNAL USE ONLY. DO NOT INVOKE THIS METHOD."})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>i});var t=a(96540);const r={},o=t.createContext(r);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);