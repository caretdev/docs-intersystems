"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[3956],{22441:(e,t,s)=>{s.r(t),s.d(t,{contentTitle:()=>i,default:()=>o,frontMatter:()=>r,toc:()=>l});var a=s(74848),n=s(28453);const r={pagination_prev:null,pagination_next:null},i="%iKnow.Matching.Formats.Format",l=[{value:"Properties",id:"properties",level:2},{value:"DomainId",id:"domainid",level:3},{value:"Methods",id:"methods",level:2},{value:"MatchSingle",id:"matchsingle",level:3},{value:"HasMatchAll",id:"hasmatchall",level:3},{value:"MatchAll",id:"matchall",level:3},{value:"MatchAllHashes",id:"matchallhashes",level:3},{value:"Finalize",id:"finalize",level:3},{value:"ConvertFormatCase",id:"convertformatcase",level:3},{value:"%OnNew",id:"onnew",level:3},{value:"TestParams",id:"testparams",level:3}];function c(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"iknowmatchingformatsformat",children:"%iKnow.Matching.Formats.Format"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Class %iKnow.Matching.Formats.Format Extends %RegisteredObject [ Abstract, Deprecated, System = 4 ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"This abstract class describes the interface to be implemented by an actual Dictionary Format matching object. Subclasses of this class can for example introduce regular expression matching, date matching, number checking or something more domain-specific."}),"\n",(0,a.jsx)(t.p,{children:"Subclasses should at least override MatchSingle and optionally provide a format-specific implementation for MatchAll."}),"\n",(0,a.jsxs)(t.p,{children:["Format implementations can be parameterized through a number of parameters the Format class defines, which will get passed to the MatchSingle and MatchAll methods as a ",(0,a.jsx)(t.em,{children:"formatParams"})," parameter of type %List."]}),"\n",(0,a.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,a.jsx)(t.h3,{id:"domainid",children:"DomainId"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Property DomainId As %Integer [ ReadOnly ];\n"})}),"\n",(0,a.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(t.h3,{id:"matchsingle",children:"MatchSingle"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method MatchSingle(string As %String, formatParams As %List, Output matchScore As %Numeric, Output matchedWordBits, Output isScattered As %Boolean, Output formatOutput) As %Status [ Abstract ]\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Implementations of this method check whether an individual ",(0,a.jsx)(t.em,{children:"string"})," complies with the format this class represents, returning a ",(0,a.jsx)(t.em,{children:"matchScore"})," (0..1) and optional ",(0,a.jsx)(t.em,{children:"matchedWordBits"}),", ",(0,a.jsx)(t.em,{children:"isScattered"})," and ",(0,a.jsx)(t.em,{children:"formatOutput"})," through output parameters."]}),"\n",(0,a.jsx)(t.h3,{id:"hasmatchall",children:"HasMatchAll"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method HasMatchAll() As %Boolean\n"})}),"\n",(0,a.jsx)(t.p,{children:"Whether or not this Format class has a MatchAll function that deals with a set of strings directly. Subclasses should make sure to override this method (to make it return true) if they override MatchAll."}),"\n",(0,a.jsx)(t.h3,{id:"matchall",children:"MatchAll"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method MatchAll(stringsGlobalName As %String, resultGlobalName As %String, formatParams As %List, minEntUniId As %Integer = 0) As %Status\n"})}),"\n",(0,a.jsx)(t.p,{children:'This method loops through @stringsGlobalName@(" "_string) = id and matches all global entries, storing the results in @resultGlobalName@(id) = $lb(matchScore, matchedWordBits, isScattered, formatOutput). The implementation should ignore all ids < minEntUniId and should not store any results if the matchScore is 0.'}),"\n",(0,a.jsx)(t.p,{children:"Implementing this method only makes sense if the specific format this class represents can exploit the inverse global structure of @stringsGlobalName."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Note:"})," entries in @stringsGlobalName are all in lowercase and prefixed with a space"]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Warning:"})," an implementation for this method does not replace MatchSingle. There should still be a MatchSingle alternative, for example to process strings longer than $$$IKHASHSIZE that would not appear in @stringsGlobalName."]}),"\n",(0,a.jsx)(t.h3,{id:"matchallhashes",children:"MatchAllHashes"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method MatchAllHashes(hashGlobalName As %String, idGlobalName As %String, resultGlobalName As %String, formatParams As %List, minEntUniId As %Integer = 0) As %Status [ Final ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"As MatchAll can only tackle those strings shorter than $$$IKHASHSIZE, this method complements it by looping through the corresponding global structures for longer strings and checking them manually using MatchSingle."}),"\n",(0,a.jsx)(t.h3,{id:"finalize",children:"Finalize"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method Finalize() As %Status\n"})}),"\n",(0,a.jsx)(t.p,{children:"This method is called after matching has finished to clean up eventual memory structures generated while executing MatchSingle or MatchAll calls and can be overridden in subclasses to perform any required cleanup operations."}),"\n",(0,a.jsx)(t.h3,{id:"convertformatcase",children:"ConvertFormatCase"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method ConvertFormatCase(formatString As %String) As %String [ Internal ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"Utility method to ensure a string used in the format matching process is in the same case set as the strings supplied to the MatchSingle method."}),"\n",(0,a.jsx)(t.h3,{id:"onnew",children:"%OnNew"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method %OnNew(domainId As %Integer) As %Status [ Private, ServerOnly = 1 ]\n"})}),"\n",(0,a.jsx)(t.h3,{id:"testparams",children:"TestParams"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod TestParams(pFormatParams As %List, pDomainId As %Integer = 0) As %Status\n"})}),"\n",(0,a.jsx)(t.p,{children:'Utility method subclasses can implement to verify user-supplied format parameters are valid. The default implementation instantiates an object of this matching format class and calls its MatchSingle method for "test string". The %Status object returned by that call is returned for this method.'})]})}function o(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>l});var a=s(96540);const n={},r=a.createContext(n);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);