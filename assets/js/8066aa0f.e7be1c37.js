"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[37331],{30410:(e,s,n)=>{n.r(s),n.d(s,{contentTitle:()=>l,default:()=>o,frontMatter:()=>r,toc:()=>i});var t=n(74848),a=n(28453);const r={pagination_prev:null,pagination_next:null},l="%DeepSee.extensions.clusters.CLARA",i=[{value:"Properties",id:"properties",level:2},{value:"SampleSize",id:"samplesize",level:3},{value:"UseSA",id:"usesa",level:3},{value:"CacheCost",id:"cachecost",level:3},{value:"Treshold",id:"treshold",level:3},{value:"NIdle",id:"nidle",level:3},{value:"Methods",id:"methods",level:2},{value:"New",id:"new",level:3},{value:"Open",id:"open",level:3},{value:"Create",id:"create",level:3},{value:"Prepare",id:"prepare",level:3},{value:"IsPrepared",id:"isprepared",level:3},{value:"Execute",id:"execute",level:3},{value:"ExecuteLoop",id:"executeloop",level:3},{value:"CreateSample",id:"createsample",level:3},{value:"GenerateRandomSample",id:"generaterandomsample",level:3},{value:"GenerateUniformSample",id:"generateuniformsample",level:3},{value:"Merge",id:"merge",level:3}];function c(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"deepseeextensionsclustersclara",children:"%DeepSee.extensions.clusters.CLARA"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Class %DeepSee.extensions.clusters.CLARA Extends PAM [ System = 4 ]\n"})}),"\n",(0,t.jsx)(s.p,{children:"This class provides an implemantation of CLARA (Clustering for Large Applications) algorithm."}),"\n",(0,t.jsx)(s.p,{children:"An obvious way of clustering larger datasets is to try and extend existing methods so that they can cope with a larger number of objects. The focus is on clustering large numbers of objects rather than a small number of objects in high dimensions. Kaufman and Rousseeuw (1990) suggested the CLARA (Clustering for Large Applications) algorithm for tackling large applications. CLARA extends their k-medoids approach or a large number of objects. It works by clustering a sample from the dataset and then assigns all objects in the dataset to these clusters."}),"\n",(0,t.jsx)(s.p,{children:"CLARA (CLustering LARge Applications) relies on the sampling approach to handle large data sets. Instead of finding medoids for the entire data set, CLARA draws a small sample from the data set and applies the PAM algorithm to generate an optimal set of medoids for the sample. The quality of resulting medoids is measured by the average dissimilarity between every object in the entire data set D and the medoid of its cluster"}),"\n",(0,t.jsx)(s.p,{children:"To alleviate sampling bias, CLARA repeats the sampling and clustering process a pre-defined number of times and subsequently selects as the final clustering result the set of medoids with the minimal cost."}),"\n",(0,t.jsx)(s.h2,{id:"properties",children:"Properties"}),"\n",(0,t.jsx)(s.h3,{id:"samplesize",children:"SampleSize"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property SampleSize As %Integer [ InitialExpression = 100 ];\n"})}),"\n",(0,t.jsx)(s.p,{children:"Sample Size to use for one PAM run"}),"\n",(0,t.jsx)(s.h3,{id:"usesa",children:"UseSA"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property UseSA As %Boolean [ InitialExpression = 0 ];\n"})}),"\n",(0,t.jsx)(s.p,{children:"Whether to use Simulated Annealing in each PAM run for a sample (not recommended)."}),"\n",(0,t.jsx)(s.h3,{id:"cachecost",children:"CacheCost"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property CacheCost As %Integer [ InitialExpression = -1 ];\n"})}),"\n",(0,t.jsx)(s.p,{children:"Unused in current implementation"}),"\n",(0,t.jsx)(s.h3,{id:"treshold",children:"Treshold"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property Treshold As %Double [ InitialExpression = 0.001 ];\n"})}),"\n",(0,t.jsx)(s.p,{children:"Treshold to determine when to stop"}),"\n",(0,t.jsx)(s.h3,{id:"nidle",children:"NIdle"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Property NIdle As %Integer [ InitialExpression = 5 ];\n"})}),"\n",(0,t.jsx)(s.p,{children:"A minimum number of idle iterations (i.e. iterations that do not improve the total cost)."}),"\n",(0,t.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(s.h3,{id:"new",children:"New"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod New(dsName As %String, Output sc As %Status) As CLARA\n"})}),"\n",(0,t.jsx)(s.h3,{id:"open",children:"Open"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod Open(dsName As %String, Output sc As %Status) As CLARA\n"})}),"\n",(0,t.jsx)(s.h3,{id:"create",children:"Create"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod Create(dsName As %String, new As %Boolean, Output sc As %Status) As CLARA [ Private ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"prepare",children:"Prepare"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method Prepare() As %Status\n"})}),"\n",(0,t.jsx)(s.h3,{id:"isprepared",children:"IsPrepared"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method IsPrepared() As %Boolean\n"})}),"\n",(0,t.jsx)(s.h3,{id:"execute",children:"Execute"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method Execute() As %Status\n"})}),"\n",(0,t.jsx)(s.h3,{id:"executeloop",children:"ExecuteLoop"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method ExecuteLoop() As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"createsample",children:"CreateSample"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method CreateSample(tempds As %String, uniform As %Boolean, Output sc As %Status) As %DeepSee.extensions.clusters.PAM [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"generaterandomsample",children:"GenerateRandomSample"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method GenerateRandomSample(tempds As %String) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"generateuniformsample",children:"GenerateUniformSample"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method GenerateUniformSample(tempds As %String) As %Status [ Internal ]\n"})}),"\n",(0,t.jsx)(s.h3,{id:"merge",children:"Merge"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-objectscript-class",children:"Method Merge(model As %DeepSee.extensions.clusters.PAM) As %Status [ Internal ]\n"})})]})}function o(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>i});var t=n(96540);const a={},r=t.createContext(a);function l(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);