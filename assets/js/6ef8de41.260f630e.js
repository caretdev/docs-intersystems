"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[49866],{76314:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>r,default:()=>l,frontMatter:()=>a,toc:()=>c});var s=t(74848),i=t(28453);const a={pagination_prev:null,pagination_next:null},r="%Net.JSON.JWT",c=[{value:"Methods",id:"methods",level:2},{value:"Create",id:"create",level:3},{value:"Validate",id:"validate",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"netjsonjwt",children:"%Net.JSON.JWT"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objectscript-class",children:"Class %Net.JSON.JWT Extends %RegisteredObject [ System = 4 ]\n"})}),"\n",(0,s.jsx)(n.p,{children:"This class provides methods to create and validate JSON Web Tokens, as defined in RFC 7519."}),"\n",(0,s.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(n.h3,{id:"create",children:"Create"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objectscript-class",children:'ClassMethod Create(sigJOSE As %DynamicObject, encJOSE As %DynamicObject, claims As %DynamicObject, sigJWKS As %String = "", encJWKS As %String = "", Output JWT As %String) As %Status\n'})}),"\n",(0,s.jsx)(n.p,{children:"This method creates a JSON Web Token (JWT)."}),"\n",(0,s.jsx)(n.p,{children:"Input parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"sigJOSE - Object representation of the JSON Object Signing and Encryption (JOSE) Header to be used if this JWT is going to be signed."}),"\n",(0,s.jsx)(n.li,{children:"encJOSE - Object representation of the JSON Object Signing and Encryption (JOSE) Header to be used if this JWT is going to be encrypted."}),"\n",(0,s.jsx)(n.li,{children:"claims - Object representation of the claims to be contained in the JWT."}),"\n",(0,s.jsx)(n.li,{children:"sigJWKS - The JSON Web Key Set (JWKS) that contains the key to be used for signing this JWT (if it is going to be signed). This defaults to null."}),"\n",(0,s.jsx)(n.li,{children:"encJWKS - The JWKS that contains the key to be used for encrypting this JWT (if it is going to be encrypted). This defaults to null."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Output parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"JWT - The JWT that is created."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Return value:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A status indicating whether or not a JWT could be created given the provided inputs, where error values indicate that a JWT could not be created and describe the reason why."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Notes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'If sigJOSE is defined, then sigJWKS must also be defined unless the signing algorithm is "none".'}),"\n",(0,s.jsx)(n.li,{children:"If encJOSE is defined, then encJWKS must also be defined."}),"\n",(0,s.jsx)(n.li,{children:"If both sigJOSE and encJOSE are defined, then the JWT will be signed, then encrypted as recommended in RFC 7519 section 11.2."}),"\n",(0,s.jsx)(n.li,{children:"sigJWKS and encJWKS can be the same JWKS, but if both signing and encryption are to be used then the arguments must both be passed (even if they contain the same value)."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"validate",children:"Validate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objectscript-class",children:'ClassMethod Validate(JWT As %String, sigJWKS As %String = "", encJWKS As %String = "", acceptUnsecured As %Boolean = 0, Output claims As %DynamicObject, Output operations As %DynamicArray) As %Status\n'})}),"\n",(0,s.jsx)(n.p,{children:"This method validates a JSON Web Token (JWT)."}),"\n",(0,s.jsx)(n.p,{children:"Input parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"JWT - The JWT to be validated."}),"\n",(0,s.jsx)(n.li,{children:"sigJWKS - The JSON Web Key Set (JWKS) that contains the key to be used for verifying this JWT's signature (if it was signed). This defaults to null."}),"\n",(0,s.jsx)(n.li,{children:"encJWKS - The JWKS that contains the key to be used for decrypting this JWT (if it was encrypted). This defaults to null."}),"\n",(0,s.jsx)(n.li,{children:"acceptUnsecured - Boolean value indicating whether to accept unsecured JWTs or not. This defaults to false."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Output parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"claims - Object representation of the claims contained in the JWT."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Return value:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A status indicating whether or not the provided JWT was validated given the provided JWKSs, where error values indicate that the JWT is not valid and describe the reason why."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Notes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"sigJWKS and encJWKS can be the same JWKS, but if both signing and encryption were used then the arguments must both be passed (even if they contain the same value)."}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(96540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);