"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[1899],{86765:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>r,default:()=>c,frontMatter:()=>a,toc:()=>l});var s=n(74848),i=n(28453);const a={pagination_prev:null,pagination_next:null},r="%XML.Writer",l=[{value:"Properties",id:"properties",level:2},{value:"Format",id:"format",level:3},{value:"Charset",id:"charset",level:3},{value:"DocumentCharset",id:"documentcharset",level:3},{value:"Indent",id:"indent",level:3},{value:"IndentChars",id:"indentchars",level:3},{value:"RuntimeIgnoreNull",id:"runtimeignorenull",level:3},{value:"Summary",id:"summary",level:3},{value:"ReferencesInline",id:"referencesinline",level:3},{value:"Shallow",id:"shallow",level:3},{value:"CycleCheck",id:"cyclecheck",level:3},{value:"Base64LineBreaks",id:"base64linebreaks",level:3},{value:"NoXMLDeclaration",id:"noxmldeclaration",level:3},{value:"Canonical",id:"canonical",level:3},{value:"ElementQualified",id:"elementqualified",level:3},{value:"AttributeQualified",id:"attributequalified",level:3},{value:"DefaultNamespace",id:"defaultnamespace",level:3},{value:"SuppressXmlns",id:"suppressxmlns",level:3},{value:"SuppressAutoPrefix",id:"suppressautoprefix",level:3},{value:"DefaultXmlns",id:"defaultxmlns",level:3},{value:"OutputTypeAttribute",id:"outputtypeattribute",level:3},{value:"Namespaces",id:"namespaces",level:3},{value:"InDocument",id:"indocument",level:3},{value:"InternalStartDocument",id:"internalstartdocument",level:3},{value:"InRootElement",id:"inrootelement",level:3},{value:"InForest",id:"inforest",level:3},{value:"InTag",id:"intag",level:3},{value:"CurrentIndent",id:"currentindent",level:3},{value:"IndentNext",id:"indentnext",level:3},{value:"OrefList",id:"oreflist",level:3},{value:"IdList",id:"idlist",level:3},{value:"ElementStack",id:"elementstack",level:3},{value:"OutputDestination",id:"outputdestination",level:3},{value:"OutputTable",id:"outputtable",level:3},{value:"OutputFilename",id:"outputfilename",level:3},{value:"OriginalTable",id:"originaltable",level:3},{value:"ExtendedDocument",id:"extendeddocument",level:3},{value:"OutputStream",id:"outputstream",level:3},{value:"UserStream",id:"userstream",level:3},{value:"SaveIO",id:"saveio",level:3},{value:"Methods",id:"methods",level:2},{value:"DefaultXmlnsSet",id:"defaultxmlnsset",level:3},{value:"OutputTypeAttributeSet",id:"outputtypeattributeset",level:3},{value:"OutputToDevice",id:"outputtodevice",level:3},{value:"OutputToString",id:"outputtostring",level:3},{value:"GetXMLString",id:"getxmlstring",level:3},{value:"OutputToStream",id:"outputtostream",level:3},{value:"OutputToFile",id:"outputtofile",level:3},{value:"Reset",id:"reset",level:3},{value:"InitNamespaces",id:"initnamespaces",level:3},{value:"AddNamespace",id:"addnamespace",level:3},{value:"AddInstanceNamespace",id:"addinstancenamespace",level:3},{value:"AddSchemaNamespace",id:"addschemanamespace",level:3},{value:"AddSOAPNamespace",id:"addsoapnamespace",level:3},{value:"AddSOAP12Namespace",id:"addsoap12namespace",level:3},{value:"StartDocument",id:"startdocument",level:3},{value:"EndDocument",id:"enddocument",level:3},{value:"StartDocumentInternal",id:"startdocumentinternal",level:3},{value:"EndDocumentInternal",id:"enddocumentinternal",level:3},{value:"RootObject",id:"rootobject",level:3},{value:"RootElement",id:"rootelement",level:3},{value:"EndRootElement",id:"endrootelement",level:3},{value:"ParsePrefixList",id:"parseprefixlist",level:3},{value:"Canonicalize",id:"canonicalize",level:3},{value:"CanonicalTree",id:"canonicaltree",level:3},{value:"CanonicalTreeInternal",id:"canonicaltreeinternal",level:3},{value:"Document",id:"document",level:3},{value:"DocumentNode",id:"documentnode",level:3},{value:"Tree",id:"tree",level:3},{value:"TreeInternal",id:"treeinternal",level:3},{value:"Object",id:"object",level:3},{value:"Element",id:"element",level:3},{value:"WriteAttribute",id:"writeattribute",level:3},{value:"EndElement",id:"endelement",level:3},{value:"Write",id:"write",level:3},{value:"StartWrite",id:"startwrite",level:3},{value:"EndWrite",id:"endwrite",level:3},{value:"WriteChars",id:"writechars",level:3},{value:"CharsText",id:"charstext",level:3},{value:"AttributeText",id:"attributetext",level:3},{value:"WriteCData",id:"writecdata",level:3},{value:"WriteBase64",id:"writebase64",level:3},{value:"WriteBinHex",id:"writebinhex",level:3},{value:"WriteComment",id:"writecomment",level:3},{value:"WriteDocType",id:"writedoctype",level:3},{value:"WriteProcessingInstruction",id:"writeprocessinginstruction",level:3}];function o(e){const t={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"xmlwriter",children:"%XML.Writer"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Class %XML.Writer Extends %RegisteredObject [ System = 3 ]\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"For details on using this class"}),", see ",(0,s.jsx)(t.a,{href:"/csp/docbook/Doc.View.cls?FIND=CLASSES+%25XML.Writer",children:"Writing XML Output from Objects"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"The %XML.Writer controls export of XML from InterSystems IRIS. It generates a complete XML document including the <?xml> tag. %XML.Writer works sequentially, outputting the XML as it goes."}),"\n",(0,s.jsx)(t.p,{children:"%XML.Writer works in two phases. During the first phase, any required parameters are set for the entire document, for example indentation, charset, output media. In the second phase the root element and its child elements are exported. The root element may be the export of a single object and its referenced objects. Or the root element may be a simple element with any number of objects exported as its children."}),"\n",(0,s.jsx)(t.p,{children:"All parts of the XML document should be output using methods of this class. The Write method may be used to output unformatted and unescaped text inside the the root element of the document. In this case the user is responsible for proper management of namespaces and nesting. Additionally, the Object() and Element() may be used to output nested elements."}),"\n",(0,s.jsx)(t.p,{children:"Namespace handling is for the most part automatic. %XML.Writer adds namespaces, with automatically created prefixes, to the XML output as needed. The usage of namespaces is controlled by the ElementQualified, AttributeQualified and DefaultNamespace properties, and any namespace argument to an Object or Element call. However, it is possible to control when a namespace is introduced into the document and the prefix used with the AddNamespace method."}),"\n",(0,s.jsxs)(t.p,{children:["The following usage example wraps two instances of the Sample.Person class in  tags and sets the root tag to  as an example of possible adherence to a business rule: ",(0,s.jsx)(t.code,{children:'set x1=##class(Sample.Person).%OpenId(1) set x2=##class(Sample.Person).%OpenId(2) set writer=##class(%XML.Writer).%New() set writer.Charset="UTF-8" set sc=writer.OutputToString() If $$$ISERR(sc) Do $system.OBJ.DisplayError(sc) Quit s sc=writer.RootElement("CustomerList") If $$$ISERR(sc) Do $system.OBJ.DisplayError(sc) Quit set sc=writer.Object(x1,"Customer") If $$$ISERR(sc) Do $system.OBJ.DisplayError(sc) Quit set sc=writer.Object(x2,"Customer") If $$$ISERR(sc) Do $system.OBJ.DisplayError(sc) Quit s sc=writer.EndRootElement() If $$$ISERR(sc) Do $system.OBJ.DisplayError(sc) Quit s string=writer.GetXMLString()'})]}),"\n",(0,s.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,s.jsx)(t.h3,{id:"format",children:"Format"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Property Format As %String [ InitialExpression = "literal" ];\n'})}),"\n",(0,s.jsx)(t.p,{children:'The format of the XML document: "literal", "encoded" or "encoded12", "literal" is the default. For "literal" formatting is according to the schema for this document. For "encoded" formatting use SOAP encoding as specified by section 5 of the SOAP 1.1 standard. For "encoded12" formatting use SOAP encoding as specified by part 2 of the SOAP 1.2 standard.'}),"\n",(0,s.jsx)(t.h3,{id:"charset",children:"Charset"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Charset As %String;\n"})}),"\n",(0,s.jsx)(t.p,{children:'Charset is the charset to use for encoding the XML output. The default depends upon the output destination. "UTF-8" is the default for output to files and binary streams. "UTF-16" is the default for output to character streams and strings.'}),"\n",(0,s.jsx)(t.h3,{id:"documentcharset",children:"DocumentCharset"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property DocumentCharset As %String [ Internal, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Copy of Charset property for internal use within a document."}),"\n",(0,s.jsx)(t.h3,{id:"indent",children:"Indent"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Indent As %Boolean [ InitialExpression = 0 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Indent specifies that indentation of the XML output should take place."}),"\n",(0,s.jsx)(t.h3,{id:"indentchars",children:"IndentChars"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Property IndentChars As %String [ InitialExpression = "  " ];\n'})}),"\n",(0,s.jsx)(t.p,{children:"IndentChars specifies the character sequence to be used for each indent level if Indent=1."}),"\n",(0,s.jsx)(t.h3,{id:"runtimeignorenull",children:"RuntimeIgnoreNull"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property RuntimeIgnoreNull As %String [ InitialExpression = 0 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:'If XMLIGNORENULL = "runtime", then the behavior of XMLIGNORENULL is determined by the RuntimeIgnoreNull property. RuntimeIgnoreNull specifies the value of XMLIGNORENULL at runtime as either 0, 1 or inputonly. RuntimeIgnoreNull="inputonly" is equivalent to RuntimeIgnoreNull=0.'}),"\n",(0,s.jsx)(t.h3,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Summary As %Boolean [ InitialExpression = 0 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"If Summary is 1 (true), then export the summary that is specified by the XMLSUMMARY class parameter. Otherwise, export the entire object."}),"\n",(0,s.jsx)(t.h3,{id:"referencesinline",children:"ReferencesInline"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property ReferencesInline As %Boolean [ InitialExpression = 0 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:'If ReferencesInline is 1 (true), then encoded objects are exported inline. By default, SOAP encoded XMLExport of a class uses idref\'s for class instances referenced by a class that is being exported. This change allows the referenced class instances to be exported inline as for "literal" format. Note that unlike most properties of %XML.Writer, changing the value of ReferencesInline has immediate effect on the next object exported.'}),"\n",(0,s.jsx)(t.h3,{id:"shallow",children:"Shallow"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Shallow As %Boolean;\n"})}),"\n",(0,s.jsx)(t.p,{children:"The Shallow controls shallow XML export of objects where referenced objects are not exported. Embedded (serial) objects will still be exported. To indicate shallow export, set Shallow to 1 (default is 0). Note that unlike most properties of %XML.Writer, changing the value of Shallow has immediate effect on the next object exported."}),"\n",(0,s.jsx)(t.h3,{id:"cyclecheck",children:"CycleCheck"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property CycleCheck As %Boolean [ InitialExpression = 1 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"If CycleCheck is true (1), then any object to be exported is checked for cycles in the referenced classes which could result in  error. The default is 1."}),"\n",(0,s.jsx)(t.h3,{id:"base64linebreaks",children:"Base64LineBreaks"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Base64LineBreaks As %Boolean [ InitialExpression = 0 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"If Base64LineBreaks is true (1), then remove line breaks from base64 encoded XML output for all properties of type %Binary or %xsd.base64Binary. The default is 0 which will be to not include line breaks."}),"\n",(0,s.jsx)(t.h3,{id:"noxmldeclaration",children:"NoXMLDeclaration"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property NoXMLDeclaration As %Boolean;\n"})}),"\n",(0,s.jsx)(t.p,{children:"If NoXMLDeclaration is 1 (true), then the XML declaration will not be written. The default is to write the XML declaration unless Charset is not specified and the output is directed to a string or character stream in which case no XML declaration is written."}),"\n",(0,s.jsx)(t.h3,{id:"canonical",children:"Canonical"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Canonical As %Boolean [ Internal, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"If Canonical is 1 (true), then output is formatted according to XML Exclusive Canonicalization specification."}),"\n",(0,s.jsx)(t.h3,{id:"elementqualified",children:"ElementQualified"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property ElementQualified As %Boolean;\n"})}),"\n",(0,s.jsx)(t.p,{children:'ElementQualified indicates whether or not locally declared elements must be qualified. The default for Format="encoded"or "encoded12" = 0 and the default for Format="literal" is 1. See elementFormDefault schema attribute.'}),"\n",(0,s.jsx)(t.h3,{id:"attributequalified",children:"AttributeQualified"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property AttributeQualified As %Boolean [ InitialExpression = 0 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"AttributeQualified indicates whether or not locally declared attributes must be qualified. See attributeFormDefault schema attribute."}),"\n",(0,s.jsx)(t.h3,{id:"defaultnamespace",children:"DefaultNamespace"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property DefaultNamespace As %String;\n"})}),"\n",(0,s.jsx)(t.p,{children:"DefaultNamespace is the XML namespace to use for any exported classes that do not have the NAMESPACE parameter specified. If the NAMESPACE parameter is specified for a class, then the namespace specified in the class is always used."}),"\n",(0,s.jsx)(t.h3,{id:"suppressxmlns",children:"SuppressXmlns"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property SuppressXmlns As %Boolean [ InitialExpression = 0 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"SuppressXmlns allows optionally suppression of the use of xmlns= to set default XML namespace when ElementQualified is false. If SuppressXmlns is true then a prefix is used for each tag rather than default namespace with xmlns=."}),"\n",(0,s.jsx)(t.h3,{id:"suppressautoprefix",children:"SuppressAutoPrefix"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property SuppressAutoPrefix As %Boolean [ InitialExpression = 0, Internal, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"SuppressAutoPrefix allows optionally suppression of the prefix that is created for the default XML namespace even if it is not needed for the current element."}),"\n",(0,s.jsx)(t.h3,{id:"defaultxmlns",children:"DefaultXmlns"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property DefaultXmlns As %String;\n"})}),"\n",(0,s.jsx)(t.p,{children:"DefaultXmlns allows optional specification of the XML namespace to use as the default XML namespace when SuppressXmlns is false."}),"\n",(0,s.jsx)(t.h3,{id:"outputtypeattribute",children:"OutputTypeAttribute"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property OutputTypeAttribute As %Boolean [ InitialExpression = 0 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"OutputTypeAttribute allows the user to force the inclusion of the xsi:type attribute for each element of object output."}),"\n",(0,s.jsx)(t.h3,{id:"namespaces",children:"Namespaces"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property Namespaces As %XML.Namespaces [ Internal ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"The namespace manager class."}),"\n",(0,s.jsx)(t.h3,{id:"indocument",children:"InDocument"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property InDocument As %Boolean [ InitialExpression = 0, Internal, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"True if we've started writing the XML document."}),"\n",(0,s.jsx)(t.h3,{id:"internalstartdocument",children:"InternalStartDocument"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property InternalStartDocument As %Boolean [ InitialExpression = 0, Internal, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"True if document was implictely started without StartDocument call."}),"\n",(0,s.jsx)(t.h3,{id:"inrootelement",children:"InRootElement"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property InRootElement As %Boolean [ InitialExpression = 0, Internal, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"True if we've started writing the root element."}),"\n",(0,s.jsx)(t.h3,{id:"inforest",children:"InForest"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property InForest As %Boolean [ InitialExpression = 0, Internal, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"True if forest allowed instead of just single root node. Note that this may not be a valid document."}),"\n",(0,s.jsx)(t.h3,{id:"intag",children:"InTag"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property InTag As %Boolean [ InitialExpression = 0, Internal, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"True if we've written the tag and not yet finished the start element."}),"\n",(0,s.jsx)(t.h3,{id:"currentindent",children:"CurrentIndent"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property CurrentIndent As %String;\n"})}),"\n",(0,s.jsx)(t.p,{children:"The current indent level."}),"\n",(0,s.jsx)(t.h3,{id:"indentnext",children:"IndentNext"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property IndentNext As %Boolean [ InitialExpression = 0, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"If true, indenting to be done for next element, comment or processing instruction."}),"\n",(0,s.jsx)(t.h3,{id:"oreflist",children:"OrefList"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property OrefList As %String [ MultiDimensional, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Internal list of orefs for use by encoded output."}),"\n",(0,s.jsx)(t.h3,{id:"idlist",children:"IdList"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property IdList As %String [ MultiDimensional, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Internal list of orefs for use by encoded output."}),"\n",(0,s.jsx)(t.h3,{id:"elementstack",children:"ElementStack"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property ElementStack As %String [ MultiDimensional, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:'Stack of end elements for currently started elements. ElementStack(index) == qname for element ElementStack(index,"ns") == previous default namespace'}),"\n",(0,s.jsx)(t.h3,{id:"outputdestination",children:"OutputDestination"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Property OutputDestination As %String [ InitialExpression = "device", Private ];\n'})}),"\n",(0,s.jsx)(t.p,{children:'Internal list of ids for use by encoded output. Destination for %XML.Writer output. Possible values are "file", "charstream", "binarystream", "charstring" and "device".'}),"\n",(0,s.jsx)(t.h3,{id:"outputtable",children:"OutputTable"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property OutputTable As %String [ Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Internal -- translate table used for output"}),"\n",(0,s.jsx)(t.h3,{id:"outputfilename",children:"OutputFilename"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property OutputFilename As %String [ Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Filename for output to file."}),"\n",(0,s.jsx)(t.h3,{id:"originaltable",children:"OriginalTable"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property OriginalTable As %String [ Internal, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Internal -- original translate table for current output device"}),"\n",(0,s.jsx)(t.h3,{id:"extendeddocument",children:"ExtendedDocument"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property ExtendedDocument As %Boolean [ Internal ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"True if a document has already been written to this file/stream. This property is for internal use only. You should not make direct use of it within your applications. There is no guarantee made about either the behavior or future operation of this property."}),"\n",(0,s.jsx)(t.h3,{id:"outputstream",children:"OutputStream"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property OutputStream As %RegisteredObject [ Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Stream for output to stream or file. Will store a stream, but declare as %RegisteredObject to prevent auto create of serial object."}),"\n",(0,s.jsx)(t.h3,{id:"userstream",children:"UserStream"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property UserStream As %RegisteredObject [ Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"User specified Global stream that will receive data. Will store a stream, but declare as %RegisteredObject to prevent auto create of serial object."}),"\n",(0,s.jsx)(t.h3,{id:"saveio",children:"SaveIO"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property SaveIO As %String [ Internal, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Save current $io"}),"\n",(0,s.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(t.h3,{id:"defaultxmlnsset",children:"DefaultXmlnsSet"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method DefaultXmlnsSet(value As %String) As %Status [ Internal ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"outputtypeattributeset",children:"OutputTypeAttributeSet"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method OutputTypeAttributeSet(value As %Boolean) As %Status [ Internal ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"outputtodevice",children:"OutputToDevice"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method OutputToDevice() As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"OutputToDevice sets output to the current device which is the default if no output method is specified."}),"\n",(0,s.jsx)(t.h3,{id:"outputtostring",children:"OutputToString"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method OutputToString() As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"OutputToString sets output to be directed to a string. GetXMLString may be called after output is complete to a string to retrieve the output."}),"\n",(0,s.jsx)(t.h3,{id:"getxmlstring",children:"GetXMLString"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method GetXMLString(ByRef status As %Status) As %String\n"})}),"\n",(0,s.jsx)(t.p,{children:"GetXMLString gets output generated using OutputToString."}),"\n",(0,s.jsx)(t.h3,{id:"outputtostream",children:"OutputToStream"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method OutputToStream(ByRef export As %BinaryStream) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:'OutputToStream sets output to be directed to a stream. export is the exported stream. If export is the oref of a stream, the XML document will be written to this existing stream at the current position. If export is "", then a new %FileBinaryStream will be created to contain the XML document and its oref returned. In this case, export must be passed by reference.'}),"\n",(0,s.jsx)(t.h3,{id:"outputtofile",children:"OutputToFile"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method OutputToFile(filename As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"OutputToFile sets output to be directed to a new file, named filename."}),"\n",(0,s.jsx)(t.h3,{id:"reset",children:"Reset"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Reset() As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"The Reset method may be called after an XML document has been output by RootObject or RootElement to reintialize the properties and output method of the XML document."}),"\n",(0,s.jsx)(t.h3,{id:"initnamespaces",children:"InitNamespaces"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method InitNamespaces() As %Status [ Internal ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Initialize the namespaces manager. This method is for internal use only. You should not make direct use of it within your applications. There is no guarantee made about either the behavior or future operation of this property."}),"\n",(0,s.jsx)(t.h3,{id:"addnamespace",children:"AddNamespace"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method AddNamespace(namespace As %String, prefix As %String, schemaLocation As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"AddNamespace adds a namespace to the XML document for all elements added at this nesting level. The prefix to be used for the namespace may optionally be specified with the prefix argument. A schemaLocation attribute value for the first definition of this namespace may also specified. For example, if many children of an element will use the same namespace, it is better to add the namespace above the containing element, so that the prefix may be defined only once at the containing level using the xmlns:prefix attribute."}),"\n",(0,s.jsx)(t.h3,{id:"addinstancenamespace",children:"AddInstanceNamespace"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method AddInstanceNamespace(prefix As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:'AddInstanceNamespace adds the schema instance namespace to the document using the optional prefix. If the prefix argument is not specifed, "xsi" is used as the prefix.'}),"\n",(0,s.jsx)(t.h3,{id:"addschemanamespace",children:"AddSchemaNamespace"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method AddSchemaNamespace(prefix As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:'AddSchemaNamespace adds the schema namespace to the document using the optional prefix. If the prefix argument is not specifed, "s" is used as the prefix.'}),"\n",(0,s.jsx)(t.h3,{id:"addsoapnamespace",children:"AddSOAPNamespace"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method AddSOAPNamespace(soapPrefix As %String, schemaPrefix As %String, xsiPrefix As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"AddSOAPNamespace adds the SOAP 1.1 encoding, schema and schema instance namespaces to the document using the optional prefixes soapPrefix, schemaPrefixPrefix and xsiPrefix."}),"\n",(0,s.jsx)(t.h3,{id:"addsoap12namespace",children:"AddSOAP12Namespace"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method AddSOAP12Namespace(soapPrefix As %String, schemaPrefix As %String, xsiPrefix As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"AddSOAP12Namespace adds the SOAP 1.2 encoding, schema and schema instance namespaces to the document using the optional prefixes soapPrefix, schemaPrefixPrefix and xsiPrefix."}),"\n",(0,s.jsx)(t.h3,{id:"startdocument",children:"StartDocument"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method StartDocument(allowForest As %Boolean = 0) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Start output of the XML document If allowForest = true, then mutiple root nodes are allowed."}),"\n",(0,s.jsx)(t.h3,{id:"enddocument",children:"EndDocument"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method EndDocument() As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Finish output of the XML document"}),"\n",(0,s.jsx)(t.h3,{id:"startdocumentinternal",children:"StartDocumentInternal"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method StartDocumentInternal(rootOK As %Boolean) As %Status [ Private ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"This method is for internal use only. You should not make direct use of it within your applications. There is no guarantee made about either the behavior or future operation of this property."}),"\n",(0,s.jsx)(t.h3,{id:"enddocumentinternal",children:"EndDocumentInternal"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method EndDocumentInternal() As %Status [ Private ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"This method is for internal use only. You should not make direct use of it within your applications. There is no guarantee made about either the behavior or future operation of this property."}),"\n",(0,s.jsx)(t.h3,{id:"rootobject",children:"RootObject"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method RootObject(object As %XML.Adaptor, tag As %String, namespace As %String, className As %String, bare As %Boolean) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"RootObject will output the document as a single object instance and all its references. The RootObject method initializes itself based on the properties of the %XML.Writer instance and does the output. When output is complete, it writes the final end tag and closes the output device. At this point, the %XML.Writer properties may be modified and RootObject or RootElement called again to output another document."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"object is the XML enabled object instance to output."}),"\n",(0,s.jsx)(t.li,{children:"tag optionally specifies the tag name to be used for this element."}),"\n",(0,s.jsx)(t.li,{children:"namespace optionally specifies the default namespace for this object. If the NAMESPACE parameter is specified for a class, then the namespace specified in the class is always used."}),"\n",(0,s.jsx)(t.li,{children:"className is the expected name of this object's class. If the className is specified and this class's name is not equal to the name in className, then add a xsi:type attribute to the element."}),"\n",(0,s.jsx)(t.li,{children:'bare is for internal ISC use only.\nIf the Format="encoded" property is used and RootObject called, then all object instances will be output as embedded in the top level object. This is usually not desired and therefore objects to be output using SOAP encoding should usually be enclosed in by a root element using RootElement and EndRootElement.'}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"rootelement",children:"RootElement"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method RootElement(root, namespace As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"The RootElement method writes only the root element of the XML document Child elments must be written by the user. The RootElement method initializes based on the properties of the %XML.Writer instance and does the output. EndRootElement() writes the final end tag and closes the output device. After EndRootElement() is called, the properties may be modified and RootObject or RootElement called again to output another document."}),"\n",(0,s.jsxs)(t.p,{children:["There are two possible polymorphic formats for the RootElement method. The element to output may be either have its name specified as a %String or have the element specified as a %XML.Element instance. root is the root element specified either as a tag name or an %XML.Element instance.",(0,s.jsx)(t.br,{}),"\nnamespace optionally specifies the default namespace for this element and any nested elements."]}),"\n",(0,s.jsx)(t.h3,{id:"endrootelement",children:"EndRootElement"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method EndRootElement() As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"EndRootElement is the method to end the root element."}),"\n",(0,s.jsx)(t.h3,{id:"parseprefixlist",children:"ParsePrefixList"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod ParsePrefixList(PrefixList As %String, ByRef PrefixListArray)\n"})}),"\n",(0,s.jsx)(t.p,{children:"The ParsePrefixList parses the PrefixList that is specified for Exclusive Canonicalization as a list of NMTOKENS. True (1) is returned if the parsing is successful."}),"\n",(0,s.jsx)(t.h3,{id:"canonicalize",children:"Canonicalize"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method Canonicalize(node As %XML.Node, ByRef PrefixList, formatXML As %Boolean = 0, isSTR As %Boolean = 0, mimeAttachments As %Net.MIMEPart = "") As %Status\n'})}),"\n",(0,s.jsx)(t.p,{children:"The Canonicalize method writes an XML document with root element specified by the %XML.Node class in canonicalized form specified by the Exclusive XML Canonicalization or Canonical XML (also called inclusive canonicalization) specification."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"node is the parse tree that represents the XML document to be output."}),"\n",(0,s.jsx)(t.li,{children:'For Exclusive XML Canonicalization PrefixList is a multidimensional array which specifies the prefixes that are included on the IncludedNamespaces list. PrefixList(prefix)="" if the prefix is on the list. If PrefixList is = "c14n", then inclusive canonicalization is performed.'}),"\n",(0,s.jsx)(t.li,{children:"If formatXML is true, the formatting specified for %XML.Writer rather than the formatting specified by the XML Canonicalization specification is used. The output is not strictly speaking canonical XML, but has done the namespace processing for canonical XML. This behavior is useful for outputting a fragment of an XML document, such as the SOAP body in the ProcessBodyNode callback from a web service, while still having some control of the format."}),"\n",(0,s.jsx)(t.li,{children:'isSTR is for internal use. If true, keep xmlns="" on the APEX node as specified by WS-Security for canonicalization of XML freferenced by a SecurityTokenReference.'}),"\n",(0,s.jsx)(t.li,{children:"If the XML document is in MTOM format, then mimeAttachments is a mime part which contains in the Parts property the list of attachments."}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"canonicaltree",children:"CanonicalTree"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method CanonicalTree(node As %XML.Node, ByRef PrefixList, isSTR As %Boolean = 0, mimeAttachments As %Net.MIMEPart = "") As %Status\n'})}),"\n",(0,s.jsx)(t.p,{children:"The CanonicalTree method writes element content as represented by the %XML.Node class in canonicalized form specified by the Exclusive XML Canonicalization or Canonical XML (also called inclusive canonicalization) specification."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"node is the parse tree that represents the XML document to be output."}),"\n",(0,s.jsx)(t.li,{children:'For Exclusive XML Canonicalization PrefixList is a multidimensional array which specifies the prefixes that are included on the IncludedNamespaces list. PrefixList(prefix)="" if the prefix is on the list. If PrefixList is = "c14n", then inclusive canonicalization is performed.'}),"\n",(0,s.jsx)(t.li,{children:'isSTR is for internal use. If true, keep xmlns="" on the APEX node as specified by WS-Security for canonicalization of XML freferenced by a SecurityTokenReference.'}),"\n",(0,s.jsx)(t.li,{children:"If the XML document is in MTOM format, then mimeAttachments is a mime part which contains in the Parts property the list of attachments."}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"canonicaltreeinternal",children:"CanonicalTreeInternal"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method CanonicalTreeInternal(DocId As %String, NodeId As %String, baseChildlist As %String, ByRef PrefixList, isSTR As %Boolean, mimeAttachments As %Net.MIMEPart, addedPrefix) As %Status [ Internal ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"The CanonicalTreeInternal method is an internal method to implement recursion needed to canonicalize."}),"\n",(0,s.jsx)(t.h3,{id:"document",children:"Document"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Document(documentArg As %XML.Document) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"The Document method writes the XML document represented by the %XML.Document class. The Document method initializes based on the properties of the %XML.Writer instance and does the output. document is the parse tree that represents the XML document to be output."}),"\n",(0,s.jsx)(t.h3,{id:"documentnode",children:"DocumentNode"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method DocumentNode(node As %XML.Node) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"The DocumentNode method writes the XML document represented by the %XML.Node class. The DocumentNode method initializes based on the properties of the %XML.Writer instance and does the output. node is the parse tree that represents the XML document to be output."}),"\n",(0,s.jsx)(t.h3,{id:"tree",children:"Tree"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Tree(node As %XML.Node, keepxmlns As %Boolean = 0) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"The Tree method writes the XML document node represented by the %XML.Node class and its tree of descendants.. node is an %XML.Node class that is positioned at the node to output."}),"\n",(0,s.jsx)(t.h3,{id:"treeinternal",children:"TreeInternal"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method TreeInternal(DocId As %String, NodeId As %String, baseChildlist As %String, keepxmlns As %Boolean = 0) As %Status [ Internal ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"The TreeInternal method is an internal method to implement recursion needed to output document from DOM."}),"\n",(0,s.jsx)(t.h3,{id:"object",children:"Object"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Object(objectArg As %XML.Adaptor, tag As %String, namespace As %String, local As %Boolean, className As %String, bare As %Boolean) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Object outputs objects nested in the root object of an XML document."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"object is the XML enabled object instance to output."}),"\n",(0,s.jsx)(t.li,{children:"tag optionally specifies the tag name to be used for this element."}),"\n",(0,s.jsx)(t.li,{children:"namespace optionally specifies the default namespace for this object. If the NAMESPACE parameter is specified for a class, then the namespace specified in the class is always used."}),"\n",(0,s.jsx)(t.li,{children:"local specifies if the element is treated as a local element. Default is 0 (false)."}),"\n",(0,s.jsx)(t.li,{children:"className is the expected name of this object's class. If the className is specified and this class's name is not equal to the name in className, then add a xsi:type attribute to the element."}),"\n",(0,s.jsx)(t.li,{children:"bare is for internal ISC use only."}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"element",children:"Element"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Element(tag, namespace As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Element outputs elements nested in the root object of an XML document."}),"\n",(0,s.jsxs)(t.p,{children:["There are two possible polymorphic formats for the Element method. The element to output may be either have its name specified as a %String or have the element specified as a %XML.Element instance. tag is the nexted element specified either as a tag name or an %XML.Element instance.",(0,s.jsx)(t.br,{}),"\nnamespace optionally specifies the default namespace for this element and any nested elements."]}),"\n",(0,s.jsx)(t.h3,{id:"writeattribute",children:"WriteAttribute"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'Method WriteAttribute(name As %String, value As %String = "", namespace As %String, valueNamespace As %String = "", global As %Boolean = 0) As %Status\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The WriteAttribute method writes an attribute for the last element started. This method may only be called immediately after StartElement or Element.",(0,s.jsx)(t.br,{}),"\nArguments: - name is the attribute name and is required.",(0,s.jsx)(t.br,{}),"\n- value is the attribute value and is required.",(0,s.jsx)(t.br,{}),"\n- namespace is the optional namespace for the attribute name. If namespace is not specified, then the default XML namespace is used for the attribute name.",(0,s.jsx)(t.br,{}),"\n- valueNamespace is the namespace for the value.",(0,s.jsx)(t.br,{}),"\nIf valueNamespace is not specified (the most usual case), no namespace prefix is used for the value. valueNamespace is used for attributes like xsi:type whose value comes from an XML schema namespace. - global is true if the attribute is global in the associated XML schema and thus should have a prefix. Default is false."]}),"\n",(0,s.jsx)(t.h3,{id:"endelement",children:"EndElement"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method EndElement() As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"EndElement outputs the end element for the matching element started with the Element method."}),"\n",(0,s.jsx)(t.h3,{id:"write",children:"Write"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Write(text) As %Status\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Write writes arbitrary text in the XML document without any escaping being done. This method can be used in any part of the XML document.",(0,s.jsx)(t.br,{}),"\nArgument:",(0,s.jsx)(t.br,{}),"\n- text The character data to output. Type of %String or %CharacterStream."]}),"\n",(0,s.jsx)(t.h3,{id:"startwrite",children:"StartWrite"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method StartWrite() As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"StartWrite sets the current device for writing arbitrary text in the XML document without any escaping being done. This method can be used in any part of the XML document."}),"\n",(0,s.jsx)(t.h3,{id:"endwrite",children:"EndWrite"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method EndWrite() As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"EndWrite restores the current device to before matching StartWrite. This method can be used in any part of the XML document."}),"\n",(0,s.jsx)(t.h3,{id:"writechars",children:"WriteChars"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method WriteChars(text) As %Status\n"})}),"\n",(0,s.jsxs)(t.p,{children:["WriteChars writes XML element text performing any required escaping. This method is used to write element content.",(0,s.jsx)(t.br,{}),"\nArgument:",(0,s.jsx)(t.br,{}),"\n- text The character data to output. Type of %String or %CharacterStream."]}),"\n",(0,s.jsx)(t.h3,{id:"charstext",children:"CharsText"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method CharsText(text As %String, Output overflow) As %String\n"})}),"\n",(0,s.jsx)(t.p,{children:"Do canonical formatting of element text"}),"\n",(0,s.jsx)(t.h3,{id:"attributetext",children:"AttributeText"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method AttributeText(attrval As %String) As %String\n"})}),"\n",(0,s.jsx)(t.p,{children:"Do canonical formatting of attribute text"}),"\n",(0,s.jsx)(t.h3,{id:"writecdata",children:"WriteCData"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method WriteCData(text) As %Status\n"})}),"\n",(0,s.jsxs)(t.p,{children:["WriteCData writes XML element text in a CData section. This method is used to write element content.",(0,s.jsx)(t.br,{}),"\nArgument:",(0,s.jsx)(t.br,{}),"\n- text The character data to output. Type of %String or %CharacterStream."]}),"\n",(0,s.jsx)(t.h3,{id:"writebase64",children:"WriteBase64"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method WriteBase64(binary) As %Status\n"})}),"\n",(0,s.jsxs)(t.p,{children:["WriteBase64 encodes the specified binary bytes as base64 and writes out the resulting text. This method is used to write element content.",(0,s.jsx)(t.br,{}),"\nArgument:",(0,s.jsx)(t.br,{}),"\n- binary The binary data to output. Type of %Binary or %BinaryStream."]}),"\n",(0,s.jsx)(t.h3,{id:"writebinhex",children:"WriteBinHex"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method WriteBinHex(binary) As %Status\n"})}),"\n",(0,s.jsxs)(t.p,{children:["WriteBinHex encodes the specified binary bytes as binhex and writes out the resulting text. This method is used to write element content.",(0,s.jsx)(t.br,{}),"\nArgument:",(0,s.jsx)(t.br,{}),"\n- binary The binary data to output. Type of %Binary or %BinaryStream."]}),"\n",(0,s.jsx)(t.h3,{id:"writecomment",children:"WriteComment"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method WriteComment(text) As %Status\n"})}),"\n",(0,s.jsxs)(t.p,{children:["WriteComment writes out a comment  containing the specified text. This method can be used in any part of the XML document.",(0,s.jsx)(t.br,{}),"\nArgument:",(0,s.jsx)(t.br,{}),"\n- text Text to place inside the comment. Type of %String or %CharacterStream."]}),"\n",(0,s.jsx)(t.h3,{id:"writedoctype",children:"WriteDocType"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method WriteDocType(name As %String, PublicId As %String, SystemId As %String, subset As %String) As %Status\n"})}),"\n",(0,s.jsxs)(t.p,{children:["WriteDocType writes the DOCTYPE declaration with the specified name and optional attributes. This method may only be called before the root element is written.",(0,s.jsx)(t.br,{}),"\nArguments:",(0,s.jsx)(t.br,{}),"\n- name The name of the DOCTYPE. This must be non-empty.",(0,s.jsx)(t.br,{}),'\n- PublicId If non-null it also writes PUBLIC "PublicId" "SystemId" where PublicId and SystemId are replaced with the value of the given arguments.',(0,s.jsx)(t.br,{}),'\n- SystemId If PublicId is null and SystemId is non-null it writes SYSTEM "SystemId" where SystemId is replaced with the value of this argument.',(0,s.jsx)(t.br,{}),"\n- subset If non-null it writes [Subset] where Subset is replaced with the value of this argument."]}),"\n",(0,s.jsx)(t.h3,{id:"writeprocessinginstruction",children:"WriteProcessingInstruction"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method WriteProcessingInstruction(name As %String, text As %String) As %Status\n"})}),"\n",(0,s.jsxs)(t.p,{children:["WriteProcessingInstruction writes out a processing instruction with a space between the name and text as follows: ",". This method may only be called outside the root element is written.",(0,s.jsx)(t.br,{}),"\nArguments:",(0,s.jsx)(t.br,{}),"\n- name Name of the processing instruction.",(0,s.jsx)(t.br,{}),"\n- text Text to include in the processing instruction."]})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>l});var s=n(96540);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);