"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[40578],{82985:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>a,default:()=>d,frontMatter:()=>s,toc:()=>c});var r=n(74848),i=n(28453);const s={pagination_prev:null,pagination_next:null},a="%Net.JSON.JWE",c=[{value:"Methods",id:"methods",level:2},{value:"Encrypt",id:"encrypt",level:3},{value:"Decrypt",id:"decrypt",level:3},{value:"EncryptCompact",id:"encryptcompact",level:3},{value:"EncryptJSON",id:"encryptjson",level:3},{value:"DecryptCompact",id:"decryptcompact",level:3},{value:"DecryptJSON",id:"decryptjson",level:3},{value:"CreateCEK",id:"createcek",level:3},{value:"EncryptCEK",id:"encryptcek",level:3},{value:"CreateCiphertext",id:"createciphertext",level:3},{value:"DecryptCEK",id:"decryptcek",level:3},{value:"DecryptCiphertext",id:"decryptciphertext",level:3},{value:"ExtractAllRecipients",id:"extractallrecipients",level:3},{value:"ExtractGeneralFormat",id:"extractgeneralformat",level:3},{value:"ExtractFlattenedFormat",id:"extractflattenedformat",level:3}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"netjsonjwe",children:"%Net.JSON.JWE"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Class %Net.JSON.JWE Extends %RegisteredObject [ System = 4 ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This class provides methods to encrypt and decrypt JSON Web Encryption objects, as defined in RFC 7516."}),"\n",(0,r.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(t.h3,{id:"encrypt",children:"Encrypt"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:'ClassMethod Encrypt(protectedHeader As %DynamicObject, sharedUnprotectedHeader As %DynamicObject, perRecipientUnprotectedHeader As %DynamicObject, plaintext As %String, AAD As %String = "", serialization As %String = "compact", JWKS As %String, Output JWE As %String) As %Status\n'})}),"\n",(0,r.jsx)(t.p,{children:"This method encrypts a message and makes a JWE."}),"\n",(0,r.jsx)(t.p,{children:"Input parameters:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"protectedHeader - The JOSE Protected Header to use."}),"\n",(0,r.jsx)(t.li,{children:"sharedUnprotectedHeader - The JOSE Shared Unprotected Header to use."}),"\n",(0,r.jsx)(t.li,{children:"perRecipientUnprotectedHeader - The JOSE Per-Recipient Unprotected Header to use."}),"\n",(0,r.jsx)(t.li,{children:"plaintext - The message being encrypted."}),"\n",(0,r.jsx)(t.li,{children:"AAD - any Additional Authenticated Data to input to the content encryption algorithm. This defaults to null."}),"\n",(0,r.jsx)(t.li,{children:'serialization - The JWE Serialization format to use. Accepted serialization formats are "compact" and "json". The format type determines the structure of the JWE that is created. This defaults to "compact"'}),"\n",(0,r.jsx)(t.li,{children:"JWKS - The JSON Web Key Set that contains the key that will be used to create the content encryption key for this JWE."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Output parameters:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"JWE - The JSON Web Encryption that is created. If json serialization is used, this will be a valid JSON string. If compact serialization is used it will be a non-JSON string."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Return value:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"A status indicating whether or not a JWE was created from the inputs. If this method is unable to create a JWE from the inputs it will return an error indicating why this is."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Notes:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"At least one of the headers must be present and non-null."}),"\n",(0,r.jsx)(t.li,{children:"If none of the provided headers contains a kid but in the process of creating the JWE a JWK with a kid is used, that kid will be added to the protected header before the JWE is created."}),"\n",(0,r.jsx)(t.li,{children:"This method will fail if provided an empty plaintext."}),"\n",(0,r.jsx)(t.li,{children:'If the "compact" serialization format is used, the protected header MUST be present and both unprotected headers MUST be absent. If the "json" format is used, at least one of the protected header and unprotected headers MUST be present and they all CAN be present.\nOnly the JWE Compact Serialization and the flattened syntax of the JWE JSON Serialization are supported for encryption (not the general format of the JWE JSON Serialization).'}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"decrypt",children:"Decrypt"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Decrypt(JWE As %String, JWKS As %String, Output plaintext As %String, Output decryptions As %DynamicArray) As %Status\n"})}),"\n",(0,r.jsx)(t.p,{children:"This method decrypts a JWE."}),"\n",(0,r.jsx)(t.p,{children:"Input parameters:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"JWE - The JSON Web Encryption to be decrypted."}),"\n",(0,r.jsx)(t.li,{children:"JWKS - The JSON Web Key Set that contains the key that will be used to create the content encryption key needed to validate this JWS."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Output parameters:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"plaintext - The decrypted plaintext."}),"\n",(0,r.jsxs)(t.li,{children:["decryptions - A dynamic array containing information about whether or not each encrypted key in the JWE successfully decrypted the ciphertext. The decryptions array contains one DynamicObject for each encrypted key in the JWE, each containing the following fields:\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:'"encryptedKey": The encrypted key this DynamicObject contains information about.'}),"\n",(0,r.jsx)(t.li,{children:'"decrypted": A boolean indicating whether or not the encrypted key successfully decrypted the ciphertext.'}),"\n",(0,r.jsx)(t.li,{children:'"error": A string containing any error message that was generating during the decryption of the ciphertext.'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Return value:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"A status indicating whether or not the JWE's ciphertext was successfully decrypted. (If there are multiple encrypted keys in the JWE, this method will return a success as long as at least one of the keys successfully decrypts the ciphertext.) If the ciphertext was not successfully decrypted this method will return an error describing why."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Notes:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"This method will not accept an empty JWE. If provided one, it will return false and the decryptions array will be null."}),"\n",(0,r.jsx)(t.li,{children:"This method supports decryption for the JWE Compact Serialization and both the flattened and general syntax of the JWE JSON Serialization."}),"\n",(0,r.jsx)(t.li,{children:"For ease of development, this method returns detailed error messages. However, applications that use this method should take care when passing these errors on to end users, as doing so could allow their application to be used as an oracle for decrypting messages. Note, in particular, that applications should report formatting errors to the CEK, AAD, and ciphertext of the provided JWE as a single error, as per RFC 7516 section 11.4."}),"\n",(0,r.jsx)(t.li,{children:"If the provided JWE contains multiple encrypted keys, this method will succeed and output the plaintext as long as at least one of the keys successfully decrypted the ciphertext."}),"\n",(0,r.jsx)(t.li,{children:"Some applications may only want to consider a JWE with multiple encrypted keys valid if all of the encrypted keys successfully decrypt the ciphertext. Since this method only needs one encrypted key to decrypt the plaintext in order to return the plaintext, applications that require all encrypted keys to successfully decrypt the ciphertext should use the error field of each encrypted key in the validations array to meet their needs. Specifically, they should check to see if any encrypted key's error field is not null. Any encrypted key whose error field is not null failed to decrypt the ciphertext (which is why it has an error message), so the presence of any non-null error fields means that at least one encrypted key failed to decrypt the ciphertext."}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"encryptcompact",children:"EncryptCompact"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod EncryptCompact(header As %DynamicObject, plaintext As %String, JWKS As %String, Output JWE As %String) As %Status [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private method encrypts and creates a compact serialized JWE. It is a helper method for Encrypt() above and should never be called on its own. See Encrypt() for information on the inputs and outputs."}),"\n",(0,r.jsx)(t.h3,{id:"encryptjson",children:"EncryptJSON"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod EncryptJSON(protectedHeader As %DynamicObject, sharedUnprotectedHeader As %DynamicObject, perRecipientUnprotectedHeader As %DynamicObject, plaintext As %String, JWEAAD As %String, JWKS As %String, Output JWE As %String) As %Status [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private method encrypts and creates a JSON serialized JWE with flattened syntax. It is a helper method for Encrypt() above and should never be called on its own. See Encrypt() for information on the inputs and outputs."}),"\n",(0,r.jsx)(t.h3,{id:"decryptcompact",children:"DecryptCompact"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod DecryptCompact(JWE As %String, JWKS As %String, Output plaintext As %String, Output decryptions As %DynamicArray) As %Status [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private method decrypts a compact serialized JWE and returns an object containing information on the decryption status of the encrypted key in the JWE. It is a helper method for Decrypt() above and should never be called on its own. See Decrypt() for information on the inputs and outputs."}),"\n",(0,r.jsx)(t.h3,{id:"decryptjson",children:"DecryptJSON"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod DecryptJSON(JWE As %String, JWKS As %String, Output plaintext As %String, Output decryptions As %DynamicArray) As %Status [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private method decrypts a JSON serialized JWE and returns an object containing information on the decryption status of each encrypted key in the JWE. It is a helper method for Decrypt() above and should never be called on its own. See Decrypt() for information on the inputs and outputs."}),"\n",(0,r.jsx)(t.h3,{id:"createcek",children:"CreateCEK"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod CreateCEK(algInfo As %DynamicObject, encInfo As %DynamicObject, JWK As %DynamicObject, Output CEK As %String) As %Status [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private helper method creates a Content Encryption Key based on the given algorithm information and JWK."}),"\n",(0,r.jsx)(t.h3,{id:"encryptcek",children:"EncryptCEK"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod EncryptCEK(algInfo As %DynamicObject, JWK As %DynamicObject, CEK As %String, Output encryptedCEK As %String) As %Status [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private helper method encrypts the Content Encryption Key based on the given algorithm information and JWK."}),"\n",(0,r.jsx)(t.h3,{id:"createciphertext",children:"CreateCiphertext"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod CreateCiphertext(encInfo As %DynamicObject, plaintext As %String, CEK As %String, IV As %String, AAD As %String, Output ciphertext As %String, Output authTag As %String) As %Status [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private helper method is what actually encrypts the plaintext using the provided encryption algorithm information and inputs. It outputs both the ciphertext and an authentication tag."}),"\n",(0,r.jsx)(t.h3,{id:"decryptcek",children:"DecryptCEK"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod DecryptCEK(algInfo As %DynamicObject, JWK As %DynamicObject, encryptedCEK As %String, Output CEK As %String) As %Status [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private helper method decrypts the Content Encryption Key based on the given algorithm information and JWK."}),"\n",(0,r.jsx)(t.h3,{id:"decryptciphertext",children:"DecryptCiphertext"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod DecryptCiphertext(encInfo As %DynamicObject, ciphertext As %String, authTag As %String, CEK As %String, IV As %String, AAD As %String, Output plaintext As %String) As %Status [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private helper method is what actually decrypts the ciphertext using the provided encryption algorithm information and inputs. Before decrypting the ciphertext, it first verifies the authentication tag."}),"\n",(0,r.jsx)(t.h3,{id:"extractallrecipients",children:"ExtractAllRecipients"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod ExtractAllRecipients(JWEObj As %DynamicObject, Output recipientsArray) As %Integer [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private helper method retrieves all of the encrypted keys and per-recipient unprotected headers from a JSON serialized JWE. It returns the number of recipients found and outputs an array of all of the encrypted keys and per-recipient unprotected headers found."}),"\n",(0,r.jsx)(t.h3,{id:"extractgeneralformat",children:"ExtractGeneralFormat"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod ExtractGeneralFormat(JWEObj As %DynamicObject, Output recipientsArray) As %Integer [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private helper method retrieves all of the encrypted keys and per-recipient unprotected headers from a JSON serialized JWE that uses general syntax. It populates a two-dimensional array to store each encrypted key alongside the corresponding per-recipient unprotected header and then returns the number of recipients found."}),"\n",(0,r.jsx)(t.h3,{id:"extractflattenedformat",children:"ExtractFlattenedFormat"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod ExtractFlattenedFormat(JWEObj As %DynamicObject, Output recipientsArray) As %Integer [ Private ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"This private helper method retrieves the encrypted key and per-recipient unprotected header from a JSON serialized JWE that uses flattened syntax. In order to ensure compatibility with the general syntax of JSON serialized JWEs, this method populates a two-dimensional array to store the encrypted key alongside the per-recipient unprotected header. It then returns the number of recipients found (which will always either be 0 or 1)."})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var r=n(96540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);