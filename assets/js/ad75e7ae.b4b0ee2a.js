"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[99910],{90191:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>l,default:()=>i,frontMatter:()=>r,toc:()=>o});var a=n(74848),s=n(28453);const r={pagination_prev:null,pagination_next:null},l="%XML.XSLT.CallbackHandler",o=[{value:"Methods",id:"methods",level:2},{value:"evaluate",id:"evaluate",level:3}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"xmlxsltcallbackhandler",children:"%XML.XSLT.CallbackHandler"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Class %XML.XSLT.CallbackHandler Extends %RegisteredObject [ System = 3 ]\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"For details on using this class"}),", see ",(0,a.jsx)(t.a,{href:"/csp/docbook/Doc.View.cls?FIND=CLASSES+%25XML.XSLT.CallbackHandler",children:"Performing XSLT Transformations"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"This class handles callbacks from the XSLT processor. You should create a subclass this class and override the 'evaluate' method to perform the processing that you require. An example of an stylesheet using this function is shown in the example XSL contained in the %XML.XSLT.Transformer class"}),"\n",(0,a.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(t.h3,{id:"evaluate",children:"evaluate"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method evaluate(Args...) As %String\n"})}),"\n",(0,a.jsx)(t.p,{children:"Evaluate receives a variable number of arguments, allowing you to pass multiple arguments on the evaluate call. The number of arguments is available in the Args variable and each value can be accessed by subscripting. The method has a single return value which will be returned as the result of the xslt evaluate function(). The return value can either be a regular cache variable or it can be an instance of a stream object. This allows for returning a value that is greater than 32k in size. The stream has to be wrapped in an instance of %XML.XSLT.StreamAdapter which facilitates the XSLT processors reading of the stream. This example shows both techniques, change the 1 to 0 to test the stream functionality (%XML.XSLT.Transformer.Example3() exercises this functionality)"})]})}function i(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>o});var a=n(96540);const s={},r=a.createContext(s);function l(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);