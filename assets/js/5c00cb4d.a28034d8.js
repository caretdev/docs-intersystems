"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[4844],{90526:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>r,default:()=>h,frontMatter:()=>i,toc:()=>o});var a=n(74848),s=n(28453);const i={pagination_prev:null,pagination_next:null},r="%SYSTEM.Semaphore",o=[{value:"Parameters",id:"parameters",level:2},{value:"%MODULENAME",id:"modulename",level:3},{value:"%MODULEBASECLASS",id:"modulebaseclass",level:3},{value:"Properties",id:"properties",level:2},{value:"SemID",id:"semid",level:3},{value:"WaitIdx",id:"waitidx",level:3},{value:"Methods",id:"methods",level:2},{value:"Create",id:"create",level:3},{value:"Open",id:"open",level:3},{value:"Delete",id:"delete",level:3},{value:"GetValue",id:"getvalue",level:3},{value:"SetValue",id:"setvalue",level:3},{value:"Increment",id:"increment",level:3},{value:"Decrement",id:"decrement",level:3},{value:"AddToWaitMany",id:"addtowaitmany",level:3},{value:"RmFromWaitMany",id:"rmfromwaitmany",level:3},{value:"WaitMany",id:"waitmany",level:3},{value:"WaitCompleted",id:"waitcompleted",level:3}];function l(e){const t={amount:"amount",code:"code",granted:"granted",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",protect:"protect",timeout:"timeout",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"systemsemaphore",children:"%SYSTEM.Semaphore"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Class %SYSTEM.Semaphore Extends %Library.SystemBase\n"})}),"\n",(0,a.jsx)(t.p,{children:"Semaphores can be used to control limited access to an application resource locally or across ECP (allowing a limited number of concurrent activities), or can be used to schedule work in the background."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Limit access to an application resource (allow a limited number of concurrent activities) such as running no more than n of certain type of job that uses some resource.\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Create a semaphore with initial value equal to the number of concurrent accesses"}),"\n",(0,a.jsx)(t.li,{children:"When the resource is required decrement that semaphore."}),"\n",(0,a.jsx)(t.li,{children:"When done with the resource increment the semaphore."}),"\n",(0,a.jsx)(t.li,{children:"When the semaphore value reaches zero decrement will wait until it becomes available."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["Schedule work\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Create a semaphore with initial value of zero."}),"\n",(0,a.jsx)(t.li,{children:"Start n worker jobs. The worker job should decrement that semaphore (which will wait until it's incremented by any job)."}),"\n",(0,a.jsx)(t.li,{children:"When there is work to be done, it should placed the work description in a queue and increment the semaphore."}),"\n",(0,a.jsx)(t.li,{children:"The background worker process decrements the semaphore and dequeues the work that needs to be processed, and does it."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Semaphores are a shared objects. They can be accessed from multiple jobs."}),"\n",(0,a.jsx)(t.p,{children:"SEMAPHORE NAMES"}),"\n",(0,a.jsx)(t.p,{children:"Semaphores are identified by their unique names. If the name starts with ^, %SYSTEM.Semaphore uses the instance global mapping to uniquely identify it (by its system name/number and SFN); otherwise the name is used as is by the instance, independent of namespace and its mappings."}),"\n",(0,a.jsx)(t.p,{children:'Note: The namespace name is stripped from the semaphore name, but the rest is used as is to uniquely identify them. i.e. ^Rem2("22") and ^Rem2(22) are not the same!!'}),"\n",(0,a.jsx)(t.p,{children:"If the associated system is a remote node, the remote semaphore is used."}),"\n",(0,a.jsxs)(t.p,{children:["Before accessing any of these methods you have to %New and then invoke Open() or Create(, ) the semaphore. Both methods return zero if the operation fails. To open/create/access any semaphore with a global name, you must have roles that give write access to the associated database, otherwise these actions will raise a ",(0,a.jsx)(t.protect,{children:" error."})]}),"\n",(0,a.jsx)(t.p,{children:"Open will fail if the semaphore does not exist. Create will open the semaphore if it already exists and ignore the initial value."}),"\n",(0,a.jsx)(t.p,{children:"Every semaphore has value, you can get its value by GetValue() or SetValue() methods. The value is typed as a 64-bit integer."}),"\n",(0,a.jsx)(t.p,{children:"A semaphore value can be increased via the Increment method by a specified amount. The amount is given as a positive, 31-bit integer."}),"\n",(0,a.jsxs)(t.p,{children:["You can Decrement(",(0,a.jsxs)(t.amount,{to:"",decrement:"",children:[", ",(0,a.jsx)(t.timeout,{in:"",seconds:"",children:") the semaphore by the specified amount. The amount must be > 0 (the amount is signed 32 bit number)."})]})]}),"\n",(0,a.jsx)(t.p,{children:"If the value of the semaphore is zero, it will wait the specified amount of time for the amount to be incremented by some other job. While the amount is zero the semaphore will track its requestors by first in first out order."}),"\n",(0,a.jsx)(t.p,{children:"If the amount requested is greater than what is available, it will return the available amount immediately. That is, if there is Decrement(10), but the current available amount is 2, it will return 2."}),"\n",(0,a.jsx)(t.p,{children:"If the Decrement times out, it returns zero. If the time out is zero, it and the Decrement cannot be done, it returns immediately. If the timeout is -1, Decrement will wait forever."}),"\n",(0,a.jsx)(t.p,{children:"If the global is mapped across ECP and the timeout is zero it will wait up to 2 seconds for the ECP response."}),"\n",(0,a.jsx)(t.p,{children:"WAITMANY"}),"\n",(0,a.jsxs)(t.p,{children:['You can wait for multiple semaphores at once. It\'s called "WaitMany" support. You specify the amount you wish to decrement to the wait-many list by the AddToWaitMany(',(0,a.jsxs)(t.amount,{to:"",decrement:"",children:[") instance method of the semaphore object and then you invoke the WaitMany(",(0,a.jsx)(t.timeout,{in:"",seconds:"",children:") class method."})]})]}),"\n",(0,a.jsxs)(t.p,{children:["When the semaphore is available it invokes/calls-back the WaitCompleted(",(0,a.jsx)(t.granted,{amount:"",children:") method which should be overwritten by the application if using the WaitMany feature. After invoking the WaitCompleted() method, AddToWaitMany must be called again for more amount if it is required."})]}),"\n",(0,a.jsx)(t.p,{children:"After adding to the WaitMany list, the RmFromWaitMany() method could be used to remove a pending entry, and release the associated resources. Otherwise they will be released when the job halts. If the object has some granted value, and it was removed by the RmFromWaitMany() before the WaitMany() call, the granted amount will be incremented back."}),"\n",(0,a.jsx)(t.p,{children:"WaitMany list is currently limited to 64."}),"\n",(0,a.jsxs)(t.p,{children:["WaitMany(",(0,a.jsx)(t.timeout,{children:") does Round Robin notification of pending WaitCompletion notification. After going through the pending grants, it returns with the number of semaphores on which WaitCompleted() was called."})]}),"\n",(0,a.jsx)(t.p,{children:"Decrement and AddToWaitMany use the same wait queue, and grants are delivered in First-In/First-Out order."}),"\n",(0,a.jsx)(t.p,{children:"Semaphores are a shared object, we can have up to 32K (32,768) of them per instance. Semaphores do not have an owner, and they are not reference-counted. Any object that can open it can delete it using the Delete() method. After deleting, any reference to that semaphore will raise an invalid semaphore error. If the semaphore is remote, it will delete the semaphore on the server and any reference to that semaphore from any app-server should fail. The WaitMany WaitCompleted method is invoked with a granted value of zero when the semaphore is deleted by a job or by an ECP failure."}),"\n",(0,a.jsx)(t.p,{children:"RECOVERY"}),"\n",(0,a.jsx)(t.p,{children:"If a job dies, the allocated resource with a wait-many list is released. But if any amount was granted, it stays granted. Nothing is returned!"}),"\n",(0,a.jsx)(t.p,{children:"ECP"}),"\n",(0,a.jsx)(t.p,{children:"If the Semaphore is a remote semaphore, most of the operations and the value are tracked by the ECP server."}),"\n",(0,a.jsx)(t.p,{children:"ECP RECOVERY"}),"\n",(0,a.jsx)(t.p,{children:"Remote semaphore operations are not recoverable since the value of the semaphores are not persistent. After any ECP/network outage or failure, all remote semaphores on the app-server are automatically deleted; on the server all pending decrements are dropped/ignored."}),"\n",(0,a.jsx)(t.p,{children:"It is the responsibility of the application to detect and recover the semaphores, by re-creating and setting their initial value(s) and state(s)."}),"\n",(0,a.jsx)(t.p,{children:"Ordering considerations:"}),"\n",(0,a.jsx)(t.p,{children:'As stated earlier, a global named "^glob" and a semaphore named "^glob" are entirely unrelated. So in a sequence of commands such as'}),"\n",(0,a.jsx)(t.p,{children:"set i=$inc(^glob) set ^glob(i)= sem.inc(^glob)"}),"\n",(0,a.jsx)(t.p,{children:"the order in which the statements are executed is guaranteed only for a single execution stream. However, when multiple jobs are involved, the order in which the objects will be manipulated cannot be guaranteed. It will be the same for each execution stream, but because multiple streams are manipulating shared objects, the order that the objects are changed is unpredictable."}),"\n",(0,a.jsx)(t.p,{children:"i.e. the following order could happen when multiple instances or jobs are involved."}),"\n",(0,a.jsx)(t.p,{children:"time job A job B 1 $inc returns 1 2 $inc returns 2 3 set ^glob(2)= 4 sem.inc(^glob) 5 <--- logical state ----\x3e 6 set ^glob(1)= 7 sem.inc(^glob)"}),"\n",(0,a.jsx)(t.p,{children:"In the above example at the indicated logical state (at time 5), when sem.inc is delivered in job B, it's guaranteed that the associated set is there, but there is no guarantee the previous and other $inc and associated data is there!!"}),"\n",(0,a.jsx)(t.p,{children:"This would be an issue when multiple nodes or jobs insert a node at the end of a Q using $inc and then they use sem.inc to notify the Q entry's presence. If another global is $inc-ed to find out what to deQ the expected node may not be there. i.e. @ time 5 if some other global is incremented to deQ, its value would be 1 and if that value is used to reference the Q, ^glob(1) wouldn't be there!!"}),"\n",(0,a.jsx)(t.p,{children:"ECP ORDERS & GUARANTEES"}),"\n",(0,a.jsx)(t.p,{children:"The following items are guaranteed for remote semaphores:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Increment(s) will happen after sets and kills.\nThe semaphore grants do not honor durability as locks do. When a lock is granted, any data before the lock grant is durable; this is NOT true for semaphores."}),"\n",(0,a.jsx)(t.li,{children:"When a semaphore is granted the data cache is guaranteed to be coherent relative to Increment()."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsx)(t.h3,{id:"modulename",children:"%MODULENAME"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Parameter %MODULENAME [ Internal ] = 3;\n"})}),"\n",(0,a.jsx)(t.h3,{id:"modulebaseclass",children:"%MODULEBASECLASS"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:'Parameter %MODULEBASECLASS [ Internal ] = "ISC_method_dispatcher, public invalidateMths";\n'})}),"\n",(0,a.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,a.jsx)(t.h3,{id:"semid",children:"SemID"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Property SemID As %Integer [ Internal, Private ];\n"})}),"\n",(0,a.jsx)(t.p,{children:"Internal semaphore ID"}),"\n",(0,a.jsx)(t.h3,{id:"waitidx",children:"WaitIdx"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Property WaitIdx As %Integer [ Internal, Private ];\n"})}),"\n",(0,a.jsx)(t.p,{children:"Multi wait list index"}),"\n",(0,a.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(t.h3,{id:"create",children:"Create"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method Create(name As %Binary, value As %CPP.LongLong = 0) As %Integer [ Language = cpp ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"Initializes this object. It must be called before accessing any of its methods. The initial value is set to the specified amount. It returns zero on failure."}),"\n",(0,a.jsx)(t.h3,{id:"open",children:"Open"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method Open(name As %Binary) As %Integer [ Language = cpp ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"Initialize a pre-existing semaphore. It must be called before accessing any of the semaphore methods. Returns zero on failure."}),"\n",(0,a.jsx)(t.h3,{id:"delete",children:"Delete"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method Delete() As %Integer [ Language = cpp ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"Semaphores are shared objects and they do not go away until they are deleted explicitly. After deletion, any references to this object from the current job or any other job will fail. If the semaphore is remote, it deletes the semaphore on the remote system too."}),"\n",(0,a.jsx)(t.h3,{id:"getvalue",children:"GetValue"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method GetValue() As %CPP.LongLong [ Language = cpp ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"Returns the current value storedin the semaphore."}),"\n",(0,a.jsx)(t.h3,{id:"setvalue",children:"SetValue"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method SetValue(amount As %CPP.LongLong) [ Language = cpp ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"Sets the current sempahore value to the specified amount."}),"\n",(0,a.jsx)(t.h3,{id:"increment",children:"Increment"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method Increment(value As %Integer) [ Language = cpp ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"Increments the semaphore by the specified amount."}),"\n",(0,a.jsx)(t.h3,{id:"decrement",children:"Decrement"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method Decrement(amount As %Integer, timeout As %Integer) As %Integer [ Language = cpp ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"If the requested amount is not available (available amount is less than the requested amount), it will decrement by the available amount, setting it to zero."}),"\n",(0,a.jsx)(t.p,{children:'If the semaphore value is zero, this method waits for the specified timeout in seconds; a value of -1 means "wait forever". If the timeout period expires and no increments have been made to the semaphore, this method returns 0.'}),"\n",(0,a.jsx)(t.p,{children:"Otherwise, the method returns the amount decremented."}),"\n",(0,a.jsx)(t.h3,{id:"addtowaitmany",children:"AddToWaitMany"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method AddToWaitMany(value As %Integer) [ Language = cpp ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"Add this semaphore to the wait-many list with the specified amount to decrement. This method uses the Decrement() method rules. It decrements in the background as soon as the semaphore value is great enough. Note: the completion code is delivered by the WaitMany() method."}),"\n",(0,a.jsx)(t.h3,{id:"rmfromwaitmany",children:"RmFromWaitMany"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method RmFromWaitMany() [ Language = cpp ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"Remove this semaphore from the wait-many list. The WaitMany() list caches the associated objects. This method must be called before closing this object so it can be properly removed from the cache, otherwise the object's reference count will never drop to zero and it will not get destroyed."}),"\n",(0,a.jsx)(t.h3,{id:"waitmany",children:"WaitMany"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod WaitMany(timeout As %Integer) As %Integer [ Language = cpp ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"Wait for multiple semaphores. It waits for all semaphores registered in the WaitMany list. It waits the specified amount of time in seconds. It returns 0 if it times out, or returns the number of sempahores that were granted."}),"\n",(0,a.jsx)(t.p,{children:"If the timeout is zero, it just polls all sempahores, and invokes the WaitCompleted methods of all available semaphores. Note: It invokes the WaitCompleted() method in a round robin order."}),"\n",(0,a.jsx)(t.h3,{id:"waitcompleted",children:"WaitCompleted"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method WaitCompleted(value As %Integer) [ Language = cpp ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"This method is invoked by the WaitMany() class method when the requested amount of semaphores are decremented. After invoking this method, the semaphore is removed from the wait-many list. An explicit invocation of AddToWaitMany is required to put it back on the wait-many list. If the associated semaphore is deleted and it was in the wait list, this method is called with a granted amount of zero."}),"\n",(0,a.jsx)(t.p,{children:"Note: this class is an abstract class and the derived sub-class must overwrite this method before any of the wait-many features can be used."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(96540);const s={},i=a.createContext(s);function r(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);