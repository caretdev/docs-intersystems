"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[90630],{82327:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>c,default:()=>l,frontMatter:()=>i,toc:()=>d});var s=t(74848),r=t(28453);const i={pagination_prev:null,pagination_next:null},c="%DeepSee.IndexBuilder",d=[{value:"Parameters",id:"parameters",level:2},{value:"BITMAPCHUNKINMEMORY",id:"bitmapchunkinmemory",level:3},{value:"Methods",id:"methods",level:2},{value:"%NextId",id:"nextid",level:3},{value:"%ConstructIndicesParallel",id:"constructindicesparallel",level:3},{value:"%ConstructIndicesStartTask",id:"constructindicesstarttask",level:3},{value:"%ConstructIndices",id:"constructindices",level:3},{value:"%SaveIndices",id:"saveindices",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"deepseeindexbuilder",children:"%DeepSee.IndexBuilder"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objectscript-class",children:"Class %DeepSee.IndexBuilder [ Abstract, System = 3 ]\n"})}),"\n",(0,s.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsx)(n.h3,{id:"bitmapchunkinmemory",children:"BITMAPCHUNKINMEMORY"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objectscript-class",children:"Parameter BITMAPCHUNKINMEMORY = 0;\n"})}),"\n",(0,s.jsx)(n.p,{children:"BITMAPCHUNKINMEMORY is used during code generation to decide whether or not bitmap chunks can be constructed in memory. It is faster to construct bitmap chunks in memory but if there are a lot of bitmaps, the indexed property or properties have very low selectivity or the index values are large then STORE errors can be encountered. If BITMAPCHUNKINMEMORY is 1 then bitmap chunks are constructed in memory by %ConstructIndices. Otherwise, bitmap chunks are constructed using process-private globals. The default is 0, meaning that bitmap chunks are built using process-private globals."}),"\n",(0,s.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(n.h3,{id:"nextid",children:"%NextId"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod %NextId(pId As %Integer, pDirection As %Integer = 1) As %Integer [ CodeMode = objectgenerator ]\n"})}),"\n",(0,s.jsx)(n.p,{children:"NextId(pId,pDirection) returns the ID value following pId if pDirection is 1 or the ID value preceding pId if pDirection is -1."}),"\n",(0,s.jsx)(n.h3,{id:"constructindicesparallel",children:"%ConstructIndicesParallel"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objectscript-class",children:'ClassMethod %ConstructIndicesParallel(pTaskId = "", pStartId As %Integer = 0, pEndId As %Integer = -1, pSortBegin As %Integer = 1, pDroneCount As %Integer = 0) As %Status\n'})}),"\n",(0,s.jsx)(n.h3,{id:"constructindicesstarttask",children:"%ConstructIndicesStartTask"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod %ConstructIndicesStartTask(pTaskId, pSortBegin) As %String [ CodeMode = objectgenerator ]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"constructindices",children:"%ConstructIndices"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod %ConstructIndices(pStartId As %Integer, pEndId As %Integer) As %Status [ CodeMode = objectgenerator ]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"saveindices",children:"%SaveIndices"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-objectscript-class",children:'ClassMethod %SaveIndices(pStartId As %String(MAXLEN="") = "", pEndId As %String(MAXLEN="") = "", lockExtent As %Boolean = 0) As %Status [ CodeMode = generator, ProcedureBlock = 1, ServerOnly = 0 ]\n'})}),"\n",(0,s.jsx)(n.p,{children:"Files the indices for all objects whose ID is in the range defined by pStartId and pEndId. If pEndId is null then it defaults to pStartId. If pStartId is null then the range is empty and no filing will occur. If lockExtent is true then an extent lock will be acquired before the indices are built. If the lock cannot be acquired then an error is returned. The lock is released after the index filing is completed."}),"\n",(0,s.jsx)(n.p,{children:"Returns a %Status value indicating success or failure."})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>d});var s=t(96540);const r={},i=s.createContext(r);function c(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);