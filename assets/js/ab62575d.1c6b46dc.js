"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[25077],{13885:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>s,default:()=>l,frontMatter:()=>i,toc:()=>o});var a=n(74848),r=n(28453);const i={pagination_prev:null,pagination_next:null},s="%Stream.DynamicBinary",o=[{value:"Methods",id:"methods",level:2},{value:"ReadLineIntoStream",id:"readlineintostream",level:3},{value:"OutputToDevice",id:"outputtodevice",level:3}];function c(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"streamdynamicbinary",children:"%Stream.DynamicBinary"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Class %Stream.DynamicBinary Extends %Stream.DynamicCharacter [ ClientDataType = BINARYSTREAM, OdbcType = LONGVARBINARY, System = 2 ]\n"})}),"\n",(0,a.jsx)(t.p,{children:"%Stream.DynamicBinary character stream containing the 8-bit binary bytes of an element of a %DynamicAbstractObject. It is particularly useful for holding the value of a %DynamicAbstractObject element with a byte stream value that would exceed the capacity of an ObjectScript string variable. A %Stream.DynamicBinary object is readonly and it cannot be modified or saved. But it can be copied to any other %Stream class object that does support modification and saving."}),"\n",(0,a.jsx)(t.p,{children:'One way to create a %Stream.DynamicBinary is by making a method call that looks like dao.%Get(key,default,"stream"), dao.%Get(key,default,"stream<base64") or dao.%Get(key,default,"stream>base64") where dao is an object reference to a subclass of %DynamicAbstractObject; and where key is the key name value of an element of a %DynamicObject or the index value of an element of a %DynamicArray. You can also get a %Stream.DynamicBinary object by calling the %GetNext(.key,.value,.type) method in one of subclasses of the %Iterator.AbstractIterator class.'}),"\n",(0,a.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(t.h3,{id:"readlineintostream",children:"ReadLineIntoStream"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method ReadLineIntoStream(ByRef sc As %Status) As %Stream.Object\n"})}),"\n",(0,a.jsx)(t.p,{children:"This reads from the stream until it finds the LineTerminator and returns a new %Stream.TmpCharacter stream containing the bytes in the line. If the stream does not contain the line terminator then this can potentially be the entire stream."}),"\n",(0,a.jsx)(t.h3,{id:"outputtodevice",children:"OutputToDevice"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-objectscript-class",children:"Method OutputToDevice(ByRef len As %Integer = -1) As %Status\n"})}),"\n",(0,a.jsx)(t.p,{children:"Write out len bytes of the stream to the current device starting from the current position. If len is omitted or set to -1 then the OutputToDevice method will write out the entire stream starting at the beginning and then rewind back to the beginning. If len > 0 and we are unable to write len bytes because we reach the end of the stream then we will stop writing and set the AtEnd property to 1. Otherwise, we will leave the stream positioned after the last byte written to the device. If parameter len is passed by reference and if no error occurs then the number of bytes actually written to the output device will be assigned to len. If zero bytes are written because we are already positioned at the end of the stream then len will be assigned to -1. If an error occurs while writing the device then len will be assigned to -2, an error %Status value will be returned and the stream will rollback to its original position."})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var a=n(96540);const r={},i=a.createContext(r);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);