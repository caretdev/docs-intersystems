"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[15405],{71499:(e,t,r)=>{r.r(t),r.d(t,{contentTitle:()=>i,default:()=>c,frontMatter:()=>n,toc:()=>a});var s=r(74848),o=r(28453);const n={pagination_prev:null,pagination_next:null},i="%SYSTEM.AbstractWorkMgr",a=[{value:"Properties",id:"properties",level:2},{value:"group",id:"group",level:3},{value:"DeleteTimeout",id:"deletetimeout",level:3},{value:"completed",id:"completed",level:3},{value:"suppressoutput",id:"suppressoutput",level:3},{value:"NumWorkers",id:"numworkers",level:3},{value:"NumActiveWorkers",id:"numactiveworkers",level:3},{value:"Methods",id:"methods",level:2},{value:"NumActiveWorkersGet",id:"numactiveworkersget",level:3},{value:"%OnNew",id:"onnew",level:3},{value:"%OnClose",id:"onclose",level:3},{value:"Initialize",id:"initialize",level:3},{value:"InitializeClass",id:"initializeclass",level:3},{value:"Setup",id:"setup",level:3},{value:"TearDown",id:"teardown",level:3},{value:"Cleanup",id:"cleanup",level:3},{value:"Clear",id:"clear",level:3},{value:"Sync",id:"sync",level:3},{value:"WaitForComplete",id:"waitforcomplete",level:3},{value:"Wait",id:"wait",level:3},{value:"WaitOne",id:"waitone",level:3},{value:"Help",id:"help",level:3}];function l(e){const t={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"systemabstractworkmgr",children:"%SYSTEM.AbstractWorkMgr"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Class %SYSTEM.AbstractWorkMgr Extends %SystemBase [ Abstract ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Implement some abstract interfaces for Work Queue Manager subclasses"}),"\n",(0,s.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,s.jsx)(t.h3,{id:"group",children:"group"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property group As %Integer [ Internal, MultiDimensional ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Group assocaited with this work."}),"\n",(0,s.jsx)(t.h3,{id:"deletetimeout",children:"DeleteTimeout"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property DeleteTimeout As %Integer [ InitialExpression = 1 ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"When the work queue oref is killed or goes out of scope this is the timeout we pass to the call the destructor makes to delete the work queue. The delete queue logic will wait for this timeout period for the worker/s to respond but if the worker/s is/are still busy it will force these processes down."}),"\n",(0,s.jsx)(t.h3,{id:"completed",children:"completed"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property completed As %Boolean [ InitialExpression = 0, Internal ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Internal property not to be set by user code."}),"\n",(0,s.jsx)(t.p,{children:"If true skip normal cancel work we will do for shard queue."}),"\n",(0,s.jsx)(t.h3,{id:"suppressoutput",children:"suppressoutput"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property suppressoutput As %Boolean [ Internal, Private ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"Disable output from worker jobs"}),"\n",(0,s.jsx)(t.h3,{id:"numworkers",children:"NumWorkers"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property NumWorkers As %Integer;\n"})}),"\n",(0,s.jsx)(t.p,{children:"For local WQM group after the work group is created the number of workers allocated to this group. Note this is the number of jobs we requested, not the number actively working for this group at this moment. The active number is NumActiveWorkers."}),"\n",(0,s.jsx)(t.h3,{id:"numactiveworkers",children:"NumActiveWorkers"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Property NumActiveWorkers As %Integer [ Calculated ];\n"})}),"\n",(0,s.jsx)(t.p,{children:"For local WQM groups number of active workers attached to this group. If the system is at the limit then we limit the number of worker jobs so you may need to wait for existing worker jobs to become free in order to attach to your work group. If queue is detached will return -1."}),"\n",(0,s.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(t.h3,{id:"numactiveworkersget",children:"NumActiveWorkersGet"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method NumActiveWorkersGet() As %Integer\n"})}),"\n",(0,s.jsx)(t.h3,{id:"onnew",children:"%OnNew"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %OnNew(ByRef qstruct As %String, numberjobs As %Integer, category, target) As %Status [ Private, ServerOnly = 1 ]\n"})}),"\n",(0,s.jsx)(t.p,{children:"Initialize the worker jobs so they are ready to start accepting work items. In the qspec that is passed you can determine if you want output with the 'd' flag. If you wish to disable multiple jobs and process the work in this parent process pass in numberjobs=0. This returns an instance of the worker queue manager which you can then queue work against. If you wish to specify how many workers you require then pass the numberjobs equal to the number you require."}),"\n",(0,s.jsx)(t.p,{children:"category allows you to specify the pool of workers this group should be taken from. Note that we qstruct to specify /multicompile is deprecated. The /multicompile qualifier is not used by the work queue manager and passing this qualifier into this class has no effect."}),"\n",(0,s.jsx)(t.h3,{id:"onclose",children:"%OnClose"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method %OnClose() As %Status [ Internal, Private ]\n"})}),"\n",(0,s.jsx)(t.h3,{id:"initialize",children:"Initialize"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'ClassMethod Initialize(qspec As %String = "", ByRef sc As %Status, numworkers As %Integer) As AbstractWorkMgr [ Deprecated ]\n'})}),"\n",(0,s.jsx)(t.p,{children:"Deprecated method implemented for compatibility with code used to calling 'Initialize' method but new users should call %New to create an instance of this class."}),"\n",(0,s.jsx)(t.h3,{id:"initializeclass",children:"InitializeClass"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'ClassMethod InitializeClass(iscname As %String, qspec As %String = "", ByRef sc As %Status, numworkers As %Integer) As AbstractWorkMgr [ Internal ]\n'})}),"\n",(0,s.jsx)(t.p,{children:"Internal method not for use"}),"\n",(0,s.jsx)(t.h3,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Setup(work As %String, args... As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"If you queue a large number of units of work and there is some common setup needed by any process that will run one of these units of work rather than having this setup work done for every work unit you can initalize the worker process once with this method, then it can process any number of work units in this group and when it is done it will run the TearDown. So if you call this method for a work group we will ensure this Setup entry point is called before the worker runs the first unit in this work group. This must be called before you queue any work and the arguments are the same as for the Queue."}),"\n",(0,s.jsx)(t.h3,{id:"teardown",children:"TearDown"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method TearDown(work As %String, args... As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"This is a companion method to Setup to restore a workers process to the previous state if setup work was done. The arguments are the same as for Queue. This must be called before you queue work."}),"\n",(0,s.jsx)(t.h3,{id:"cleanup",children:"Cleanup"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Cleanup(work As %String, args... As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Normally when a work group is deleted the delete/close is synchronous and so waits for all the worker jobs to finish or be terminated before it returns to the caller. This means the caller can be sure all work has finished and it can cleanup any temporary storage or resources the workers may have been using. This method allows you to specify a callback to be run when the work group is fully deleted which makes the delete/close of the work group asynchronous. So when the work group is deleted it can return immediately to the caller, but the caller can not assume all work has been terminated. Some of the workers may still be finishing their work or may be in the process of being terminated, however once the workers are stopped we will fully delete the work queue and run this 'Cleanup' callback. Note that this callback is not run in a worker that we have called Setup in."}),"\n",(0,s.jsx)(t.h3,{id:"clear",children:"Clear"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Clear(timeout As %Integer = 1) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"Clear any existing work from this work queue, it does this by removing the queue and creating a new one. This will wait for up to timeout seconds for the workers to finish their current task before killing the jobs. When we return from this function all work on the group has terminated so you can cleanup any temporary globals etc used by the workers."}),"\n",(0,s.jsx)(t.h3,{id:"sync",children:"Sync"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Sync(qspec As %String, errorlog As %String) As %Status\n"})}),"\n",(0,s.jsx)(t.p,{children:"After work has been queued this will wait for all the workers to complete. It will display any output the work writes to the current device and it will also combine all the %Status codes/exceptions that the units of work report and return this combined %Status. If the work queue is created with no workers then this will execute all the work in the current job during this phase. When this returns all the work queued up to this point has been completed (see Cleanup for an exception). This is the phase that will run the QueueCallback callbacks as the workers jobs report that work units are complete. In the function/method called in the QueueCallback callback you can reference the public variable '%workqueue' which is the oref pointing to the instance of the work queue class to allow additional work to be queued."}),"\n",(0,s.jsxs)(t.p,{children:["For information on qSpec, see ",(0,s.jsx)(t.a,{href:"/csp/docbook/DocBook.UI.Page.cls?FIND=ObjectScript+qspec",children:"System Flags and Qualifiers"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"waitforcomplete",children:"WaitForComplete"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method WaitForComplete(qspec As %String, errorlog As %String) As %Status [ CodeMode = call ]\n"})}),"\n",(0,s.jsxs)(t.p,{children:["For information on qSpec, see ",(0,s.jsx)(t.a,{href:"/csp/docbook/DocBook.UI.Page.cls?FIND=ObjectScript+qspec",children:"System Flags and Qualifiers"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"wait",children:"Wait"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method Wait(qspec As %String, ByRef atend As %Boolean, timeout As %Integer = -1) As %Status\n"})}),"\n",(0,s.jsxs)(t.p,{children:["After work has been queued you can call this to process some work completion events and then return to the caller where the caller will check the atend to see if all the work was processed and if not then you can call this method again to process additional items until atend is true. atend will be true for the first time when we have just received the last completion event for work that was queued.",(0,s.jsx)(t.br,{}),"\nThe conditions which control when it will return to the caller are controlled by timeout argument which has a default of -1:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Positive number : Return to the caller after one work complete event is received or after the specified number of seconds has elapsed."}),"\n",(0,s.jsx)(t.li,{children:"0 : Keep looking for work completion events until no completions are waiting, then return to the caller. Useful for polling to check if all work has been completed but then going to do some other work in this process."}),"\n",(0,s.jsx)(t.li,{children:"-1 : Requires a callback queued in QueueCallback. In the callback set the public variable %exit to 1 to make this 'Wait' call return to the caller. If the %exit is not set we will continue to wait for additoinal completion events until all have been received or until a callback sets %exit=1. This is the default\nIn the function/method called in the QueueCallback callback you can reference the public variable '%workqueue' which is the oref of the instance of the work queue class in order to queue additional work."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["For information on qSpec, see ",(0,s.jsx)(t.a,{href:"/csp/docbook/DocBook.UI.Page.cls?FIND=ObjectScript+qspec",children:"System Flags and Qualifiers"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"waitone",children:"WaitOne"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:"Method WaitOne(timeout As %Integer = 9999, ByRef worksc As %Status, ByRef workargs As %Binary, ByRef workresult As %Binary) As %Boolean\n"})}),"\n",(0,s.jsx)(t.p,{children:"Wait for one work unit to complete or we hit the timeout. This is useful when you want to respond to individual completeion events in the parent process or you want to handle work unit errors differently than WQM framework errors. If you only need to wait until all the work is completed then use the Sync. Any errors in the WQM framework will be thrown as an exception which the caller should 'catch', in normal operation this will not occur. The return value of the individual work unit or any errors thrown by running the work unit are returned in the byref worksc %Status variable. If a timeout happens then we indicate this in the worksc %Status variable as a error of $$$ERROR($$$MultiTimeout,timeout) error. You can check for this error code with 'If $$$ERRORISTYPE(sc,$$$MultiTimeout)'."}),"\n",(0,s.jsx)(t.p,{children:"If a work unit was run then the array workargs is the argument list passed to the work unit, the first argument will be in workargs(1) and the second argument will be in workargs(2) etc, so in the format when your function uses an 'workarg...' parameter. This provides context so you can understand any error or other information the work unit has set."}),"\n",(0,s.jsx)(t.p,{children:"When a work unit that is run sets result information into the public variable %result array this will be returned to the caller of WaitOne in the workresult byref array. The method returns '1' to indicate it has either got a completion event or a timeout has occurred and '0' to indicate all completions have already been processed. Any callback queued in QueueCallback are run in this method in the same way they are for Sync calls although when using WaitOne there is no need for the callback mechanism."}),"\n",(0,s.jsxs)(t.p,{children:["Example use of this method is the following code. Any errors in WQM framework will be throw but return values from work units are returned in the workargs byref value so they may be handled by the caller if wished. ",(0,s.jsx)(t.code,{children:'Set queue=$system.WorkMgr.%New() If queue="" ; Report Error, can check %objlasterror for %Status code For i=1:1:100 { Set sc=queue.Queue("##class(MyClass).ClassMethod",i) If $$$ISERR(sc) ; Report Error } While queue.WaitOne(10,.sc,.args,.result) { If $$$ISERR(sc) { If $$$ERRORISTYPE(sc,$$$MultiTimeout) { ; Handle a timeout } Else { ; Work unit returned %Status code or threw an expcetion, hanlde this here } } Else { Write "Completed work unit ",args(1),! ; As we have access to the argument list provided on the \'Queue\' Zwrite result ; Any %result data from the work unit } }'})]}),"\n",(0,s.jsx)(t.h3,{id:"help",children:"Help"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objectscript-class",children:'ClassMethod Help(method As %String = "") As %String\n'})}),"\n",(0,s.jsx)(t.p,{children:"Write out a list of the methods of this object to the console. Pass the method name as an argument to see the full description for this item."})]})}function c(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>a});var s=r(96540);const o={},n=s.createContext(o);function i(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);