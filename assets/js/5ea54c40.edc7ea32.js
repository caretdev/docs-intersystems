"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[7668],{94679:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>r,default:()=>o,frontMatter:()=>a,toc:()=>d});var i=t(74848),s=t(28453);const a={pagination_prev:null,pagination_next:null},r="%Library.FunctionalIndex",d=[{value:"Overview",id:"overview",level:2},{value:"Index Filing Interface",id:"index-filing-interface",level:2},{value:"Query Interface",id:"query-interface",level:2},{value:"Index Dictionary Metadata",id:"index-dictionary-metadata",level:2},{value:"Subvalue Indexing",id:"subvalue-indexing",level:2},{value:"Parameters",id:"parameters",level:2},{value:"SUPPORTSSHARDING",id:"supportssharding",level:3},{value:"Methods",id:"methods",level:2},{value:"InsertIndex",id:"insertindex",level:3},{value:"UpdateIndex",id:"updateindex",level:3},{value:"DeleteIndex",id:"deleteindex",level:3},{value:"PurgeIndex",id:"purgeindex",level:3},{value:"SortBeginIndex",id:"sortbeginindex",level:3},{value:"SortEndIndex",id:"sortendindex",level:3},{value:"SegmentInitialize",id:"segmentinitialize",level:3},{value:"SegmentInsert",id:"segmentinsert",level:3},{value:"SegmentFinalize",id:"segmentfinalize",level:3},{value:"Find",id:"find",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"libraryfunctionalindex",children:"%Library.FunctionalIndex"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"Class %Library.FunctionalIndex [ Abstract, ClassType = index, System = 2 ]\n"})}),"\n",(0,i.jsx)(n.h1,{id:"functional-indexing",children:"Functional Indexing"}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"An index is a structure maintained by a persistent class that is intended to be used to optimize certain queries and other functions. objects supports three primary types of indexes - regular, bitmap and key structures. The index type is defined by two index keywords, TYPE and EXTENT. It is also possible to declare a type class for an index. This index type class is expected to implement the index type class interface as defined by this class. The classtype of the index type class is expected to be INDEX."}),"\n",(0,i.jsx)(n.p,{children:"Functional Indexing is the feature in InterSystems IRIS Objects that allows a user to implement a class that maintains an index structure and a function that can be used by SQL to resolve certain SQL query operators. A Functional Index class must implement two interfaces. The first interface is the index filing interface, the second is the query interface used by SQL."}),"\n",(0,i.jsx)(n.h2,{id:"index-filing-interface",children:"Index Filing Interface"}),"\n",(0,i.jsxs)(n.p,{children:["The Index Filing Interface consists of six methods. The three methods that implement instance filing, InsertIndex, UpdateIndex, and DeleteIndex accept a formal argument corresponding to the ID of the object (ROWID of the row) being filed and a variable number of arguments corresponding to the indexed properties and clustered data properties. The UpdateIndex method accepts two sets of indexed properties as arguments, the first set corresponds to the new indexed property values and the second the existing set of indexed property values. All arguments other than the ID are accessed using the formal argument pArg with a subscript corresponding to the actual argument's position. For example, the following index: ",(0,i.jsx)(n.code,{children:"index x1F on (Name, DOB, Home_City) as User.MyIndexClass [ data=(Name,BirthPlace)];"})," will result in Name passed as pArg(1), DOB passed as pArg(2) and Home_City passed as pArg(3). For InsertIndex, the data values corresponding to Name and BirthPlace are passed as pArg(4) and pArg(5) respectively. Keep in mind that any index on a persistent class that is not final will cause the %%CLASSNAME property to be implicitly clustered as the first property. If that is the case in the above example, %%CLASSNAME becomes pArg(4) and the defined properties will be pArg(5) and pArg(6) respectively. For UpdateIndex, the arguments 4, 5, and 6 will correspond to the existing values of Name, DOB, and Home_City and the arguments 7, 8, and 9 correspond to %%CLASSNAME, Name and BirthPlace. All argument values are passed as uncollated values. It is the responsibility of the functional index class to properly collate the values."]}),"\n",(0,i.jsx)(n.p,{children:"Three additional methods are included in the Index Filing Interface. They are PurgeIndex, SortBeginIndex, and SortEndIndex."}),"\n",(0,i.jsx)(n.h2,{id:"query-interface",children:"Query Interface"}),"\n",(0,i.jsx)(n.p,{children:"The Query Interface consists of at least one method that is projected to SQL as a function. Arguments of this function should be limited to the set of index properties."}),"\n",(0,i.jsx)(n.h2,{id:"index-dictionary-metadata",children:"Index Dictionary Metadata"}),"\n",(0,i.jsx)(n.p,{children:"When implementing a functional index class it is sometimes necessary to access the compiled class dictionary metadata. The class compiler will not have generated a specific global location for the functional index. That is the responsibility of the functional index class. When you need a global location for a functional index the convention is to use the defined global location values from the storage definition but the details of exactly what global location will be used by the index are left to the functional index class."}),"\n",(0,i.jsx)(n.h2,{id:"subvalue-indexing",children:"Subvalue Indexing"}),"\n",(0,i.jsx)(n.p,{children:"Subvalue indexing occurs when an index property specification includes either (ELEMENTS) or (KEYS). These references trigger the filers to determine the set of subvalues, either by the fact that the property involved is a collection or there is a user-implemented BuildValueArray method. The filers then iterate over the subvalues and file the index. In the case of an update, the set of existing subvalues are first deleted from the index and the set of new subvalues is filed."}),"\n",(0,i.jsx)(n.p,{children:"Functional Indexes continue with this behavior with the index filing method simply performing the work needed to place one subvalue into the index. The Objects and SQL filers will continue to determine the set of subvalues, both existing and new, and call the Functional Index interface iteratively."}),"\n",(0,i.jsx)(n.p,{children:"When the index structure includes subvalues but there is no declaration in the index property specifications then it is entirely up to the Functional Index implementation to determine the set of subvalues and to provide the necessary subvalue iterators. The Objects and SQL filers will invoke the Functional Index filer with existing and new values as if the index is on the entire property value."}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(n.h3,{id:"supportssharding",children:"SUPPORTSSHARDING"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"Parameter SUPPORTSSHARDING = 0;\n"})}),"\n",(0,i.jsx)(n.p,{children:"This parameter can be set to 1 if the implementation of the filing interface and the SQL query interface can be executed on a shard server. The default is 0. If a sharded class attempts to use a functional index where SUPPORTSSHARDING = 0, a class compiler error will be returned."}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsx)(n.h3,{id:"insertindex",children:"InsertIndex"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod InsertIndex(pID As %RawString, pArg... As %Binary) [ CodeMode = generator, ServerOnly = 1 ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"This method is invoked when a new instance of a class is inserted into the database."}),"\n",(0,i.jsx)(n.h3,{id:"updateindex",children:"UpdateIndex"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod UpdateIndex(pID As %RawString, pArg... As %Binary) [ CodeMode = generator, ServerOnly = 1 ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"This method is invoked when an existing instance of a class is updated."}),"\n",(0,i.jsx)(n.h3,{id:"deleteindex",children:"DeleteIndex"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod DeleteIndex(pID As %RawString, pArg... As %Binary) [ CodeMode = generator, ServerOnly = 1 ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"This method is invoked when an existing instance of a class is deleted."}),"\n",(0,i.jsx)(n.h3,{id:"purgeindex",children:"PurgeIndex"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod PurgeIndex() [ CodeMode = generator, ServerOnly = 1 ]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"sortbeginindex",children:"SortBeginIndex"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod SortBeginIndex() [ CodeMode = generator, ServerOnly = 1 ]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"sortendindex",children:"SortEndIndex"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod SortEndIndex(pCommit As %Integer = 1) [ CodeMode = generator, ServerOnly = 1 ]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"segmentinitialize",children:"SegmentInitialize"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod SegmentInitialize(ByRef pIndexBuffer As %RawString, pStartID As %RawString, pEndID As %RawString)\n"})}),"\n",(0,i.jsx)(n.p,{children:"This method is called by the parallel index build to initialize an index segment when constructing index entries for one segment of the extent. Parallel index builds typically construct indexes in memory for segments of 64k instances/rows."}),"\n",(0,i.jsx)(n.h3,{id:"segmentinsert",children:"SegmentInsert"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod SegmentInsert(ByRef pIndexBuffer As %RawString, pID As %RawString, pArg... As %Binary) [ CodeMode = generator ]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"segmentfinalize",children:"SegmentFinalize"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod SegmentFinalize(ByRef pIndexBuffer As %RawString, pStartID As %RawString, pEndID As %RawString)\n"})}),"\n",(0,i.jsx)(n.p,{children:"This method is called when the index builder is finalizing a segment. Use this method to implement any segment cleanup work or to complete the filing of the segment. Parallel index builds typically construct segments of the index in memory and this method is a good place to copy temporary structures to the permanent index structure."}),"\n",(0,i.jsx)(n.h3,{id:"find",children:"Find"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-objectscript-class",children:"ClassMethod Find(pSearch As %Binary) As %Library.Binary [ CodeMode = generator, ServerOnly = 1, SqlProc ]\n"})})]})}function o(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var i=t(96540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);