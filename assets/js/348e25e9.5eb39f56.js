"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[14346],{80765:(e,s,t)=>{t.r(s),t.d(s,{contentTitle:()=>n,default:()=>c,frontMatter:()=>i,toc:()=>l});var a=t(74848),o=t(28453);const i={pagination_prev:null,pagination_next:null},n="%Projection.AbstractProjection",l=[{value:"Parameters",id:"parameters",level:2},{value:"DisableMulticompile",id:"disablemulticompile",level:3},{value:"Methods",id:"methods",level:2},{value:"CreateProjection",id:"createprojection",level:3},{value:"EndCompile",id:"endcompile",level:3},{value:"RemoveProjection",id:"removeprojection",level:3},{value:"QueueClass",id:"queueclass",level:3},{value:"RemoveFromQueue",id:"removefromqueue",level:3},{value:"SetQueueFlag",id:"setqueueflag",level:3},{value:"getDefaultParam",id:"getdefaultparam",level:3},{value:"getROOTDIR",id:"getrootdir",level:3},{value:"AddToManifest",id:"addtomanifest",level:3},{value:"RemoveFromManifest",id:"removefrommanifest",level:3}];function r(e){const s={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"projectionabstractprojection",children:"%Projection.AbstractProjection"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"Class %Projection.AbstractProjection Extends %Library.Base [ Abstract, System = 1 ]\n"})}),"\n",(0,a.jsxs)(s.p,{children:["This abstract class defines the Projection interface which is implemented by one of the various subclasses of this class.",(0,a.jsx)(s.br,{}),"\nA class definition may include one or more Projection definitions; each one of which refers to a specific Projection class (a subclass of this class). The Projection interface defines methods that are invoked by the Class Compiler at certain points within a class compilation. Specifically, there is a method, CreateProjection that is called when a class has been compiled, and another, RemoveProjection that is called when a class is about to be recompiled or deleted.",(0,a.jsx)(s.br,{}),"\nThe expected use of a Projection class is to provide a way to automatically generate associated files (such as those used by the Java Binding) whenever a class is compiled. If the projection creates globals or other items that need to be packaged with this class in the event we wish to move this class in a deployment package then add these items in the AddToManifest call."]}),"\n",(0,a.jsx)(s.h2,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsx)(s.h3,{id:"disablemulticompile",children:"DisableMulticompile"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"Parameter DisableMulticompile As BOOLEAN = 0;\n"})}),"\n",(0,a.jsx)(s.p,{children:"If true then do not create this projection using the class compiler multicompile jobs but create it in the main process. Used to allow projections that do not function in the multicompile environement to disable this feature."}),"\n",(0,a.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(s.h3,{id:"createprojection",children:"CreateProjection"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod CreateProjection(classname As %String, ByRef parameters As %String, modified As %String, qstruct) As %Status\n"})}),"\n",(0,a.jsxs)(s.p,{children:['This method is called by the Class Compiler whenever an associated class has finished compiling. classname contains the name of the associated class while parameters contains an array of the projection parameters subscripted by parameter name. Also the special parameter value parameters("%qstruct") contains a merge of the qstruct array this projection is being compiled with. The modified is always blank.',(0,a.jsx)(s.br,{}),"\nAny errors reported by this method are reported by the Class Compiler but do not effect class compilation in any way."]}),"\n",(0,a.jsx)(s.h3,{id:"endcompile",children:"EndCompile"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod EndCompile(qstruct) As %Status\n"})}),"\n",(0,a.jsx)(s.p,{children:"This is called as close to the end of the compile as possible so it can do cleanup work or more usefully it can avoid doing work multiple times. For example if class User.A would modify MyFile.txt normally in the CreateProjection method and class User.B would normally modify the same file when it is compiled and you compile both these classes together then you may end up generating MyFile.txt twice and so doing duplicate work. By changing this so CreateProjection just adds 'MyFile.txt' to the queue of things to be done and then processing this list in this method, making sure to only do each piece of work once, you can process the fully up to date state of User.A and User.B to create the correct MyFile.txt just once."}),"\n",(0,a.jsx)(s.p,{children:"Note that this method will be called just once per projection subclass, so CreateProjection may be called multiple times for each class with this projection type, but this method will only be called once at the end of the compile."}),"\n",(0,a.jsx)(s.h3,{id:"removeprojection",children:"RemoveProjection"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod RemoveProjection(classname As %String, ByRef parameters As %String, recompile As %Boolean, modified As %String, qstruct) As %Status\n"})}),"\n",(0,a.jsxs)(s.p,{children:['This method is called by the Class Compiler whenever an associated class is either a) about to be recompiled, or b) about to be deleted. classname contains the name of the associated class while parameters contains an array of the projection parameters subscripted by parameter name. Also the special parameter value parameters("%qstruct") contains a merge of the qstruct array this projection is being compiled with. recompile is true (1) if the associated class is about to be recompiled. The modified is always blank.',(0,a.jsx)(s.br,{}),"\nAny errors reported by this method are reported by the Class Compiler but do not effect class compilation in any way."]}),"\n",(0,a.jsx)(s.h3,{id:"queueclass",children:"QueueClass"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod QueueClass(classname)\n"})}),"\n",(0,a.jsxs)(s.p,{children:["This is a helper method for implementors of projection classes. This method provides a mechanism for to make sure additional classes are compiled. Typically these would be new classes created by the projection itself.",(0,a.jsx)(s.br,{}),"\nYou should not directly invoke the Class Compiler from a projection method, instead, invoke this method to request that the class classname be placed in a queue of classes that will be compiled at the end of the current compilation operation."]}),"\n",(0,a.jsx)(s.h3,{id:"removefromqueue",children:"RemoveFromQueue"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod RemoveFromQueue(classname)\n"})}),"\n",(0,a.jsx)(s.p,{children:"Can be called to remove a queued class from the queued class list created with QueueClass"}),"\n",(0,a.jsx)(s.h3,{id:"setqueueflag",children:"SetQueueFlag"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod SetQueueFlag(flag)\n"})}),"\n",(0,a.jsx)(s.h3,{id:"getdefaultparam",children:"getDefaultParam"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod getDefaultParam(parameters, type, paramname, default) As %String\n"})}),"\n",(0,a.jsx)(s.h3,{id:"getrootdir",children:"getROOTDIR"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod getROOTDIR(parameters, type) As %String\n"})}),"\n",(0,a.jsx)(s.h3,{id:"addtomanifest",children:"AddToManifest"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod AddToManifest(classname, item) As %Status\n"})}),"\n",(0,a.jsx)(s.p,{children:"Call this helper method to add a component to the class manifest. For example if the projection of a class creates ^gbl(classname) nodes that describe some data about the projected class then you should add 'gbl(\"classname\").gbl' to the manifest so if we create a deployment package of this class we will also include any items in the manifest automatically."}),"\n",(0,a.jsx)(s.h3,{id:"removefrommanifest",children:"RemoveFromManifest"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod RemoveFromManifest(classname, item) As %Status\n"})}),"\n",(0,a.jsx)(s.p,{children:"Called when you remove a projected item to remove this from the manifest."})]})}function c(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(r,{...e})}):r(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>n,x:()=>l});var a=t(96540);const o={},i=a.createContext(o);function n(e){const s=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:n(e.components),a.createElement(i.Provider,{value:s},e.children)}}}]);