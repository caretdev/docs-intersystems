"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[38543],{55739:(e,a,s)=>{s.r(a),s.d(a,{contentTitle:()=>c,default:()=>o,frontMatter:()=>r,toc:()=>i});var n=s(74848),t=s(28453);const r={pagination_prev:null,pagination_next:null},c="%XML.Schema",i=[{value:"Properties",id:"properties",level:2},{value:"DefaultNamespace",id:"defaultnamespace",level:3},{value:"IncludeDocumentation",id:"includedocumentation",level:3},{value:"AllowRedundantArrayName",id:"allowredundantarrayname",level:3},{value:"suppressDocumentation",id:"suppressdocumentation",level:3},{value:"Document",id:"document",level:3},{value:"Namespaces",id:"namespaces",level:3},{value:"NoNamespace",id:"nonamespace",level:3},{value:"NamespacePrefix",id:"namespaceprefix",level:3},{value:"schema",id:"schema",level:3},{value:"ServiceName",id:"servicename",level:3},{value:"namespaceIndices",id:"namespaceindices",level:3},{value:"namespaceElementQualified",id:"namespaceelementqualified",level:3},{value:"namespaceAttributeQualified",id:"namespaceattributequalified",level:3},{value:"namespaceEncoded",id:"namespaceencoded",level:3},{value:"namespaceSchema",id:"namespaceschema",level:3},{value:"namespaceImport",id:"namespaceimport",level:3},{value:"locations",id:"locations",level:3},{value:"Methods",id:"methods",level:2},{value:"NamespacePrefixSet",id:"namespaceprefixset",level:3},{value:"%OnNew",id:"onnew",level:3},{value:"%OnClose",id:"onclose",level:3},{value:"AddSchemaType",id:"addschematype",level:3},{value:"SchemaPair",id:"schemapair",level:3},{value:"SchemaSimpleType",id:"schemasimpletype",level:3},{value:"SchemaElement",id:"schemaelement",level:3},{value:"RefElement",id:"refelement",level:3},{value:"RefAttribute",id:"refattribute",level:3},{value:"AddAttributes",id:"addattributes",level:3},{value:"IsItemDefined",id:"isitemdefined",level:3},{value:"DefineNamespace",id:"definenamespace",level:3},{value:"DefineImport",id:"defineimport",level:3},{value:"GetSchema",id:"getschema",level:3},{value:"DefineLocation",id:"definelocation",level:3},{value:"DefineExtraImports",id:"defineextraimports",level:3},{value:"AddImports",id:"addimports",level:3},{value:"AddDatasetSchemaType",id:"adddatasetschematype",level:3},{value:"FixDocumentation",id:"fixdocumentation",level:3},{value:"PropertyAnnotation",id:"propertyannotation",level:3}];function l(e){const a={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.header,{children:(0,n.jsx)(a.h1,{id:"xmlschema",children:"%XML.Schema"})}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Class %XML.Schema Extends %RegisteredObject [ System = 3 ]\n"})}),"\n",(0,n.jsxs)(a.p,{children:["The %XML.Schema controls creation of an XML Schema from InterSystems IRIS. It generates a complete XML document that contains the schema including the <?xml> tag. XML types are added to the schema by using the AddSchemaType method. The schema is build up in an XML DOM by AddSchemaType and may later be output using %XML.Writer. The DocumentNode or Tree methods of the %XML.Writer class can be used to output the schema.",(0,n.jsx)(a.br,{}),"\nXML namespace handling is for the most part automatic. %XML.Schema adds namespaces for which %XML.Writer then automatically creates prefixes for the XML output as needed. The XML namespaces for which schemas are created are listed in the Namespaces property which is a list of strings. The GetSchema method is used to get the XML DOM node for a namespace's schema.",(0,n.jsx)(a.br,{}),"\nThe following example can be executed in the SAMPLES namespace.",(0,n.jsx)(a.br,{}),"\n",(0,n.jsx)(a.code,{children:'; Get %XML.Schema instance. set schema=##class(%XML.Schema).%New() set namespace="http://tempuri.org/ISC/Samples" set schema.DefaultNamespace=namespace ; Get %XML.Writer instance. set writer=##class(%XML.Writer).%New() set writer.Indent=1 do writer.AddSchemaNamespace() do writer.AddNamespace(namespace,"sample") ; Add Company. Note that referenced types are also added. set status=schema.AddSchemaType("Sample.Company") if $system.Status.IsError(status) do $system.Status.DisplayError(status) quit ; Add Vendor. set status=schema.AddSchemaType("Sample.Vendor") if $system.Status.IsError(status) do $system.Status.DisplayError(status) quit ; Verify that we have just our expected namespace. ; This is included for just for illustration. if (schema.Namespaces.Count()\'=1) || (schema.Namespaces.GetAt(1)\'=namespace) { write !,"Unexpected namespace found",! write !,"List Of Namespace: ",! for i=1:1:schema.Namespaces.Count() { write " ",schema.Namespaces.GetAt(i),! } write ! quit } ; Output the schema. set status=writer.DocumentNode(schema.GetSchema(namespace))'})," %XML.Schema automatically adds import elements to the generated schema. It is the responsibility of the user code to use the DefineLocation method to define the schemaLocation. See the following example of use DefineLocation for multiple namespaces: ",(0,n.jsx)(a.code,{children:'// className is the name of a class which references classes defined in // multiple namespaces. For example: className="test.A" in namespace "urn:testA", // test.A references test.B (in namespace "urn:testB") and test.C (in namespace "urn:testC"). try { #; get a schema writer set schemaWriter = ##class(%XML.Schema).%New() set sc = schemaWriter.AddSchemaType(className) if ($$$ISOK(sc)) { set namespaces = schemaWriter.Namespaces for i=1:1:namespaces.Count() { set ns=namespaces.GetAt(i) // set file path according to application dependent formula set locations(ns)="c:\\temp\\"_$piece(ns,":",2)_".xml" do schemaWriter.DefineLocation(ns,locations(ns)) } for i=1:1:namespaces.Count() { set ns=namespaces.GetAt(i) set schema = schemaWriter.GetSchema(ns) set writer = ##class(%XML.Writer).%New() do writer.OutputToFile(locations(ns)) set writer.Indent = 1 set sc=writer.DocumentNode(schema) If $$$ISERR(sc) do $system.OBJ.DisplayError(sc) Quit do writer.Reset() } } else { do $system.OBJ.DisplayError(sc) } } catch(tException) { do $system.OBJ.DisplayError(tException.AsStatus()) }'})]}),"\n",(0,n.jsx)(a.h2,{id:"properties",children:"Properties"}),"\n",(0,n.jsx)(a.h3,{id:"defaultnamespace",children:"DefaultNamespace"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property DefaultNamespace As %String;\n"})}),"\n",(0,n.jsx)(a.p,{children:"DefaultNamespace is the XML namespace to use for any classes that do not have the NAMESPACE parameter specified. If the NAMESPACE parameter is specified for a class, then the namespace specified in the class is always used."}),"\n",(0,n.jsx)(a.h3,{id:"includedocumentation",children:"IncludeDocumentation"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property IncludeDocumentation As %Boolean [ InitialExpression = 1 ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"If IncludeDocumentation is true, then the class and property comments are included in the schema as  elements. The default is to include the documentation."}),"\n",(0,n.jsx)(a.h3,{id:"allowredundantarrayname",children:"AllowRedundantArrayName"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property AllowRedundantArrayName As %Boolean;\n"})}),"\n",(0,n.jsx)(a.p,{children:"If AllowRedundantArrayName is true, then an array name that is used for an ObjectScript list or a pair type name that is used for an ObjectScript array will be allowed to have a type name = to the item name."}),"\n",(0,n.jsx)(a.p,{children:"The normal format of an array name for a List is ArrayOf. If =, then  is not appended unless AllowRedundantArrayName is true."}),"\n",(0,n.jsx)(a.p,{children:"The normal format of an array name for an Array is ArrayOfPairOf. If =, then  is not appended unless AllowRedundantArrayName is true."}),"\n",(0,n.jsx)(a.h3,{id:"suppressdocumentation",children:"suppressDocumentation"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property suppressDocumentation As %Boolean [ Internal, Private ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"suppressDocumentation is a one class only override of IncludeDocumentation."}),"\n",(0,n.jsx)(a.h3,{id:"document",children:"Document"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property Document As %XML.Document [ Internal ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"Document to hold the schemas that we are creating. The document consists of a root element that contains all the schemas as it's children. This property should not be set by the caller."}),"\n",(0,n.jsx)(a.h3,{id:"namespaces",children:"Namespaces"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property Namespaces As %ListOfDataTypes;\n"})}),"\n",(0,n.jsx)(a.p,{children:"List of referenced namespaces Namespaces = count of namespaces defined Namespaces(namespaceIndex)=namespace"}),"\n",(0,n.jsx)(a.h3,{id:"nonamespace",children:"NoNamespace"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property NoNamespace As %Boolean [ Internal ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"To suppress namespace handling in the schema, set NoNamespace=1. Used to support old XMLSchema method."}),"\n",(0,n.jsx)(a.h3,{id:"namespaceprefix",children:"NamespacePrefix"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property NamespacePrefix As %String [ Internal ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"If NoNamespace = true, then optional prefix to use for referenced XML types. Used to support old XMLSchema method."}),"\n",(0,n.jsx)(a.h3,{id:"schema",children:"schema"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property schema As %Integer [ Internal, Private ];\n"})}),"\n",(0,n.jsx)(a.p,{children:'List of XML elments and types defined for namespace. schema defines the portion of the global for this schema. ^||%xmlName(..schema,namespaceIndex,element,name)=$lb(class,encoded,input,summary) namespaceIndex = index for XML namespace index = order of definition within namespace element = true for element with inline complexType, false for complexType class = class name for "c" or "e", otherwise base type. name = name of XML type/element encoded = "e" for encoded or "" for literal input = 1 or 0 summary = 1 or 0'}),"\n",(0,n.jsx)(a.h3,{id:"servicename",children:"ServiceName"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property ServiceName As %String [ Internal ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"The SOAP service name for a web service with SOAPBINARY=1 specified."}),"\n",(0,n.jsx)(a.h3,{id:"namespaceindices",children:"namespaceIndices"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property namespaceIndices As %String [ Internal, MultiDimensional, Private ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"Index for each namespace. namespaceIndices(namespace)=namespaceIndex"}),"\n",(0,n.jsx)(a.h3,{id:"namespaceelementqualified",children:"namespaceElementQualified"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property namespaceElementQualified As %Boolean [ Internal, MultiDimensional, Private ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"Schema ElementQualified for each namespace. namespaceElementQualified(namespace)=ElementQualified"}),"\n",(0,n.jsx)(a.h3,{id:"namespaceattributequalified",children:"namespaceAttributeQualified"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property namespaceAttributeQualified As %Boolean [ Internal, MultiDimensional, Private ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"Schema AttributeQualified for each namespace. namespaceAttributeQualified(namespace)=AttributeQualified"}),"\n",(0,n.jsx)(a.h3,{id:"namespaceencoded",children:"namespaceEncoded"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property namespaceEncoded As %Integer [ Internal, MultiDimensional, Private ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"Schema encoded for each namespace. namespaceEncoded(namespace) = 1 for SOAP 1.1 encoded and 2 for SOAP 1.2 encoded"}),"\n",(0,n.jsx)(a.h3,{id:"namespaceschema",children:"namespaceSchema"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property namespaceSchema As %Integer [ Internal, MultiDimensional, Private ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"Schema node for each namespace. namespaceSchema(namespace)=schema node id"}),"\n",(0,n.jsx)(a.h3,{id:"namespaceimport",children:"namespaceImport"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property namespaceImport As %String [ Internal, MultiDimensional, Private ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"Namespaces which are imported by each namespace: namespaceImport(namespaceIndex,importNamespace)=location namespaceImport(namespaceIndex)=1 if the schema has already had import ele ments added."}),"\n",(0,n.jsx)(a.h3,{id:"locations",children:"locations"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Property locations As %String [ Internal, MultiDimensional, Private ];\n"})}),"\n",(0,n.jsx)(a.p,{children:"Location of import for each namespace: locations(importNamespace)=location"}),"\n",(0,n.jsx)(a.h2,{id:"methods",children:"Methods"}),"\n",(0,n.jsx)(a.h3,{id:"namespaceprefixset",children:"NamespacePrefixSet"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method NamespacePrefixSet(namespacePrefix As %String) As %Status [ Internal, ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.h3,{id:"onnew",children:"%OnNew"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method %OnNew(rootName As %String) As %Status [ ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Initialize schema index and schema document on constuction of object, rootName is the name used for the dummy root element in the schema document."}),"\n",(0,n.jsx)(a.h3,{id:"onclose",children:"%OnClose"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method %OnClose() As %Status [ ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.h3,{id:"addschematype",children:"AddSchemaType"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:'Method AddSchemaType(class As %String, top As %String = "", format As %String, summary As %Boolean = 0, input As %Boolean = 0, refOnly As %Boolean = 0) As %Status [ ServerOnly = 1 ]\n'})}),"\n",(0,n.jsxs)(a.p,{children:["Add a complexType to the schema. class is the name of the class which corresponds to the complexType.",(0,n.jsx)(a.br,{}),"\ntop is the optional override of the type name.",(0,n.jsx)(a.br,{}),'\nformat is the parameter formatting type ("literal", "encoded" or "encoded12") to be used for this object. In addition, the value "element" is the same as "literal" formatting with an element at the top level. The default value for format is "" which currently is the same as the "literal" formatting, but may be a unique encoding in the future.']}),"\n",(0,n.jsxs)(a.p,{children:["summary=true if summary type is to be created. input=true means that the schema for the input XML will be generated, otherwise the schema for the output XML will be generated. The default is input=false. Normally, this argument is not relevant since the all properties of a class participate in input and output.",(0,n.jsx)(a.br,{}),"\nrefOnly=true means that only the portions of the schema for referenced types are generated. The schema for this class is not generated. Default is refOnly=false that generates the entire schema."]}),"\n",(0,n.jsx)(a.h3,{id:"schemapair",children:"SchemaPair"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method SchemaPair(node, type, xsdtype, pairtype, choiceitem, bsummary, object, xmlkeyname, NotSummary, summaryTest, xmlsummary, membercat, namespace, classarray) As %Status [ Internal, Private, ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Define a pair type to be used for ObjectScript arrays"}),"\n",(0,n.jsx)(a.h3,{id:"schemasimpletype",children:"SchemaSimpleType"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method SchemaSimpleType(node, name, type, xsdtype, valuelist, facets) [ Internal, Private, ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Define a simpleType"}),"\n",(0,n.jsx)(a.h3,{id:"schemaelement",children:"SchemaElement"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method SchemaElement(node, class, type, property, xmlname, classxmlname, xsdtype, xmlkeyname, choiceitem, substitutiongroup, object, mixed, any, nillable, attributes, xmlsummary, bsummary, valuelist, facets, namespace, elementref, refnamespace, top, summary, ByRef classdata) As %Status [ Internal, Private, ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Define a property element"}),"\n",(0,n.jsx)(a.h3,{id:"refelement",children:"RefElement"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method RefElement(elementref As %Boolean, node As %XML.Node, refnamespace As %String, refname As %String, class As %String, attributes, ByRef status As %Status) As %Boolean [ Internal, Private, ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Introduce indirection of element to different namespace via ref attribute"}),"\n",(0,n.jsx)(a.h3,{id:"refattribute",children:"RefAttribute"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method RefAttribute(node As %XML.Node, refnamespace As %String, refname As %String, class As %String, ByRef status As %Status) As %Boolean [ Internal, Private, ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Introduce indirection of attribute to different namespace via ref attribute"}),"\n",(0,n.jsx)(a.h3,{id:"addattributes",children:"AddAttributes"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method AddAttributes(node As %XML.Node, attributes) [ Internal, Private, ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Add attributes expressed as list of 2 member lists: name and value"}),"\n",(0,n.jsx)(a.h3,{id:"isitemdefined",children:"IsItemDefined"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method IsItemDefined(ByRef namespace As %String, kind As %Integer, name As %String, class As %String, input As %Boolean, summary As %Boolean, ByRef status As %Status) As %Boolean [ Internal, Private, ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Return true if an element or complexType is already defined matching the arguments. If a match is found, then status indicates if a duplicate definition error is detected. kind is 0 for complexType, 1 for element, 2 for attribute"}),"\n",(0,n.jsx)(a.h3,{id:"definenamespace",children:"DefineNamespace"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method DefineNamespace(ByRef namespace As %String, class As %String, encoded As %Boolean, defaultElementQualified As %Boolean, defaultAttributeQualified As %Boolean) As %Status [ Internal, ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Define an XML namespace, if it is not already defined."}),"\n",(0,n.jsx)(a.h3,{id:"defineimport",children:"DefineImport"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method DefineImport(importNamespace As %String) [ Internal, Private, ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"DefineImport defines that a schema is imported by the current namespace's schema. The current schema is defined by the targetNamespace attribute of the schedma node of the node parameter. The namespace to be imported is defined by the importNamespace parameter."}),"\n",(0,n.jsx)(a.h3,{id:"getschema",children:"GetSchema"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method GetSchema(namespace As %String) As %XML.Node [ ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Get the node for the schema element that corresponds to the specified namespace."}),"\n",(0,n.jsx)(a.h3,{id:"definelocation",children:"DefineLocation"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method DefineLocation(namespace As %String, location As %String) [ ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Define the location for import elements for a schema"}),"\n",(0,n.jsx)(a.h3,{id:"defineextraimports",children:"DefineExtraImports"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method DefineExtraImports(namespace As %String, ByRef imports) [ ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Define any additional import elements for a schema The imports array is of the form imports(namespace)=location"}),"\n",(0,n.jsx)(a.h3,{id:"addimports",children:"AddImports"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method AddImports(node As %XML.Node, namespaceIndex As %Integer, encoded As %Integer) [ Internal, Private, ServerOnly = 1 ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Add the necessary import elements to a schema"}),"\n",(0,n.jsx)(a.h3,{id:"adddatasetschematype",children:"AddDatasetSchemaType"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:'Method AddDatasetSchemaType(class As %String, node As %XML.Node, top As %String = "", encoded As %Boolean, summary As %Boolean = 0, input As %Boolean = 0, refOnly As %Boolean = 0) As %Status [ Internal, ServerOnly = 1 ]\n'})}),"\n",(0,n.jsx)(a.p,{children:"Implementation of override of XMLSchemaType for %XML.Dataset."}),"\n",(0,n.jsx)(a.h3,{id:"fixdocumentation",children:"FixDocumentation"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"ClassMethod FixDocumentation(comment As %String) As %String [ Internal ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Fix up descriptions created from xs:documentation elements."}),"\n",(0,n.jsx)(a.h3,{id:"propertyannotation",children:"PropertyAnnotation"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-objectscript-class",children:"Method PropertyAnnotation(node As %XML.Node, property As %String, xmlname As %String) [ Internal ]\n"})}),"\n",(0,n.jsx)(a.p,{children:"Add property element to identify source of schema element."})]})}function o(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453:(e,a,s)=>{s.d(a,{R:()=>c,x:()=>i});var n=s(96540);const t={},r=n.createContext(t);function c(e){const a=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function i(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),n.createElement(r.Provider,{value:a},e.children)}}}]);