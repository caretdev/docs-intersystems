"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[2309],{5263:(e,s,t)=>{t.r(s),t.d(s,{contentTitle:()=>a,default:()=>c,frontMatter:()=>n,toc:()=>l});var r=t(74848),i=t(28453);const n={pagination_prev:null,pagination_next:null},a="%iKnow.Classification.Optimizer",l=[{value:"Properties",id:"properties",level:2},{value:"TaskId",id:"taskid",level:3},{value:"Debug",id:"debug",level:3},{value:"IsMaster",id:"ismaster",level:3},{value:"Verbose",id:"verbose",level:3},{value:"TestSet",id:"testset",level:3},{value:"MetadataField",id:"metadatafield",level:3},{value:"DomainId",id:"domainid",level:3},{value:"Builder",id:"builder",level:3},{value:"AddWindowSize",id:"addwindowsize",level:3},{value:"AddCount",id:"addcount",level:3},{value:"MinimalScoreIncrease",id:"minimalscoreincrease",level:3},{value:"ScoreMetric",id:"scoremetric",level:3},{value:"RemoveStepRatio",id:"removestepratio",level:3},{value:"RemoveCount",id:"removecount",level:3},{value:"MaximalScoreDecrease",id:"maximalscoredecrease",level:3},{value:"CurrentClassifier",id:"currentclassifier",level:3},{value:"CurrentScore",id:"currentscore",level:3},{value:"CurrentTestId",id:"currenttestid",level:3},{value:"CategoryWeights",id:"categoryweights",level:3},{value:"Methods",id:"methods",level:2},{value:"BuilderSet",id:"builderset",level:3},{value:"%OnNew",id:"onnew",level:3},{value:"LoadTermsSQL",id:"loadtermssql",level:3},{value:"LoadTermsArray",id:"loadtermsarray",level:3},{value:"Initialize",id:"initialize",level:3},{value:"Optimize",id:"optimize",level:3},{value:"RemoveTerms",id:"removeterms",level:3},{value:"AddTerms",id:"addterms",level:3},{value:"ClearTestInfo",id:"cleartestinfo",level:3},{value:"RankScores",id:"rankscores",level:3},{value:"GetScore",id:"getscore",level:3},{value:"RunTest",id:"runtest",level:3},{value:"TestTermAsync",id:"testtermasync",level:3},{value:"%OnClose",id:"onclose",level:3},{value:"Cleanup",id:"cleanup",level:3},{value:"SaveClassifier",id:"saveclassifier",level:3},{value:"Log",id:"log",level:3}];function o(e){const s={blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"iknowclassificationoptimizer",children:"%iKnow.Classification.Optimizer"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Class %iKnow.Classification.Optimizer Extends %RegisteredObject [ Deprecated, System = 4 ]\n"})}),"\n",(0,r.jsx)(s.p,{children:'This class automates selecting "appropriate" terms for a %iKnow.Classification.Builder. After pointing an Optimizer instance to the Builder object that needs optimization, use the LoadTermsArray and LoadTermsSQL methods to queue a large number of potentially interesting terms the Optimizer should test. Then invoke its Optimize method to let the Optimizer loop through the list of suggested terms automatically and add those terms having the highest positive impact on model accuracy (as measured according to ScoreMetric), removing terms that were already added to the model but turn out to have no significant positive impact on the model\'s accuracy.'}),"\n",(0,r.jsx)(s.p,{children:"See the individual property descriptions of their impact on the optimization process."}),"\n",(0,r.jsx)(s.h2,{id:"properties",children:"Properties"}),"\n",(0,r.jsx)(s.h3,{id:"taskid",children:"TaskId"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property TaskId As %Integer [ Internal, ReadOnly ];\n"})}),"\n",(0,r.jsx)(s.h3,{id:"debug",children:"Debug"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property Debug As %String [ Internal ];\n"})}),"\n",(0,r.jsx)(s.h3,{id:"ismaster",children:"IsMaster"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property IsMaster As %Boolean [ InitialExpression = 1, Internal ];\n"})}),"\n",(0,r.jsx)(s.h3,{id:"verbose",children:"Verbose"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property Verbose As %String [ InitialExpression = 0 ];\n"})}),"\n",(0,r.jsx)(s.p,{children:"If set to a boolean value, defines whether or not to write output to the current device during the Optimize method. If set to a string, it is treated as a global reference to which output needs to be written."}),"\n",(0,r.jsx)(s.h3,{id:"testset",children:"TestSet"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property TestSet As %iKnow.Filters.Filter;\n"})}),"\n",(0,r.jsx)(s.p,{children:"The test set to validate model accuracy increases/decreases against."}),"\n",(0,r.jsx)(s.h3,{id:"metadatafield",children:"MetadataField"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property MetadataField As %String;\n"})}),"\n",(0,r.jsx)(s.p,{children:"The metadata field containing the actual category values to compare predictions against. This assumes the value of the Builder's MetadataField property when registering an IKnowBuilder instance as Builder, if not set explicitly."}),"\n",(0,r.jsx)(s.h3,{id:"domainid",children:"DomainId"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property DomainId As %Integer;\n"})}),"\n",(0,r.jsx)(s.p,{children:"The domain using which the categorization model is being trained and tested. This assumes the value of the Builder's DomainId property when registering an IKnowBuilder instance as Builder, if not set explicitly."}),"\n",(0,r.jsx)(s.h3,{id:"builder",children:"Builder"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property Builder As %iKnow.Classification.Builder;\n"})}),"\n",(0,r.jsx)(s.p,{children:"The builder object to be optimized."}),"\n",(0,r.jsx)(s.h3,{id:"addwindowsize",children:"AddWindowSize"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property AddWindowSize As %Integer(MINVAL = 0) [ InitialExpression = 0 ];\n"})}),"\n",(0,r.jsx)(s.p,{children:"The number of terms to test in each round. If left at 0, this defaults to the number of cores the system has available, which should be most efficient."}),"\n",(0,r.jsx)(s.h3,{id:"addcount",children:"AddCount"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property AddCount As %Integer(MINVAL = 1) [ InitialExpression = 1 ];\n"})}),"\n",(0,r.jsx)(s.p,{children:"The number of terms to add during an AddTerms cycle. The top results according to RankScores will be added, as selected from the AddWindowSize terms tested in the cycle."}),"\n",(0,r.jsx)(s.h3,{id:"minimalscoreincrease",children:"MinimalScoreIncrease"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property MinimalScoreIncrease As %Double(MAXVAL = 100, MINVAL = -100) [ InitialExpression = 0.1 ];\n"})}),"\n",(0,r.jsx)(s.p,{children:"The minimal score increase % a term should ensure to be retained for further testing. If the score does not increase by at least this figure, it will be discarded from the list of terms to test. A value of 1 means the minimal score increase should be 1%"}),"\n",(0,r.jsx)(s.h3,{id:"scoremetric",children:"ScoreMetric"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:'Property ScoreMetric As %String(VALUELIST = ",MacroFmeasure,MacroPrecision,MacroRecall,MicroFmeasure,MicroPrecision,MicroRecall,WeightedPrecision,WeightedRecall,WeightedFmeasure") [ InitialExpression = "MacroFmeasure" ];\n'})}),"\n",(0,r.jsx)(s.p,{children:"The default accuracy metric to use for evaluating test results, as used by RankScores. If set to a 'Weighted*' value, the weights are retrieved from CategoryWeights."}),"\n",(0,r.jsx)(s.h3,{id:"removestepratio",children:"RemoveStepRatio"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property RemoveStepRatio As %Double(MAXVAL = 1, MINVAL = 0) [ InitialExpression = 0.1 ];\n"})}),"\n",(0,r.jsx)(s.p,{children:"The ratio of RemoveTerms cycles vs AddTerms cycles. This should be a value between 0 and 1 (inclusive)."}),"\n",(0,r.jsx)(s.p,{children:"Note: Remove cycles take significantly longer than add cycles"}),"\n",(0,r.jsx)(s.h3,{id:"removecount",children:"RemoveCount"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property RemoveCount As %Integer(MINVAL = 1) [ InitialExpression = 3 ];\n"})}),"\n",(0,r.jsx)(s.p,{children:'The number of terms to remove in a "remove" cycle. Setting this value > 1 assumes the terms deemed irrelevant (and scheduled to be removed) don\'t influence one another much and removing more in a single cycle will not worsen performance much more than the individual performance changes of each term removal alone.'}),"\n",(0,r.jsx)(s.h3,{id:"maximalscoredecrease",children:"MaximalScoreDecrease"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property MaximalScoreDecrease As %Double(MAXVAL = 100, MINVAL = -100) [ InitialExpression = 0.05 ];\n"})}),"\n",(0,r.jsx)(s.p,{children:"The maximal decrease in performance the optimizer should accept when trying to remove terms. If removing a term would imply a decrease larger than this figure, it will not be removed. A value of 1 means the maximal score decrease is 1%"}),"\n",(0,r.jsx)(s.h3,{id:"currentclassifier",children:"CurrentClassifier"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property CurrentClassifier As %String [ ReadOnly ];\n"})}),"\n",(0,r.jsx)(s.p,{children:'The class name of the current "best" classifier. This value is set during Optimize, or as part of the AddTerms and RemoveTerms methods.'}),"\n",(0,r.jsx)(s.h3,{id:"currentscore",children:"CurrentScore"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property CurrentScore As %Double [ ReadOnly ];\n"})}),"\n",(0,r.jsx)(s.p,{children:"The score of the current classifier. This value is updated by AddTerms and RemoveTerms."}),"\n",(0,r.jsx)(s.h3,{id:"currenttestid",children:"CurrentTestId"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property CurrentTestId As %Integer [ ReadOnly ];\n"})}),"\n",(0,r.jsx)(s.p,{children:"The key to %DeepSee.PMML.Utils.TempResult for the test results of CurrentClassifier."}),"\n",(0,r.jsx)(s.h3,{id:"categoryweights",children:"CategoryWeights"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Property CategoryWeights [ MultiDimensional ];\n"})}),"\n",(0,r.jsx)(s.p,{children:"If ScoreMetric is set to a 'Weighted*' value, the weights for each category are retrieved from this array, indexed by category name. If no category weight is set, it is assumed to be 0."}),"\n",(0,r.jsx)(s.p,{children:"Note: Weights don't need to add up to 1."}),"\n",(0,r.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(s.h3,{id:"builderset",children:"BuilderSet"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method BuilderSet(pBuilder As %iKnow.Classification.Builder) As %Status [ Internal, ServerOnly = 1 ]\n"})}),"\n",(0,r.jsx)(s.h3,{id:"onnew",children:"%OnNew"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method %OnNew(pTaskId As %Integer = 0, pMasterObject As %Boolean = 1) As %Status [ Private, ServerOnly = 1 ]\n"})}),"\n",(0,r.jsx)(s.h3,{id:"loadtermssql",children:"LoadTermsSQL"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method LoadTermsSQL(pSQL As %String) As %Status\n"})}),"\n",(0,r.jsx)(s.p,{children:'Loads a list of candidate terms based on a SQL query. The query should return a column named "term" containing the term\'s value and may return columns named "type", "negation" and "match" to configure the type, negation and count policy for each term being retrieved, respectively.'}),"\n",(0,r.jsx)(s.h3,{id:"loadtermsarray",children:"LoadTermsArray"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method LoadTermsArray(ByRef pTerms, pListIndex As %Integer = 0) As %Status\n"})}),"\n",(0,r.jsx)(s.p,{children:"Loads all terms from the supplied array. If pListIndex is non-zero, the term info is read from that index at each array position. If the term info itself is a list structure as well, it is interpreted as follows: pTerms(n) = $lb(term, type, negationpolicy, matchpolicy)"}),"\n",(0,r.jsx)(s.h3,{id:"initialize",children:"Initialize"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method Initialize() As %Status\n"})}),"\n",(0,r.jsx)(s.p,{children:"Initializes this Optimizer instance. This method is called automatically as part of Optimize"}),"\n",(0,r.jsx)(s.h3,{id:"optimize",children:"Optimize"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method Optimize(pMaxSteps As %Integer = 20) As %Status\n"})}),"\n",(0,r.jsx)(s.p,{children:"In at most pMaxSteps steps, the current Builder will be optimized by testing, one at a time, the terms added through LoadTermsSQL and LoadTermsArray, judging which term works best for each test window by the results of RankScores (see also AddTerms). Every (1/RemoveStepRatio) rounds, all terms in the dictionary so far will be tested for their contribution to the current model score and the lowest RemoveCount terms will be removed (see also RemoveTerms)."}),"\n",(0,r.jsx)(s.p,{children:"At the end of the optimization process, in addition to Builder being updated, CurrentClassifier will contain the class name of the last test class used to achieve the best result and pTestId will point to the test results for that class."}),"\n",(0,r.jsx)(s.h3,{id:"removeterms",children:"RemoveTerms"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method RemoveTerms(pCount As %Integer = -1) As %Status\n"})}),"\n",(0,r.jsx)(s.p,{children:"Test the impact of removing each term in the current model's TermDictionary individually. The pCount terms for which, after removing it, RankScores still returns the best score (which supposedly implies its contribution was minimial), will be removed from the TermDictionary, unless the decrease in performance surpasses MaximalScoreDecrease."}),"\n",(0,r.jsx)(s.p,{children:"If pCount < 0, it defaults to RemoveCount."}),"\n",(0,r.jsx)(s.h3,{id:"addterms",children:"AddTerms"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method AddTerms(pCount As %Integer = -1, Output pAtEnd As %Boolean = 0) As %Status\n"})}),"\n",(0,r.jsx)(s.p,{children:"This method does one round of processing, testing AddWindowSize candidate terms and selecting the best pCount terms according to RankScores, unless it wouldn't meet the MinimalScoreIncreas threshold."}),"\n",(0,r.jsx)(s.p,{children:"If pCount < 0, it defaults to RemoveCount."}),"\n",(0,r.jsx)(s.h3,{id:"cleartestinfo",children:"ClearTestInfo"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method ClearTestInfo(pJobNumber As %Integer, pDropTestResults As %Boolean = 1, pDropTestClass As %Boolean = 1) As %Status [ Private ]\n"})}),"\n",(0,r.jsx)(s.p,{children:"Clears internal and generated artifacts for one particular test."}),"\n",(0,r.jsx)(s.h3,{id:"rankscores",children:"RankScores"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method RankScores(ByRef pJobInfo, Output pRanked, Output pNoScore) As %Status [ Private ]\n"})}),"\n",(0,r.jsx)(s.p,{children:'This method ranks the test results in pJobInfo according to the desired "score". By default, it will just look at the value of the metric identified by ScoreMetric, but this method can be overridden to calculate in more detail. When this method returns, pRanked is an ordered array containing the job IDs and score in ASCENDING order (pRanked(1) is the worst job):'}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:"pRanked([position]) = $lb([jobID], [score])"}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["pJobInfo should contain the following information:",(0,r.jsx)(s.br,{}),'\npJobInfo([jobID], "scores", [metric]) = [value]',(0,r.jsx)(s.br,{}),'\npJobInfo([jobID], "testid") = [test ID] (key for %DeepSee.PMML.Utils.TempResults)',(0,r.jsx)(s.br,{}),'\npJobInfo([jobID], "term") = [term ID] (not for initial evaluation)']}),"\n",(0,r.jsx)(s.p,{children:"See also GetScore"}),"\n",(0,r.jsx)(s.h3,{id:"getscore",children:"GetScore"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:'Method GetScore(ByRef pScores, pTestId As %Integer = "") As %Double [ Internal ]\n'})}),"\n",(0,r.jsx)(s.p,{children:"See also RankScores"}),"\n",(0,r.jsx)(s.h3,{id:"runtest",children:"RunTest"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method RunTest(Output pTestId As %Integer, Output pScores, Output pTestClassName As %String, pDropTestClass As %Boolean = 1, pTracking As %Boolean = 0) As %Status [ Internal ]\n"})}),"\n",(0,r.jsx)(s.p,{children:"Runs one test for the current state of Builder and returns its test scores."}),"\n",(0,r.jsx)(s.h3,{id:"testtermasync",children:"TestTermAsync"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod TestTermAsync(pTaskID As %Integer, pJobNumber As %Integer, pDebug As %String = "") As %Status [ Internal ]\n'})}),"\n",(0,r.jsx)(s.p,{children:"Tests the effect of adding/removing a single term and stores the test results in a temporary global."}),"\n",(0,r.jsx)(s.h3,{id:"onclose",children:"%OnClose"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method %OnClose() As %Status [ Private, ServerOnly = 1 ]\n"})}),"\n",(0,r.jsx)(s.h3,{id:"cleanup",children:"Cleanup"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method Cleanup() As %Status\n"})}),"\n",(0,r.jsx)(s.p,{children:"This method clears the temporary artifacts the optimizer has created while optimizing, such as the CurrentClassifier class and CurrentTestId test results."}),"\n",(0,r.jsx)(s.h3,{id:"saveclassifier",children:"SaveClassifier"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method SaveClassifier(pClassName As %String, pOverwrite As %Boolean = 0) As %Status\n"})}),"\n",(0,r.jsx)(s.p,{children:"Saves the CurrentClassifier class to the desired pClassName, so it will not be removed after this Optimizer instance is dropped. If CurrentClassifier is not set or if the class no longer exists for other reasons, the current builder object will create a classifier class based on its current state."}),"\n",(0,r.jsx)(s.h3,{id:"log",children:"Log"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-objectscript-class",children:"Method Log(pMessage As %String, pNewLines = 1) [ Private ]\n"})})]})}function c(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>l});var r=t(96540);const i={},n=r.createContext(i);function a(e){const s=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(n.Provider,{value:s},e.children)}}}]);