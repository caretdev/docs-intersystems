"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[25860],{13601:(e,t,s)=>{s.r(t),s.d(t,{contentTitle:()=>o,default:()=>c,frontMatter:()=>a,toc:()=>l});var n=s(74848),r=s(28453);const a={pagination_prev:null,pagination_next:null},o="%ML.FeatureGetter",l=[{value:"Methods",id:"methods",level:2},{value:"GetInfo",id:"getinfo",level:3},{value:"Reset",id:"reset",level:3}];function i(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"mlfeaturegetter",children:"%ML.FeatureGetter"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-objectscript-class",children:"Class %ML.FeatureGetter Extends FT.FeatureGetter [ Language = objectscript ]\n"})}),"\n",(0,n.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,n.jsx)(t.h3,{id:"getinfo",children:"GetInfo"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod GetInfo() As %List [ Internal ]\n"})}),"\n",(0,n.jsx)(t.p,{children:"Returns a $LIST of key-value pairs for a feature Where each key-value pair has the format $LISTBUILD(key,value,type)"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"where type=0 if value is a STRING in which case we keep the most recent value,"}),"\n",(0,n.jsx)(t.li,{children:"where type=1 if value is a BOOLEAN value {0 or 1} in which case we OR with previous values,"}),"\n",(0,n.jsx)(t.li,{children:"where type=2 if value is a SUM number in which case we do a summation with previous values, and"}),"\n",(0,n.jsx)(t.li,{children:"where type=3 if value is a MAX number in which case we keep maximum value of the current and previous values."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["The method may be supplied by a ",(0,n.jsx)(t.strong,{children:"FT.FeatureGetter"})," subclass. It is called by the Feature Tracker Collector about once per hour in order to collect the Feature values that might change over time. Therefore, in case of crash of the InterSystems IRIS instance we will lose no more than one hour of Feature Tracker information."]}),"\n",(0,n.jsxs)(t.p,{children:["This method is also called immediately after a call on the ",(0,n.jsx)(t.strong,{children:"GetBegin"})," method and just before a call on the ",(0,n.jsx)(t.strong,{children:"GetEnd"})," method."]}),"\n",(0,n.jsx)(t.h3,{id:"reset",children:"Reset"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Reset() As %Status [ Internal ]\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The class method ",(0,n.jsx)(t.strong,{children:"Reset"})," is called whenever Feature Collection desires a ",(0,n.jsx)(t.strong,{children:"FT.FeatureGetter"})," object to reinitialize its tracker state and to start collecting feature information as if no previous information had been collected. After all the ",(0,n.jsx)(t.strong,{children:"Reset"})," methods have been called then the local client data base of previous Feature Tracker keys and values will be killed. The kill of the local client data base is immediately followed by a call to the ",(0,n.jsx)(t.strong,{children:"GetBegin"})," method and then calls to the ",(0,n.jsx)(t.strong,{children:"GetInfo"})," method will immediately begin and will be made during every following hour. These method calls will repopulate the client data base of feature key-value pairs."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.strong,{children:"Reset"})," method must be supplied by the ",(0,n.jsx)(t.strong,{children:"FT.FeatureGetter"})," subclass if any of the Feature keys defined by the subclass need to be reset to their initial states after the previous Feature Tracker values were sent home to the InterSystems server. ",(0,n.jsx)(t.strong,{children:"Reset"})," is called after each successful transfer of Feature information to the InterSystems server. This occurs about once per week."]}),"\n",(0,n.jsxs)(t.p,{children:["Any ",(0,n.jsx)(t.strong,{children:"FT.FeatureGetter"})," object that just produces a type=0 string of configuration information and which does not need its internal state to be reset can avoid overriding the ",(0,n.jsx)(t.strong,{children:"Reset"})," class method and can instead default to using the ",(0,n.jsx)(t.strong,{children:"Reset"})," class method from the abstract ",(0,n.jsx)(t.strong,{children:"FT.FeatureGetter"})," class."]}),"\n",(0,n.jsxs)(t.p,{children:["A call on a ",(0,n.jsx)(t.strong,{children:"Reset()"})," class method returns a ",(0,n.jsx)(t.strong,{children:"%Status"})," value. This return status should contain an error value if the ",(0,n.jsx)(t.strong,{children:"FT.FeatureGetter"})," object needs to reset its internal collection state but the ",(0,n.jsx)(t.strong,{children:"Reset"})," method discovers that it is unable to do so."]})]})}function c(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(i,{...e})}):i(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>l});var n=s(96540);const r={},a=n.createContext(r);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);