"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[67842],{33624:(e,t,o)=>{o.r(t),o.d(t,{contentTitle:()=>i,default:()=>l,frontMatter:()=>r,toc:()=>c});var n=o(74848),s=o(28453);const r={pagination_prev:null,pagination_next:null},i="%OAuth2.Server.Revoke",c=[{value:"Methods",id:"methods",level:2},{value:"OnRevokeAccessToken",id:"onrevokeaccesstoken",level:3},{value:"OnLogoutAccessToken",id:"onlogoutaccesstoken",level:3}];function a(e){const t={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"oauth2serverrevoke",children:"%OAuth2.Server.Revoke"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-objectscript-class",children:"Class %OAuth2.Server.Revoke Extends %RegisteredObject [ System = 4 ]\n"})}),"\n",(0,n.jsxs)(t.p,{children:["%OAuth2.Server.Revoke is the default RevokeTokenClass which is included with the server. The default class will pass through, with no side effects upon token revocation.",(0,n.jsx)(t.br,{}),"\nThe RevokeTokenClass is specified in the Authorization Server Configuration. The OnRevokeAccessToken can perform user-specific operations upon token revocation, optionally bypassing the regular revocation flow.",(0,n.jsx)(t.br,{}),"\nThe OnLogoutAccessToken method can perform user-specific operations during RP-Initiated Front-Channel Logout."]}),"\n",(0,n.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,n.jsx)(t.h3,{id:"onrevokeaccesstoken",children:"OnRevokeAccessToken"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod OnRevokeAccessToken(authCode As %String, Output sc As %Status) As %Boolean\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The OnRevokeAccessToken method must return a boolean value or throw an error.",(0,n.jsx)(t.br,{}),"\nIf the method returns 1 or throws an error, the regular revocation flow is bypassed.",(0,n.jsx)(t.br,{}),"\nIf the method returns 0, the regular revocation flow continues.",(0,n.jsx)(t.br,{}),"\nDefault behavior is to permit regular revocation flow.",(0,n.jsx)(t.br,{}),"\nReceives the AuthorizationCode property value of the token to be deleted."]}),"\n",(0,n.jsx)(t.h3,{id:"onlogoutaccesstoken",children:"OnLogoutAccessToken"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod OnLogoutAccessToken(authCode As %String, properties As %OAuth2.Server.Properties, ByRef redirectURI As %String, Output sc As %Status) As %Boolean\n"})}),"\n",(0,n.jsx)(t.p,{children:"The OnLogoutAccessToken method is called during the RP-Initiated Front-Channel Logout flow. If this returns an error status (or throws an exception), then the normal flow will be bypassed. If it returns 1 the server will skip deleting the token and ending the session (if one exists,) but the normal redirect flow will still take place. The client's redirect URI is passed in the redirectURI parameter. This can be modified by the callback to redirect to another URI; this can be useful if authorization has been delegated to a third-party authorization server. If this callback modifies redirectURI, the new target should redirect to the original URI upon successful completion of the request."})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},28453:(e,t,o)=>{o.d(t,{R:()=>i,x:()=>c});var n=o(96540);const s={},r=n.createContext(s);function i(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);