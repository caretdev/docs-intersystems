"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[99377],{73423:(e,s,t)=>{t.r(s),t.d(s,{contentTitle:()=>i,default:()=>c,frontMatter:()=>r,toc:()=>l});var a=t(74848),n=t(28453);const r={pagination_prev:null,pagination_next:null},i="Config.MapRoutines",l=[{value:"Parameters",id:"parameters",level:2},{value:"EMSSERVICE",id:"emsservice",level:3},{value:"Properties",id:"properties",level:2},{value:"Database",id:"database",level:3},{value:"Methods",id:"methods",level:2},{value:"DatabaseSet",id:"databaseset",level:3},{value:"NameSet",id:"nameset",level:3},{value:"CheckRoutineMapOverlap",id:"checkroutinemapoverlap",level:3},{value:"CreateCallBack",id:"createcallback",level:3},{value:"%OnValidateObject",id:"onvalidateobject",level:3},{value:"ListExecute",id:"listexecute",level:3},{value:"ListFetch",id:"listfetch",level:3},{value:"ListClose",id:"listclose",level:3},{value:"ListMapEditsExecute",id:"listmapeditsexecute",level:3},{value:"ListMapEditsClose",id:"listmapeditsclose",level:3},{value:"ListMapEditsFetch",id:"listmapeditsfetch",level:3},{value:"GetAllMappings",id:"getallmappings",level:3}];function o(e){const s={br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"configmaproutines",children:"Config.MapRoutines"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"Class Config.MapRoutines Extends (%Persistent, Config.CommonMapMethods, Config.CommonMapProperties, %SYSTEM.Help) [ Final, Inheritance = right, System = 4 ]\n"})}),"\n",(0,a.jsxs)(s.p,{children:["This class allows you to modify and view routine mappings in the [Map.xxx] section of the CPF file through programatic APIs. While properties are usually modified through the System Management portal, there may be some occasion where modifying them through the API's is best for your system. In all the Config methods, if you do not specify the CPFFile parameter, the currently active CPF file is used. If you wish to modify a CPF file which is not the currently active one, then specify the CPFFile you wish to modify in the method call.",(0,a.jsx)(s.br,{}),"\nThe Flags parameter does not normally need to be specified; the defaults are usually sufficient for most cases.",(0,a.jsx)(s.br,{}),"\nYou can use either the provided API's (Create/Get/Modify/Delete) to modify the properties by passing in the correct parameters, or use Object syntax to open and directly manipulate the config objects (Open() and Exists()). Most objects created here need only to specify the Name of the object, and 1 or 2 properties since the the defaults are what are commonly used for most cases."]}),"\n",(0,a.jsx)(s.p,{children:"EXAMPLE:"}),"\n",(0,a.jsxs)(s.p,{children:['; Use class methods to create a routine mapping in namespace USER to the SAMPLES database %SYS>s Namespace="USER" %SYS>s Name="ROUTINEA" %SYS>s Properties("Database")="SAMPLES" %SYS>s Status=##Class(Config.MapRoutines).Create(Namespace,Name,.Properties) %SYS>i \'Status w !,"Error="',(0,a.jsx)(s.em,{children:'$SYSTEM.Status.GetErrorText(Status) ; Use class methods to modify properties %SYS>s Status=##Class(Config.MapRoutines).Get(Namespace,Name,.Properties) %SYS>i \'Status w !,"Error="'}),'$SYSTEM.Status.GetErrorText(Status) %SYS>zw Properties Properties("Database")="SAMPLES" %SYS>s Properties("Database")="TEST" %SYS>s Status=##Class(Config.MapRoutines).Modify(Namespace,Name,.Properties) %SYS>i \'Status w !,"Error="',(0,a.jsx)(s.em,{children:'$SYSTEM.Status.GetErrorText(Status) ; Now use Objects to modify properties %SYS>s Obj=##Class(Config.MapRoutines).Open(Namespace,Name) ; We could have used i ##Class(Config.MapRoutines).Exists(Namespace,Name,.Obj) instead of Open() %SYS>w Obj.Database TEST %SYS>s Obj.Database="SAMPLES" %SYS>s Status=Obj.%Save() %SYS>i \'Status w !,"Error="'}),'$SYSTEM.Status.GetErrorText(Status) ; Now delete the object we just created %SYS>s Status=##Class(Config.MapRoutines).Delete(Namespace,Name) %SYS>i \'Status w !,"Error="_$SYSTEM.Status.GetErrorText(Status)']}),"\n",(0,a.jsx)(s.h2,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsx)(s.h3,{id:"emsservice",children:"EMSSERVICE"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'Parameter EMSSERVICE [ Internal ] = "Namespace";\n'})}),"\n",(0,a.jsx)(s.h2,{id:"properties",children:"Properties"}),"\n",(0,a.jsx)(s.h3,{id:"database",children:"Database"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"Property Database As %String(MAXLEN = 64, MINLEN = 1) [ Required ];\n"})}),"\n",(0,a.jsx)(s.p,{children:"Database to map routine to."}),"\n",(0,a.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(s.h3,{id:"databaseset",children:"DatabaseSet"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"Method DatabaseSet(Val) As %Status [ Internal ]\n"})}),"\n",(0,a.jsx)(s.p,{children:"Force the Database name to be uppercase."}),"\n",(0,a.jsx)(s.h3,{id:"nameset",children:"NameSet"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"Method NameSet(Val) As %Status [ Internal ]\n"})}),"\n",(0,a.jsx)(s.p,{children:"Force the Routine type to be uppercase."}),"\n",(0,a.jsx)(s.h3,{id:"checkroutinemapoverlap",children:"CheckRoutineMapOverlap"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod CheckRoutineMapOverlap(Namespace As %String, Entry As %String = "", CPFFile As %String = "", Flags As %Integer = 0) As %Status [ Internal ]\n'})}),"\n",(0,a.jsx)(s.p,{children:"Check whether the input Routine Mapping entry could cause overlap in the current configuration."}),"\n",(0,a.jsxs)(s.p,{children:["Parameters:",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"Namespace"})," - Namespace of the routine mapping to be checked.",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"Entry"})," - a Routine mapping entry to be checked before it is added to the configuration.",(0,a.jsx)(s.br,{}),'\n"" - Check all routine mapping in the namespace.',(0,a.jsx)(s.br,{}),"\nRoutineMapping) - Check the specific Routine Mappig entry to be added to the configuration.",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"CPFFile"})," - Name of the CPF file to use. A null string means use the active CPF file."]}),"\n",(0,a.jsx)(s.p,{children:"Returns true if there is no mapping overlap. Otherwise return false with error informtion."}),"\n",(0,a.jsx)(s.h3,{id:"createcallback",children:"CreateCallBack"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod CreateCallBack(Obj As %ObjectHandle, Data As %String) As %Status [ Internal ]\n"})}),"\n",(0,a.jsx)(s.p,{children:"Called by the Create method during import from a CPF file."}),"\n",(0,a.jsx)(s.h3,{id:"onvalidateobject",children:"%OnValidateObject"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"Method %OnValidateObject() As %Status [ Internal ]\n"})}),"\n",(0,a.jsxs)(s.p,{children:["This method is called from %Save().",(0,a.jsx)(s.br,{}),"\nAny error returned here will cause the object not to be saved."]}),"\n",(0,a.jsx)(s.h3,{id:"listexecute",children:"ListExecute"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod ListExecute(ByRef %qHandle As %Binary, Namespace As %String, Names As %String = "*", CPFFile As %String = "", Flags As %Integer = 0) As %Status [ Internal ]\n'})}),"\n",(0,a.jsx)(s.p,{children:"List MapRoutines in a CPF file."}),"\n",(0,a.jsxs)(s.p,{children:["Parameters:",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"Names"})," - Comma separated list of MapRoutine names",(0,a.jsx)(s.br,{}),'\n"*" - All records match',(0,a.jsx)(s.br,{}),'\n"String,String1" - Any records matching one of these elements',(0,a.jsx)(s.br,{}),'\n"String*" - Any record starting with "String"',(0,a.jsx)(s.br,{}),'\n"String,String1*,String2" - Any record matching one of these elements, or starting with "String1"',(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"CPFFile"})," - Name of the CPF file to use. A null string means use the active CPF file.",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"Flags"})," - Currently ignored.",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"Format"}),(0,a.jsx)(s.br,{}),"\n0 - Standard report list format",(0,a.jsx)(s.br,{}),"\n1 - ^CONFIG global format",(0,a.jsx)(s.br,{}),"\n2 - CPF file format format",(0,a.jsx)(s.br,{}),"\nNote: This query may change in future versions"]}),"\n",(0,a.jsx)(s.h3,{id:"listfetch",children:"ListFetch"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ListFetch(ByRef %qHandle As %Binary, ByRef Row As %List, ByRef AtEnd As %Integer = 0) As %Status [ Internal, PlaceAfter = ListExecute ]\n"})}),"\n",(0,a.jsx)(s.h3,{id:"listclose",children:"ListClose"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ListClose(ByRef %qHandle As %Binary) As %Status [ Internal, PlaceAfter = ListExecute ]\n"})}),"\n",(0,a.jsx)(s.h3,{id:"listmapeditsexecute",children:"ListMapEditsExecute"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ListMapEditsExecute(ByRef qHandle As %Binary, Namespace As %String) As %Status\n"})}),"\n",(0,a.jsx)(s.p,{children:"List entries in CPFMappingEdit temporary storage"}),"\n",(0,a.jsx)(s.h3,{id:"listmapeditsclose",children:"ListMapEditsClose"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ListMapEditsClose(ByRef qHandle As %Binary) As %Status [ PlaceAfter = ListEditsExecute ]\n"})}),"\n",(0,a.jsx)(s.h3,{id:"listmapeditsfetch",children:"ListMapEditsFetch"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ListMapEditsFetch(ByRef qHandle As %Binary, ByRef Row As %List, ByRef AtEnd As %Integer = 0) As %Status [ PlaceAfter = ListEditsExecute ]\n"})}),"\n",(0,a.jsx)(s.h3,{id:"getallmappings",children:"GetAllMappings"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod GetAllMappings(Namespace As %String, ByRef Mappings, CPFFile As %String = "", Flags As %Integer = 0) As %Status [ Internal ]\n'})}),"\n",(0,a.jsx)(s.p,{children:"Get all routine mappings for a specified namespace, including %ALL mappings. Used to determine mappings which need to be propagated to shards."}),"\n",(0,a.jsxs)(s.p,{children:["Parameters:",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"Namespace"})," - Namespace whose mappings are returned.",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"Mappings"}),' - Returns mapped routine names by reference, as array subscripted by routine name, with value set to "%ALL" if routine name was mapped in %ALL, else with value set to specified Namespace.',(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"CPFFile"})," - Name of the CPF file to use. A null string means use the active CPF file.",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"Flags"})," - Can optionally specify $$$CPFImport to import CPF file into a special global."]}),"\n",(0,a.jsx)(s.p,{children:"Returns status."})]})}function c(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>i,x:()=>l});var a=t(96540);const n={},r=a.createContext(n);function i(e){const s=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(r.Provider,{value:s},e.children)}}}]);