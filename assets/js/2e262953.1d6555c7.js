"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[90723],{9955:(e,s,t)=>{t.r(s),t.d(s,{contentTitle:()=>a,default:()=>o,frontMatter:()=>i,toc:()=>l});var n=t(74848),r=t(28453);const i={pagination_prev:null,pagination_next:null},a="%DeepSee.Query.Engine",l=[{value:"Parameters",id:"parameters",level:2},{value:"MAXLISTING",id:"maxlisting",level:3},{value:"Methods",id:"methods",level:2},{value:"%PurgeBuckets",id:"purgebuckets",level:3},{value:"%GetBucketList",id:"getbucketlist",level:3},{value:"%InvalidateBuckets",id:"invalidatebuckets",level:3},{value:"%CubeRemoved",id:"cuberemoved",level:3},{value:"%ClearCache",id:"clearcache",level:3},{value:"%ExecuteForBucket",id:"executeforbucket",level:3},{value:"%Consolidate",id:"consolidate",level:3},{value:"%ComputeExpressions",id:"computeexpressions",level:3},{value:"%ResolveComputations",id:"resolvecomputations",level:3},{value:"%ComputeCellWeight",id:"computecellweight",level:3},{value:"%UpdatePendingResults",id:"updatependingresults",level:3},{value:"%ComputeTupleForCell",id:"computetupleforcell",level:3},{value:"%GetSpecForAxisNode",id:"getspecforaxisnode",level:3},{value:"CombineSetAndTerms",id:"combinesetandterms",level:3},{value:"%GetDescendantNodes",id:"getdescendantnodes",level:3},{value:"%FindRelativeNode",id:"findrelativenode",level:3},{value:"%AggregateStart",id:"aggregatestart",level:3},{value:"%AggregateAccum",id:"aggregateaccum",level:3},{value:"%AggregateEnd",id:"aggregateend",level:3},{value:"%BuildLeafIndex",id:"buildleafindex",level:3},{value:"%ComputeTotals",id:"computetotals",level:3},{value:"%GetAxisValues",id:"getaxisvalues",level:3},{value:"%IntersectExists",id:"intersectexists",level:3},{value:"%Intersect",id:"intersect",level:3},{value:"%IntersectOrset",id:"intersectorset",level:3},{value:"%CountFactsWithSlicer",id:"countfactswithslicer",level:3},{value:"%GetBranchesForSlicer",id:"getbranchesforslicer",level:3},{value:"%MergeRelatedBranches",id:"mergerelatedbranches",level:3},{value:"%CleanBranchesForSlicer",id:"cleanbranchesforslicer",level:3},{value:"%ReduceSlicerAndBranch",id:"reduceslicerandbranch",level:3},{value:"%ReduceOrsInSlicer",id:"reduceorsinslicer",level:3},{value:"%GetSlicerMask",id:"getslicermask",level:3},{value:"%ResolveCurrentMembers",id:"resolvecurrentmembers",level:3},{value:"%ProcessOneCurrentMember",id:"processonecurrentmember",level:3},{value:"%ComputeCMbrCellSpec",id:"computecmbrcellspec",level:3},{value:"%ResolveRelationships",id:"resolverelationships",level:3},{value:"%SpecToJoinIndex",id:"spectojoinindex",level:3},{value:"%ConvertDeepSpec",id:"convertdeepspec",level:3},{value:"%ConvertDeepMemberSpec",id:"convertdeepmemberspec",level:3},{value:"%CreateJoinIndex",id:"createjoinindex",level:3},{value:"%GetCorrelatedMembers",id:"getcorrelatedmembers",level:3},{value:"%FindDependentMembers",id:"finddependentmembers",level:3},{value:"%ProcessResultSubset",id:"processresultsubset",level:3},{value:"%PrintCells",id:"printcells",level:3},{value:"%ResolveAggregateAddress",id:"resolveaggregateaddress",level:3},{value:"%SetLogging",id:"setlogging",level:3},{value:"%GetLogSetting",id:"getlogsetting",level:3},{value:"%ClearLog",id:"clearlog",level:3},{value:"%PrintLog",id:"printlog",level:3}];function c(e){const s={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"deepseequeryengine",children:"%DeepSee.Query.Engine"})}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"Class %DeepSee.Query.Engine Extends %RegisteredObject [ System = 3 ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Contains the logic for calculating the results of a DeepSee query."}),"\n",(0,n.jsx)(s.h2,{id:"parameters",children:"Parameters"}),"\n",(0,n.jsx)(s.h3,{id:"maxlisting",children:"MAXLISTING"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"Parameter MAXLISTING = 20000;\n"})}),"\n",(0,n.jsx)(s.p,{children:"Maximum number of items in a listing. Setting this above 20000 can cause browser timeouts."}),"\n",(0,n.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,n.jsx)(s.h3,{id:"purgebuckets",children:"%PurgeBuckets"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %PurgeBuckets(pCubeName As %String) As %Status [ Deprecated, Internal ]\n"})}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"DEPRECATED"})," - Use %DeepSee.Utils:%PurgeObsoleteCache. Delete all unused buckets from the result cache for cube pCubeName."]}),"\n",(0,n.jsx)(s.h3,{id:"getbucketlist",children:"%GetBucketList"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %GetBucketList(pCubeName As %String, Output pBucketList As %Integer, Output pActiveChunk As %Integer) As %Status [ Internal ]\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Get the bucket list for the given cube.",(0,n.jsx)(s.br,{}),"\nIf the list is not in the cache, build it and store it in the results global for the cube.",(0,n.jsx)(s.br,{}),"\nThe list is of the form:",(0,n.jsx)(s.br,{}),"\npBucketList(bucketNo) = slotNo",(0,n.jsx)(s.br,{}),"\npActiveChunk contains the number of the active chunk."]}),"\n",(0,n.jsx)(s.h3,{id:"invalidatebuckets",children:"%InvalidateBuckets"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %InvalidateBuckets(pCubeName As %String, pFactClass As %String, ByRef pChunkList) As %Status [ Internal ]\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Invalidate any buckets affected by the given bitmap chunks from the result cache for cube pCubeName.",(0,n.jsx)(s.br,{}),"\nAs a side effect, test if the active chunk has changed, if so adjust buckets to compensate."]}),"\n",(0,n.jsx)(s.h3,{id:"cuberemoved",children:"%CubeRemoved"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %CubeRemoved(pCubeName As %String, pClassName As %String) As %Status\n"})}),"\n",(0,n.jsx)(s.p,{children:"Notification that a cube has been removed / recompiled."}),"\n",(0,n.jsx)(s.h3,{id:"clearcache",children:"%ClearCache"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ClearCache(pCubeName As %String, pResultsOnly As %Boolean = 0) As %Status\n"})}),"\n",(0,n.jsx)(s.p,{children:"Clear the results cache for the given cube. If pResultsOnly is true, then only clear the results cache."}),"\n",(0,n.jsx)(s.h3,{id:"executeforbucket",children:"%ExecuteForBucket"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ExecuteForBucket(pCube As %String, pKey As %String, pBucketNo As %Integer, pSlotNo As %Integer, ByRef pSections As %List, pTrace As %Boolean = 0, ByRef pStats) As %Status [ Internal ]\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Compute the values of cells within the result cube.",(0,n.jsx)(s.br,{}),"\npCube is the name of the cube.",(0,n.jsx)(s.br,{}),"\npKey is the query key.",(0,n.jsx)(s.br,{}),"\npBucketNo is the logical bucket number to execute.",(0,n.jsx)(s.br,{}),"\npSlotNo is the physical bucket slot number containing the results.",(0,n.jsx)(s.br,{}),"\npSection, if defined, specifies, by axis, which sections of the result to calculate:",(0,n.jsx)(s.br,{}),"\npSection(axis) = $LB(startNode,endNode)",(0,n.jsx)(s.br,{}),"\npTrace is a debugging flag."]}),"\n",(0,n.jsx)(s.h3,{id:"consolidate",children:"%Consolidate"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %Consolidate(pCube As %String, pKey As %String, ByRef pBucketList As %Integer, pTrace As %Boolean = 0, ByRef pStats, ByRef pNonEmptyList) As %Status [ Internal ]\n"})}),"\n",(0,n.jsxs)(s.p,{children:["For a given query, consolidate the partial answers into a final answer and, if required, remove empty rows and columns.",(0,n.jsx)(s.br,{}),"\npNonEmptyList is an additional list of non-empty axes to apply when folding compound cubes."]}),"\n",(0,n.jsx)(s.h3,{id:"computeexpressions",children:"%ComputeExpressions"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ComputeExpressions(pCube As %String, pKey As %String, pPhase As %Integer, ByRef pCalcCells, Output pPendingCells, ByRef pNonEmptyList) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Compute all the cell expressions within a consolidated query. This is called during the consolidation phase and also to update expressions as pending results are resolved."}),"\n",(0,n.jsx)(s.h3,{id:"resolvecomputations",children:"%ResolveComputations"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ResolveComputations(pCube As %String, pKey As %String, ByRef pCalcCells, Output pOrderedCalcCells, pFinalAxisCount As %String, ByRef pRealAxisKey) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"This is called by %ComputeExpressions pCalcCells contains the list of addresses for all cells that need to be computed. %ResolveComputations returns an ordered list (pOrderedCalcCells) of the form: pOrderedCalcCells(index)=cellAddr The addresses are ordered such a way that no cell contains a computation referencing a cell occurring later in the list. This means that %ComputeExpressions can evaluate all calculated cells in a single pass."}),"\n",(0,n.jsx)(s.h3,{id:"computecellweight",children:"%ComputeCellWeight"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ComputeCellWeight(pCubeIndex As %String, pAxisKey As %String, pNodeNo As %Integer, Output pWeight As %Decimal, Output pSolveOrder As %Decimal, pLevel As %Integer = 0, ByRef pVisited) [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:'Compute the "weight" of the given node within an axis. This is used to determine which axis has precedence when computing a cell value.'}),"\n",(0,n.jsx)(s.h3,{id:"updatependingresults",children:"%UpdatePendingResults"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %UpdatePendingResults(pCube As %String, pKey As %String, Output pPending As %Boolean) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"If the given query has pending results, update them."}),"\n",(0,n.jsx)(s.h3,{id:"computetupleforcell",children:"%ComputeTupleForCell"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ComputeTupleForCell(pCube As %String, pKey As %String, ByRef pAddr, Output pTuple) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Find the tuple expression for the given cell in the given query. Prepend the axis # onto each tuple (#:)."}),"\n",(0,n.jsx)(s.h3,{id:"getspecforaxisnode",children:"%GetSpecForAxisNode"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %GetSpecForAxisNode(pCube As %String, pKey As %String, pAxisNo As %Integer, pNodeNo As %Integer, ByRef pPluginInfo As %String) As %String [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Return the spec (tuple) for a given axis node in a query. For example, this would return the MDX tuple for the rows clause of a given pivot cell."}),"\n",(0,n.jsx)(s.h3,{id:"combinesetandterms",children:"CombineSetAndTerms"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod CombineSetAndTerms(ByRef pSet, pTerms, Output pNumTerms, Output pSC) As %String [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Extract elements from pSet and concatenate them. Concatenate this result with pTerms"}),"\n",(0,n.jsx)(s.h3,{id:"getdescendantnodes",children:"%GetDescendantNodes"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %GetDescendantNodes(ByRef pNodeList, pCubeIndex As %String, pAxisKey As %Integer, pNodeNo As %Integer) [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Get set of (leaf) descendant nodes for a given member node"}),"\n",(0,n.jsx)(s.h3,{id:"findrelativenode",children:"%FindRelativeNode"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod %FindRelativeNode(pCubeIndex As %String, pAxisKey As %Integer, pAxisRoot As %Integer, pNodeNo As %Integer, pOffset As %Integer, pCheckNonempty = 0, pQueryKey As %String = "", pAxisNo As %Integer = "") As %Integer [ Internal ]\n'})}),"\n",(0,n.jsx)(s.p,{children:"Given a node number, find the node pOffset nodes away. This is used by spreadsheet functions to resolve addresses."}),"\n",(0,n.jsx)(s.h3,{id:"aggregatestart",children:"%AggregateStart"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %AggregateStart(pFunction As %String, ByRef pFlags, ByRef pContext) As %Status\n"})}),"\n",(0,n.jsxs)(s.p,{children:["This is called at the start of processing for an aggregate function.",(0,n.jsx)(s.br,{}),"\npFunction is the aggregate function.",(0,n.jsx)(s.br,{}),"\npFlags is a set of flags for the aggregate function.",(0,n.jsx)(s.br,{}),"\npContext is used to hold any context required to compute the aggregate."]}),"\n",(0,n.jsx)(s.h3,{id:"aggregateaccum",children:"%AggregateAccum"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %AggregateAccum(pFunction As %String, ByRef pFlags, ByRef pContext, pValue) As %Status\n"})}),"\n",(0,n.jsx)(s.p,{children:"This is called during processing for an aggregate function. It is called for each value in the set being aggregated."}),"\n",(0,n.jsx)(s.h3,{id:"aggregateend",children:"%AggregateEnd"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod %AggregateEnd(pFunction As %String, ByRef pFlags, ByRef pContext, Output pResult, Output pPendingInfo, pCubeName As %String = "", pQueryKey As %String = "") As %Status\n'})}),"\n",(0,n.jsxs)(s.p,{children:["This is called at the end of processing for an aggregate function.",(0,n.jsx)(s.br,{}),"\nIf the aggregate is being computed in the background, then pPendingInfo will contain details."]}),"\n",(0,n.jsx)(s.h3,{id:"buildleafindex",children:"%BuildLeafIndex"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %BuildLeafIndex(pCube As %String, pKey As %String) As %Status [ Internal ]\n"})}),"\n",(0,n.jsxs)(s.p,{children:["For a completed query, construct an index of all visible leaf nodes, in display order, for each axis.",(0,n.jsx)(s.br,{}),"\nThis takes the form:",(0,n.jsx)(s.br,{}),'\nResults("leaf",axisNo,leafNo) = nodeNo']}),"\n",(0,n.jsx)(s.h3,{id:"computetotals",children:"%ComputeTotals"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ComputeTotals(pCube As %String, pKey As %String, ByRef pMaxValue As %Decimal, ByRef pMinValue As %Decimal) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"For a completed query, compute totals and other aggregates for each row and column of the result. If the query has more than 2 axes, then this does nothing."}),"\n",(0,n.jsx)(s.h3,{id:"getaxisvalues",children:"%GetAxisValues"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %GetAxisValues(Output pIndex, pCube As %String, pKey As %String, Output pTotal As %Double, pPreserveOrder As %Boolean = 0) As %Status [ Internal ]\n"})}),"\n",(0,n.jsxs)(s.p,{children:['Build an array (in the ^||DeepSee.Temp global) of the values in the first "column" of a query for each "row".',(0,n.jsx)(s.br,{}),"\nThis is used by functions such as Filter et. al. to get values from subquery results.",(0,n.jsx)(s.br,{}),"\nOn return pIndex holds the subscript for the temp global.",(0,n.jsx)(s.br,{}),"\nThe results are returned in an array subscripted by internal tuple names:",(0,n.jsx)(s.br,{}),"\nFact : Value $C(2) Fact : Value",(0,n.jsx)(s.br,{}),"\nIn addition, the total of the value is returned via pTotal as some consumers are interested in this value.",(0,n.jsx)(s.br,{}),"\nIf pPreserveOrder, then the results are returned in ranked order using a leading numeric subscript."]}),"\n",(0,n.jsx)(s.h3,{id:"intersectexists",children:"%IntersectExists"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod %IntersectExists(pCube As %String, pIndex1 As %String, pKey1 As %String, pIndex2 As %String = "", pKey2 As %String = "") As %Boolean [ Internal ]\n'})}),"\n",(0,n.jsx)(s.p,{children:"Call %Intersect with the pExistsOnly flag set."}),"\n",(0,n.jsx)(s.h3,{id:"intersect",children:"%Intersect"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod %Intersect(pCube As %String, pIndex1 As %String, pKey1 As %String, pIndex2 As %String = "", pKey2 As %String = "", pExistsOnly = 0) As %Boolean [ Internal ]\n'})}),"\n",(0,n.jsxs)(s.p,{children:["Given a pair of index and key names, test if there is an intersection of the implied sets within the specified cube. Return true (1) if there is a possible intersection. If a slicer is present it will also be applied before testing the intersection.",(0,n.jsx)(s.br,{}),"\nThis method may be called in two modes, controlled by pExistsOnly:",(0,n.jsx)(s.br,{}),"\n0 - Fully compute the intersection for any bucket looked at in this intersection and cache the result for later use",(0,n.jsx)(s.br,{}),"\n1 - Stop examination of the requested intersection as soon as a single fact is found that fits the supplied intersect parameters"]}),"\n",(0,n.jsx)(s.h3,{id:"intersectorset",children:"%IntersectOrset"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %IntersectOrset(pCubeIndex, pKey, pOrsetLeafNode, pNode2, Output pStatus As %Status) As %Boolean [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:'Traverse a node of type "orset", beginning at the bottom and working up. If any of the nodes contained in the orset intersect with the the node represented by pNode2, the method will return true. If there are zero intersections in any of the nodes in the orset chain, the method returns false.'}),"\n",(0,n.jsx)(s.h3,{id:"countfactswithslicer",children:"%CountFactsWithSlicer"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %CountFactsWithSlicer(pCube As %String, pSlicerKey As %String, pMaxCount As %Integer = 10000) As %Integer [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Compute the number of facts within the current slicer. Return -1 if there is no slicer or all/most facts are selected by it or if the count is greater than pMaxCount."}),"\n",(0,n.jsx)(s.h3,{id:"getbranchesforslicer",children:"%GetBranchesForSlicer"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %GetBranchesForSlicer(pCube As %String, pSlicerKey As %String, Output pBranch, Output pHasRelations As %Boolean, Output pReferencedFacts As %String) As %Status [ Internal ]\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Given a slicer axis key, return a graph of branch nodes in the slicer that can be to compute the facts within the slicer.",(0,n.jsx)(s.br,{}),"\nThe branch structure looks like:",(0,n.jsx)(s.br,{}),"\npBranch(1)=2",(0,n.jsx)(s.br,{}),"\npBranch(1,1)=$lb(1,2006)",(0,n.jsx)(s.br,{}),'\npBranch(1,2)=$lb(8,"24")',(0,n.jsx)(s.br,{}),"\npBranch(2)=2",(0,n.jsx)(s.br,{}),"\npBranch(2,1)=$lb(1,2007)",(0,n.jsx)(s.br,{}),'\npBranch(2,2)=$lb(8,"24")',(0,n.jsx)(s.br,{}),"\nEach top-level branch needs to be OR'd together, within each branch items are ANDed. Each node contains $LB(fact,key).",(0,n.jsx)(s.br,{}),"\npReferencedFacts is array of facts referenced in the slicer; this is used to disambiguate slicers with no effect from slicers that restrict everything."]}),"\n",(0,n.jsx)(s.h3,{id:"mergerelatedbranches",children:"%MergeRelatedBranches"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %MergeRelatedBranches(ByRef pRelatedBranch, Output pLocalBranch) As %Status\n"})}),"\n",(0,n.jsx)(s.h3,{id:"cleanbranchesforslicer",children:"%CleanBranchesForSlicer"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod %CleanBranchesForSlicer(ByRef pSlicerBranches, pCube As %String = "") As %Status\n'})}),"\n",(0,n.jsx)(s.p,{children:"The raw collection of the slicer branches can produce branches that define logically null sets. This removes those branches, and removes duplicate entries within a branch that would lead to extra processing."}),"\n",(0,n.jsx)(s.h3,{id:"reduceslicerandbranch",children:"%ReduceSlicerAndBranch"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod %ReduceSlicerAndBranch(ByRef pAndBranch, pCube As %String = "") As %Status [ Internal ]\n'})}),"\n",(0,n.jsx)(s.p,{children:"Examine the branch-representation of an AND within the slicer and reduce it to the smallest number of logically separate elements. In this process, duplicate entries of a single fact is removed, and contradictory intersections nullify the entire branch."}),"\n",(0,n.jsx)(s.h3,{id:"reduceorsinslicer",children:"%ReduceOrsInSlicer"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod %ReduceOrsInSlicer(ByRef pSlicerBranches, pCube As %String = "") As %Status\n'})}),"\n",(0,n.jsxs)(s.p,{children:["Reduce to minimal AND logic for the purposes of identifying global fact restrictions. This attempts to simplify the restriction terms by reducing a slicer tree",(0,n.jsx)(s.br,{}),"\npSlicerBranches(OrIndex,AndIndex)",(0,n.jsx)(s.br,{}),"\nstructure into a single OR branch. This produces the minimally restrictive representation of the slicer. Note that this should not be used when calculating the final results, as it will throw away some restrictions!"]}),"\n",(0,n.jsx)(s.h3,{id:"getslicermask",children:"%GetSlicerMask"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %GetSlicerMask(pCubeIndex As %String, ByRef pMask As %Binary, ByRef pBranch, pBranchNo As %Integer = 0, pChunk As %Integer = 0, pSlotNo As %Integer = 0) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Return the bit mask from the slicer for a given slicer branch and a given chunk. pCubeName is the uppercase cubename."}),"\n",(0,n.jsx)(s.h3,{id:"resolvecurrentmembers",children:"%ResolveCurrentMembers"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ResolveCurrentMembers(pCube As %String, pKey As %String, pQuery As %DeepSee.Query.query) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"For a given query, resolve currentMember references. This means looking at all other axes and applying the CurrentMember expression to every case where the current member appears."}),"\n",(0,n.jsx)(s.h3,{id:"processonecurrentmember",children:"%ProcessOneCurrentMember"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ProcessOneCurrentMember(pCube As %String, pKey As %String, pQuery As %DeepSee.Query.query, ByRef pAddr, ByRef pMap, pSlicerAxis As %Integer) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Process current member information for one cell."}),"\n",(0,n.jsx)(s.h3,{id:"computecmbrcellspec",children:"%ComputeCMbrCellSpec"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod %ComputeCMbrCellSpec(Output pCellSpec, Output pMsr, Output pCellAgg, Output pCellMsrScale, Output pCellMsrType, pCube As %String, pKey As %String, ByRef pAddr, pCMbrAxis, pCMbrCubeIndex, pLocalKey, pLeafNodeNo, ByRef pReferencedNodes, pIsSlicer As %Boolean = 0, pFilterSpec As %List = "") As %Status [ Internal ]\n'})}),"\n",(0,n.jsx)(s.p,{children:"Compute a cell spec for one node within a current member cell (pAddr)."}),"\n",(0,n.jsx)(s.h3,{id:"resolverelationships",children:"%ResolveRelationships"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ResolveRelationships(pCube As %String, pKey As %String, pUseAgents As %Boolean = 0) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"For a given query, compute any bitsets that come from queries against related cubes."}),"\n",(0,n.jsx)(s.h3,{id:"spectojoinindex",children:"%SpecToJoinIndex"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod %SpecToJoinIndex(pSpec As %List, pCube As %String = "", pKey As %String = "", pUseAgents As %Boolean = 1, ByRef pRelation, ByRef pIntersect, pGroupId As %String = "") As %Status\n'})}),"\n",(0,n.jsx)(s.p,{children:"Produce all join index entries for a particular pSpec. The references pCube and pKeyare required. The array pRelation contains the metadata about the current relationships in play in the cube. The by-reference pIntersect can be used to prevent duplicate calculations of the same join index keys."}),"\n",(0,n.jsx)(s.h3,{id:"convertdeepspec",children:"%ConvertDeepSpec"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ConvertDeepSpec(pDRelCube As %String, pSpecialRelCube As %String, pRelName As %String, pDSpec As %String, pIncludeKey As %Boolean = 0) As %String [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"This is a deep relationships spec conversion method. It will take the subquery text and convert the spec to the original form. This takes in a related cube that is running the query, the cube of the target relationship dimension, the name of the relation, the spec text, and if the output should include the key or not."}),"\n",(0,n.jsx)(s.h3,{id:"convertdeepmemberspec",children:"%ConvertDeepMemberSpec"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ConvertDeepMemberSpec(pDRelCube As %String, pSpecialRelCube As %String, pRelName As %String, pNode As %DeepSee.Query.node) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"This method will iterate through the query object of a complex spec. Once a memberSpec is reached, the spec will be replaced by the original top level query spec. This helps match the tIntersectIndex"}),"\n",(0,n.jsx)(s.h3,{id:"createjoinindex",children:"%CreateJoinIndex"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %CreateJoinIndex(pCube As %String, pRemoteCube As %String, pFactNo As %Integer, pKeyCode As %String, pQueryKey As %String) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:'Given a cube, a remote cube, and a "key code" describing an interection against the remote cube, construct an index in the cube based on intersecting the remote bits and transposing to local bits.'}),"\n",(0,n.jsx)(s.h3,{id:"getcorrelatedmembers",children:"%GetCorrelatedMembers"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %GetCorrelatedMembers(pCube As %String, ByRef pStatement As %SQL.StatementResult, Output pMembers, pFactNo As %Integer, pFactId As %String, pFactList As %List) As %Status [ Internal ]\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Given a cube and member within a cube (fact and id value), find the distinct set of correlated members in one or more other facts (given by list of fact numbers: pFactList). This is used by compound cubes.",(0,n.jsx)(s.br,{}),"\nOn return pMembers contains the set of distinct id values.",(0,n.jsx)(s.br,{}),"\nThis takes the form: pMembers(n) = $LB(fact1id,fact2id,...) pStatement is the SQL statement object used to fetch the results. It is possible to pass this into a subsequent call to avoid re-preparing the query."]}),"\n",(0,n.jsx)(s.h3,{id:"finddependentmembers",children:"%FindDependentMembers"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %FindDependentMembers(pCube As %String, ByRef pMemberIds As %String, pFactNo As %Integer, pMasterFactNo As %Integer, pMasterId As %String, pConditionNo As %Integer = 0) As %Status [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:'For a level (pFactNo) with a dependsOn attribute, find the set of members that apply for the given "master" fact.'}),"\n",(0,n.jsx)(s.h3,{id:"processresultsubset",children:"%ProcessResultSubset"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ProcessResultSubset(pCube, pQueryKey, pAxisNo) As %Status\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Process any subset functions that have been noted for processing in the axis cache under",(0,n.jsx)(s.br,{}),'\n^DeepSee.Cache.Axis(cube,axisKey,"subset")',(0,n.jsx)(s.br,{}),"\nFor each subset node the results currently in the result cache will be trimmed according to the subset function and the count of that subset function. If multiple subset functions are nested within one another, the innermost function will be processed first and subsequent nested functions will be processed on the remaining results.",(0,n.jsx)(s.br,{}),"\nIf these nodes do not exist in the axis cache this method will do nothing."]}),"\n",(0,n.jsx)(s.h3,{id:"printcells",children:"%PrintCells"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %PrintCells(pCubeName As %String, pKey As %String) [ Internal ]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Diagnostic."}),"\n",(0,n.jsx)(s.h3,{id:"resolveaggregateaddress",children:"%ResolveAggregateAddress"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod %ResolveAggregateAddress(pCubeIndex = "", pQueryKey = "", ByRef pAddr, pRealAxisCount = "", pFindAggregate = 0) As %Status\n'})}),"\n",(0,n.jsx)(s.p,{children:"Given a current address in the results cache, find the root node for the aggregate. If the input address is not the child of an aggregate, change nothing. If pFindAggregate=1, then search the axes for a special aggregate node. If none is found,"}),"\n",(0,n.jsx)(s.h3,{id:"setlogging",children:"%SetLogging"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %SetLogging(pLogLevel = 0)\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Set the logging global to signal the engine to record events according to the appropriate level. pLogLevel may be set to",(0,n.jsx)(s.br,{}),"\n- 1 - Record basic metrics such as method timers - 2 - Record actual counts of computational operations during query execution"]}),"\n",(0,n.jsx)(s.h3,{id:"getlogsetting",children:"%GetLogSetting"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %GetLogSetting()\n"})}),"\n",(0,n.jsx)(s.p,{children:"Return the current MDX Engine log setting."}),"\n",(0,n.jsx)(s.h3,{id:"clearlog",children:"%ClearLog"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %ClearLog()\n"})}),"\n",(0,n.jsx)(s.p,{children:"Clear all data stored in the runtime log. This preserves the original log level setting."}),"\n",(0,n.jsx)(s.h3,{id:"printlog",children:"%PrintLog"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod %PrintLog(Output pStatistics, pVerbose = 1)\n"})}),"\n",(0,n.jsx)(s.p,{children:"Diagnostic printout of the recorded computation metrics"})]})}function o(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>l});var n=t(96540);const r={},i=n.createContext(r);function a(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);