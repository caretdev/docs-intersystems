"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[99194],{74912:(e,a,l)=>{l.r(a),l.d(a,{contentTitle:()=>o,default:()=>c,frontMatter:()=>s,toc:()=>n});var i=l(74848),t=l(28453);const s={pagination_prev:null,pagination_next:null},o="%Library.FilemanTimeStamp",n=[{value:"Parameters",id:"parameters",level:2},{value:"STRICTDATA",id:"strictdata",level:3},{value:"XSDTYPE",id:"xsdtype",level:3},{value:"JSONTYPE",id:"jsontype",level:3},{value:"Methods",id:"methods",level:2},{value:"XSDToLogical",id:"xsdtological",level:3},{value:"LogicalToXSD",id:"logicaltoxsd",level:3},{value:"DisplayToLogical",id:"displaytological",level:3},{value:"IsValid",id:"isvalid",level:3},{value:"LogicalToDisplay",id:"logicaltodisplay",level:3},{value:"LogicalToOdbc",id:"logicaltoodbc",level:3},{value:"OdbcToLogical",id:"odbctological",level:3},{value:"StorageToLogical",id:"storagetological",level:3}];function r(e){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.header,{children:(0,i.jsx)(a.h1,{id:"libraryfilemantimestamp",children:"%Library.FilemanTimeStamp"})}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:"Class %Library.FilemanTimeStamp [ ClassType = datatype, ClientDataType = FTIMESTAMP, OdbcType = TIMESTAMP, SqlCategory = FMTIMESTAMP, System = 2 ]\n"})}),"\n",(0,i.jsx)(a.p,{children:"Custom TimeStamp datatype designed to handle internal FILEMAN format TimeStamp (CYYMMDD.HHMMSS). This data type projects proper TIMESTAMP meta data to DISPLAY and ODBC Client software. It does not require any extra routines to function"}),"\n",(0,i.jsx)(a.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(a.h3,{id:"strictdata",children:"STRICTDATA"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:"Parameter STRICTDATA As BOOLEAN = 0;\n"})}),"\n",(0,i.jsx)(a.p,{children:"1/0 flag which determines if the LogicalToFormat conversions will process imprecise logical FileMan Date values Default setting is STRICTDATA=0 Parameter affects the generation of the LogicalToDisplay and LogicalToOdbc methods When STRICTDATA=1, imprecise or invalid dates will not be changed to a valid FileMan Date value. For example, if Logical FileMan Date value is 31110, when STRICTDATA=0 this will translate to 3111001 (Sept 01, 2011). If STRICTDATA=1, this transformation will not take place and the invalid/imprecise Logical value will get an error when converted to Display or Odbc format."}),"\n",(0,i.jsx)(a.h3,{id:"xsdtype",children:"XSDTYPE"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:'Parameter XSDTYPE = "dateTime";\n'})}),"\n",(0,i.jsx)(a.h3,{id:"jsontype",children:"JSONTYPE"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:'Parameter JSONTYPE = "string";\n'})}),"\n",(0,i.jsx)(a.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsx)(a.h3,{id:"xsdtological",children:"XSDToLogical"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:"ClassMethod XSDToLogical(%val As %String) As %FilemanTimeStamp [ CodeMode = generator ]\n"})}),"\n",(0,i.jsx)(a.h3,{id:"logicaltoxsd",children:"LogicalToXSD"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:"ClassMethod LogicalToXSD(%val As %FilemanTimeStamp) As %String [ CodeMode = generator ]\n"})}),"\n",(0,i.jsx)(a.p,{children:"Converts the %FilemanTimeStamp value to the canonical SOAP encoded value."}),"\n",(0,i.jsx)(a.h3,{id:"displaytological",children:"DisplayToLogical"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:"ClassMethod DisplayToLogical(Arg1 As %Library.String) As %Library.FilemanTimeStamp [ ServerOnly = 0 ]\n"})}),"\n",(0,i.jsx)(a.p,{children:"Converts DISPLAY format TIMESTAMP (MM/DD/YYYY HH:MM:SS) to FILEMAN format TimeStamp (CYYMMDD.HHMMSS)."}),"\n",(0,i.jsx)(a.h3,{id:"isvalid",children:"IsValid"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:"ClassMethod IsValid(%val As %RawString) As %Status [ CodeMode = generator, ServerOnly = 0 ]\n"})}),"\n",(0,i.jsx)(a.p,{children:"Checks for Invalid Format, expects FILEMAN format TimeStamp (CYYMMDD.HHMMSS)."}),"\n",(0,i.jsx)(a.h3,{id:"logicaltodisplay",children:"LogicalToDisplay"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:'ClassMethod LogicalToDisplay(Arg1 As %Library.FilemanTimeStamp = "") As %Library.String [ CodeMode = generator, ServerOnly = 0 ]\n'})}),"\n",(0,i.jsx)(a.p,{children:"Checks for Invalid Format, expects FILEMAN format TimeStamp (CYYMMDD.HHMMSS). Converts FILEMAN format TimeStamp (CYYMMDD.HHMMSS) to DISPLAY format TIMESTAMP (DD/MM/YYYY HH:MM:SS)."}),"\n",(0,i.jsx)(a.h3,{id:"logicaltoodbc",children:"LogicalToOdbc"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:"ClassMethod LogicalToOdbc(Arg1 As %Library.FilemanTimeStamp) As %Library.String [ CodeMode = generator ]\n"})}),"\n",(0,i.jsx)(a.p,{children:"Converts FILEMAN format TimeStamp (CYYMMDD.HHMMSS) to ODBC format TIMESTAMP (YYYY-MM-DD HH:MM:SS)"}),"\n",(0,i.jsx)(a.h3,{id:"odbctological",children:"OdbcToLogical"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:"ClassMethod OdbcToLogical(Arg1 As %Library.String) As %Library.FilemanTimeStamp\n"})}),"\n",(0,i.jsx)(a.p,{children:"Converts ODBC format TIMESTAMP (YYYY-MM-DD HH:MM:SS) to FILEMAN format TimeStamp (CYYMMDD.HHMMSS)"}),"\n",(0,i.jsx)(a.h3,{id:"storagetological",children:"StorageToLogical"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-objectscript-class",children:"ClassMethod StorageToLogical(%val As %Library.String) As %Library.FilemanTimeStamp\n"})}),"\n",(0,i.jsx)(a.p,{children:"Converts Storage FileMan TIMESTAMP (CYYMMDD.HHMMSS) with possible trailing 0's to a Logical canonical value without trailing 0's This is needed so that values with trailing zeros and without can all be compared with ]] properly (they will all be treated as numeric values). LogicalTo**** methods will handle the missing trailing zeros to produce the correct time"})]})}function c(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}},28453:(e,a,l)=>{l.d(a,{R:()=>o,x:()=>n});var i=l(96540);const t={},s=i.createContext(t);function o(e){const a=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function n(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:a},e.children)}}}]);