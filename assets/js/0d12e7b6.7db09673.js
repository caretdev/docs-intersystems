"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[75998],{22950:(e,s,t)=>{t.r(s),t.d(s,{contentTitle:()=>i,default:()=>c,frontMatter:()=>r,toc:()=>o});var a=t(74848),n=t(28453);const r={pagination_prev:null,pagination_next:null},i="%SYSTEM.Cluster",o=[{value:"API Usage",id:"api-usage",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Architecture of a Sharded Cluster",id:"architecture-of-a-sharded-cluster",level:3},{value:"Prequisites for Using This API",id:"prequisites-for-using-this-api",level:3},{value:"Methods",id:"methods",level:2},{value:"Initialize",id:"initialize",level:3},{value:"InitializeMirrored",id:"initializemirrored",level:3},{value:"Init",id:"init",level:3},{value:"AttachAsDataNode",id:"attachasdatanode",level:3},{value:"AttachAsComputeNode",id:"attachascomputenode",level:3},{value:"AttachAsMirroredNode",id:"attachasmirrorednode",level:3},{value:"Attach",id:"attach",level:3},{value:"SwapDatabases",id:"swapdatabases",level:3},{value:"CreateOrReuseDatabase",id:"createorreusedatabase",level:3},{value:"CatchupDBInternal",id:"catchupdbinternal",level:3},{value:"CatchupDB",id:"catchupdb",level:3},{value:"GetDbPropsForNamespace",id:"getdbpropsfornamespace",level:3},{value:"ClusterNamespace",id:"clusternamespace",level:3},{value:"ListNodes",id:"listnodes",level:3},{value:"GetMetadata",id:"getmetadata",level:3},{value:"CreateMirror",id:"createmirror",level:3},{value:"IsNodeReady",id:"isnodeready",level:3},{value:"Detach",id:"detach",level:3}];function d(e){const s={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"systemcluster",children:"%SYSTEM.Cluster"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"Class %SYSTEM.Cluster Extends %SYSTEM.Help\n"})}),"\n",(0,a.jsx)(s.p,{children:"This class provides an API for node-level configuration of sharded clusters."}),"\n",(0,a.jsx)(s.p,{children:"You can use it via the special $SYSTEM object, for example:"}),"\n",(0,a.jsx)(s.p,{children:"set status = $SYSTEM.Cluster.Initialize()"}),"\n",(0,a.jsx)(s.h2,{id:"api-usage",children:"API Usage"}),"\n",(0,a.jsx)(s.p,{children:"Call Initialize to set up an InterSystems IRIS instance as the first node of a new nonmirrored sharded cluster (that is, a sharded cluster in which all data nodes are nonmirrored)."}),"\n",(0,a.jsx)(s.p,{children:"Call InitializeMirrored to set up an InterSystems IRIS instance as the first node of a new mirrored sharded cluster (that is, a sharded cluster in which all data nodes are mirrored)."}),"\n",(0,a.jsx)(s.p,{children:"Call AttachAsDataNode to add an instance to a cluster as a nonmirrored data node."}),"\n",(0,a.jsx)(s.p,{children:"Call AttachAsMirroredNode to add an instance to a cluster as a mirrored data node."}),"\n",(0,a.jsx)(s.p,{children:"Call AttachAsComputeNode to add an instance to a cluster as a compute node."}),"\n",(0,a.jsx)(s.p,{children:"Call Detach to detach an instance from a cluster."}),"\n",(0,a.jsx)(s.p,{children:"Call ListNodes to print a list of a cluster's nodes."}),"\n",(0,a.jsx)(s.p,{children:"Call GetMetadata to retrieve an overview of a cluster's metadata."}),"\n",(0,a.jsx)(s.p,{children:"Call ClusterNamespace to get the name of the cluster namespace for the current instance."}),"\n",(0,a.jsx)(s.h2,{id:"terminology",children:"Terminology"}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"Sharded Cluster"})}),"\n",(0,a.jsx)(s.p,{children:"An interconnected set of nodes which provides horizonal scalability of users and data."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"Node"})}),"\n",(0,a.jsx)(s.p,{children:'An InterSystems IRIS instance that participates in a sharded cluster. Nodes are of two types, "data" and "compute", but all nodes can be used interchangeably as application servers, providing transparent access to all data in the cluster. Data nodes can be mirrored or nonmirrored. Compute nodes are always non-mirrored.'}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"Data Node"})}),"\n",(0,a.jsx)(s.p,{children:"A node that stores a partition (shard) of sharded data locally."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"Compute Node"})}),"\n",(0,a.jsx)(s.p,{children:"A node that does not store sharded data locally, but provides compute access to the sharded data on a corresponding data node, via global mapping."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"Cluster URL"})}),"\n",(0,a.jsxs)(s.p,{children:['The address of a node, specified in the format "IRIS://',(0,a.jsx)(s.em,{children:"host"}),":",(0,a.jsx)(s.em,{children:"port"}),"/",(0,a.jsx)(s.em,{children:"cluster-namespace"}),'".']}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"Cluster Namespace"})}),"\n",(0,a.jsx)(s.p,{children:"A namespace that exists, with the same name, on every node of a sharded cluster, providing transparent access to all sharded and nonsharded data, and all code, on the cluster."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"Master Namespace"})}),"\n",(0,a.jsx)(s.p,{children:"A namespace that exists only on node 1 of a sharded cluster. Metadata and nonsharded data stored in its globals databases, and code stored in its routines database, are accessible in the cluster namespace on every node of the cluster, via database mapping."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"Shard Database"})}),"\n",(0,a.jsx)(s.p,{children:"A database on each data node that stores a partition (shard) of sharded data. A shard database is not the default database of any namespace, but globals stored in it are visible within the cluster namespace on the same data node, or any associated compute node, via global mapping."}),"\n",(0,a.jsx)(s.h3,{id:"architecture-of-a-sharded-cluster",children:"Architecture of a Sharded Cluster"}),"\n",(0,a.jsx)(s.p,{children:"Sharded clusters configured using methods of this class have the following architecture:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Each node consists of a separate InterSystems IRIS instance on a separate machine, and participates in only one sharded cluster."}),"\n",(0,a.jsx)(s.li,{children:'Every node has a cluster namespace, which all have the same name on every instance of the cluster ("IRISCLUSTER", by default).'}),"\n",(0,a.jsx)(s.li,{children:"A cluster has one or more data nodes, each of which has a shard database which stores one partition (shard) of the cluster's sharded data. Adding data nodes increases the degree of partitioning (number of shards) of sharded data."}),"\n",(0,a.jsx)(s.li,{children:"A cluster is either mirrored or nonmirrored. In a mirrored cluster, all data nodes are mirrored. In a nonmirrored cluster, all data nodes are nonmirrored."}),"\n",(0,a.jsx)(s.li,{children:"A cluster has zero or more compute nodes. These do not store any data, but have mapped access to the sharded data of an associated data node. Zero or more compute nodes can be associated with each data node, and are transparently balanced across data nodes as more compute nodes are added. Adding compute nodes increases the computing bandwidth for executing sharded queries."}),"\n",(0,a.jsxs)(s.li,{children:["All nonsharded data, and all code, is stored in the globals and routines databases, respectively, of the master namespace on the first node of the cluster, and is transparently accessible in the cluster namespace on every node, via database mapping. This master namespace, which exists only on the first node, is largely transparent to users, as all user data access can (and should) be done in the cluster namespaces.",(0,a.jsx)(s.br,{}),"\nThere is one special case where the master namespace should be used directly: Any globals, package, or routine mappings that should be visible in the cluster namespace on every node should be defined by users in the master namespace, from which they are automatically propagated to the cluster namespaces. Mappings defined by users in a cluster namespace are not propagated, and are only visible in the cluster namespace of the node on which they are defined."]}),"\n",(0,a.jsx)(s.li,{children:"All sharded data is transparently accessible via SQL in the cluster namespace of every node. The underlying globals of each partition of sharded data are only transparently accessible on the data node where that partition is stored, or on any compute nodes associated with that data node (although they can be accessed from any node via extended global references)."}),"\n",(0,a.jsx)(s.li,{children:"Every node plays a dual role, as an application server providing transparent access to all data and code, and as a shard server which locally executes those portions of sharded queries and updates that access sharded data stored on that node (in the case of a data node), or mapped to that node (in the case of a compute node). User connections can be load balanced across all nodes, so adding nodes of either type increases the computing bandwidth for user applications."}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"prequisites-for-using-this-api",children:"Prequisites for Using This API"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Machines must be provisioned and must be mutually accessible via TCP/IP."}),"\n",(0,a.jsx)(s.li,{children:"InterSystems IRIS instances must be installed, with sharding-enabled licenses."}),"\n",(0,a.jsx)(s.li,{children:"InterSystems IRIS instances must have the ECP configuration parameters MaxServers and MaxServerConn set to values at least as great as the anticipated number of nodes in the sharded cluster. Note that if these values are changed after installation, the instances must be restarted for the new values to take effect."}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(s.h3,{id:"initialize",children:"Initialize"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod Initialize(pClusterNamespace As %String = "IRISCLUSTER", pMasterNamespace As %String = "IRISDM", pAllowedConnections As %String = "", pHostIPAddress As %String = "") As %Status\n'})}),"\n",(0,a.jsxs)(s.p,{children:["Sets up the current InterSystems IRIS instance as the first data node of a new cluster. This method automatically and transparently performs all steps needed to enable this instance as the first node of a cluster (subject to these ",(0,a.jsx)(s.a,{href:"#Prerequisites",children:"prerequisites"}),"), including:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Enables the ECP and sharding services, and sets these services' lists of allowed connections, if specified via the pAllowedConnections argument."}),"\n",(0,a.jsx)(s.li,{children:"Creates the cluster and master namespaces and their databases if they don't already exist."}),"\n",(0,a.jsx)(s.li,{children:"Creates all necessary mappings from the cluster namespace to the globals and routines databases of the master namespace, and to the shard database."}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"This method returns an error in any of the following cases:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"The current InterSystems IRIS instance is already a node of a sharded cluster."}),"\n",(0,a.jsx)(s.li,{children:"The current instance is a mirror member."}),"\n",(0,a.jsx)(s.li,{children:"The specified cluster namespace already exists, and its globals database is mirrored."}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pClusterNamespace"})}),"\n",(0,a.jsx)(s.p,{children:"Cluster namespace, visible on all nodes of this cluster, providing access to both sharded and nonsharded data. If specified namespace does not exist, it is created. Default name: IRISCLUSTER."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pMasterNamespace"})}),"\n",(0,a.jsx)(s.p,{children:"Master namespace for this cluster. If specified namespace does not exist, it is created. Default name: IRISDM."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pAllowedConnections"})}),"\n",(0,a.jsx)(s.p,{children:"List of hosts allowed to participate in this cluster, specified as a semi-colon-separated list of IP addresses or hostnames. Default: No restriction of which hosts can participate."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pHostIPAddress"})}),"\n",(0,a.jsx)(s.p,{children:"IP address other nodes of this cluster should use to connect to this node. Specify a value for for this parameter if the default hostname known to InterSystems IRIS does not resolve to an appropriate address, or no hostname is available. Default: Default hostname will be used for inter-node connections."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(s.p,{children:"Status code reporting success or failure of this API call."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"If either the cluster namespace or the master namespace already exists, the existing namespace is used. If one of them exists and the other doesn't, the globals database for the one that doesn't exist is created using all of the same configuration settings as the globals database of the namespace that already exists (other than directory path). If neither namespace exists, databases for both are created using default settings."}),"\n",(0,a.jsx)(s.li,{children:"If neither namespace exists, the namespaces are created without enabling interoperability. If one namespace exists, the other namespace is created with interoperability enabled or not, according to whether it is enabled in the existing namespace."}),"\n",(0,a.jsx)(s.li,{children:"If the cluster namespace exists, its globals database becomes the shard database for node 1. The globals database of the master namespace is used to store all nonsharded data for the cluster, and its routines database is use to store all code for the cluster."}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"initializemirrored",children:"InitializeMirrored"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod InitializeMirrored(pClusterNamespace As %String = "IRISCLUSTER", pMasterNamespace As %String = "IRISDM", pAllowedConnections As %String = "", pHostIPAddress As %String = "", pArbiterIP As %String = "", pArbiterPort As %Integer = 0, pSSLDirectory As %String = "", pMirrorName As %String = "IRISMIRROR1", pMemberName As %String = "IRISMIRROR1A") As %Status\n'})}),"\n",(0,a.jsxs)(s.p,{children:["Sets up the current InterSystems IRIS instance as the first data node of a new mirrored cluster. This method automatically and transparently performs all steps needed to enable this instance as the first node of a mirrored cluster (subject to these ",(0,a.jsx)(s.a,{href:"#Prerequisites",children:"prerequisites"}),"), including:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Enables the ECP and sharding services, and sets these services' lists of allowed connections, if specified via the pAllowedConnections argument."}),"\n",(0,a.jsx)(s.li,{children:"If the current instance is not already the primary failover member of a mirror, creates a new mirror set, and configures the current instance as its first failover member."}),"\n",(0,a.jsx)(s.li,{children:"Creates the cluster and master namespaces and their databases if they don't already exist."}),"\n",(0,a.jsx)(s.li,{children:"Creates all necessary mappings from the cluster namespace to the globals and routines databases of the master namespace, and to the shard database."}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"This method returns an error in any of the following cases:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"The current InterSystems IRIS instance is already a node of a sharded cluster."}),"\n",(0,a.jsx)(s.li,{children:"The current instance is already a mirror member, but is not currently the primary failover member."}),"\n",(0,a.jsx)(s.li,{children:"The specified cluster namespace or master namespace already exists, but its globals database is not mirrored."}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pClusterNamespace"})}),"\n",(0,a.jsx)(s.p,{children:"Cluster namespace, visible on all nodes of this cluster, providing access to both sharded and nonsharded data. If specified namespace does not exist, it is created. Default name: IRISCLUSTER."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pMasterNamespace"})}),"\n",(0,a.jsx)(s.p,{children:"Master namespace for this cluster. If specified namespace does not exist, it is created. Default name: IRISDM."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pAllowedConnections"})}),"\n",(0,a.jsx)(s.p,{children:"List of hosts allowed to participate in this cluster, specified as a semi-colon-separated list of IP addresses or hostnames. Default: No restriction of which hosts can participate."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pHostIPAddress"})}),"\n",(0,a.jsx)(s.p,{children:"IP address other nodes of this cluster should use to connect to this node. Specify a value for for this parameter if the default hostname known to InterSystems IRIS does not resolve to an appropriate address, or no hostname is available. Default: Default hostname will be used for inter-node connections."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pArbiterIP"})}),"\n",(0,a.jsx)(s.p,{children:"Arbiter's hostname or IP address. Specify a non-null value to configure this mirror set to use an arbiter."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pArbiterPort"})}),"\n",(0,a.jsx)(s.p,{children:"Arbiter's port. Specify a non-zero value to configure this mirror to use an arbiter."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pSSLDirectory"})}),"\n",(0,a.jsx)(s.p,{children:'SSL/TLS keys directory. Specify a non-null value to configure this mirror to use SSL/TLS. Directory is expected to contain three files named "CAFile.pem", "CertificateFile.pem, and "PrivateKeyFile.pem".'}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pMirrorName"})}),"\n",(0,a.jsx)(s.p,{children:"Name of mirror set to create. Default: IRISMIRROR1."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pMemberName"})}),"\n",(0,a.jsx)(s.p,{children:"Name by which this instance is known to the mirror. Default: IRISMIRROR1A."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(s.p,{children:"Status code reporting success or failure of this API call."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"If the current instance is already a mirror member, the mirror configuration parameters (pArbiterIP, pArbiterPort, pSSLDirectory, pMirrorName, and pMemberName) are ignored, and the mirror configuration is not modified."}),"\n",(0,a.jsx)(s.li,{children:"If either the cluster namespace or the master namespace already exists, the existing namespace is used. If one of them exists and the other doesn't, the globals database for the one that doesn't exist is created using all of the same configuration settings as the globals database of the namespace that already exists (other than directory path). If neither namespace exists, databases for both are created using default settings."}),"\n",(0,a.jsx)(s.li,{children:"If neither namespace exists, the namespaces are created without enabling interoperability. If one namespace exists, the other namespace is created with interoperability enabled or not, according to whether it is enabled in the existing namespace."}),"\n",(0,a.jsx)(s.li,{children:"If the cluster namespace exists, its globals database becomes the shard database for node 1. The globals database of the master namespace is used to store all nonsharded data for the cluster, and its routines database is use to store all code for the cluster."}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"init",children:"Init"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod Init(pMirrored As %Boolean, pClusterNamespace As %String = "IRISCLUSTER", pMasterNamespace As %String = "IRISDM", pAllowedConnections As %String = "", pHostIPAddress As %String = "", pArbiterIP As %String = "", pArbiterPort As %Integer = 0, pSSLDirectory As %String = "", pMirrorName As %String = "", pMemberName As %String = "") As %Status [ Internal, Private ]\n'})}),"\n",(0,a.jsx)(s.h3,{id:"attachasdatanode",children:"AttachAsDataNode"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod AttachAsDataNode(pClusterURL As %String, pHostIPAddress As %String = "") As %Status\n'})}),"\n",(0,a.jsx)(s.p,{children:"Attaches the current InterSystems IRIS instance to a specified cluster as a nonmirrored data node."}),"\n",(0,a.jsxs)(s.p,{children:["This method automatically and transparently performs all steps needed to enable this instance as a data node of the specified cluster (subject to these ",(0,a.jsx)(s.a,{href:"#Prerequisites",children:"prerequisites"}),"), including:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Enables the ECP and sharding services, and sets these services' lists of allowed connections to match the lists on the node specified by pClusterURL."}),"\n",(0,a.jsx)(s.li,{children:"Creates the cluster namespace and shard database if they don't already exist, configuring them to match the settings on the node specified by pClusterURL."}),"\n",(0,a.jsx)(s.li,{children:"Creates all necessary mappings from the cluster namespace to the globals and routines databases of the master namespace on node 1, and to the shard database on the current instance."}),"\n",(0,a.jsx)(s.li,{children:"Propagates any user-defined mappings from the master namespace on node 1 to the cluster namespace on the current instance."}),"\n",(0,a.jsx)(s.li,{children:"Sets all SQL configuration options to match their settings on the node specified by pClusterURL."}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["If a data node has been flagged for pending removal by calling Detach while sharded tables exist, and the node's removal has not yet been completed by calling Rebalance, the pending removal can be cancelled by calling ",(0,a.jsx)(s.strong,{children:"AttachAsDataNode"}),". In that case, the ",(0,a.jsx)(s.em,{children:"pHostIPAddress"})," parameter is ignored, and an error is returned if the ",(0,a.jsx)(s.em,{children:"pClusterURL"})," parameter does not specify a node of the current cluster. Call ListNodes to determine whether a node is flagged for pending removal."]}),"\n",(0,a.jsx)(s.p,{children:"This method returns an error in any of the following cases:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"The current InterSystems IRIS instance is already a node of a sharded cluster."}),"\n",(0,a.jsx)(s.li,{children:"The current instance is a mirror member."}),"\n",(0,a.jsx)(s.li,{children:"The specified cluster namespace already exists, and its globals database is mirrored."}),"\n",(0,a.jsx)(s.li,{children:"The node specified by pClusterURL is mirrored."}),"\n",(0,a.jsxs)(s.li,{children:["The current instance is a node of a sharded cluster, flagged for pending removal, and the node specified by ",(0,a.jsx)(s.em,{children:"pClusterURL"})," is not a node of the same cluster."]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pClusterURL"})}),"\n",(0,a.jsxs)(s.p,{children:['Identifies the cluster to which to attach, by specifying the address of any existing node of the cluster, in the format "IRIS://',(0,a.jsx)(s.em,{children:"host"}),":",(0,a.jsx)(s.em,{children:"port"}),"/",(0,a.jsx)(s.em,{children:"cluster-namespace"}),'". Namespace may optionally be omitted, since there can be at most one cluster namespace in an InterSystems IRIS instance.']}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pHostIPAddress"})}),"\n",(0,a.jsx)(s.p,{children:"IP address other nodes of this cluster should use to connect to this node. Specify a value for for this parameter if the default hostname known to InterSystems IRIS does not resolve to an appropriate address, or no hostname is available. Default: Default hostname will be used for inter-node connections."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(s.p,{children:"Status code reporting success or failure of this API call."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"A cluster namespace, with same name as on all other nodes of this cluster, is created if a namespace of that name doesn't already exist. If it does already exist, its globals database becomes the shard database for this node."}),"\n",(0,a.jsx)(s.li,{children:"If the node specified by pClusterURL is a data node, it is used as the template for configuration settings on this node. If the specified node is a compute node, the corresponding data node is used as the template."}),"\n",(0,a.jsx)(s.li,{children:"If the cluster namespace doesn't exist, it is created with interoperability enabled or not according to whether it is enabled for the cluster namespace on the template node, and with its globals database settings, including directory path, matching those of the shard database on the template node."}),"\n",(0,a.jsx)(s.li,{children:"All SQL configuration settings are set to match those on the template node."}),"\n",(0,a.jsx)(s.li,{children:"Data nodes are assigned a numeric id, in sequence starting from 1, in the order they are attached to the cluster. A data node's id is the same as its shard number. Nodes are listed by id by ListNodes and GetMetadata."}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"attachascomputenode",children:"AttachAsComputeNode"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod AttachAsComputeNode(pClusterURL As %String, pHostIPAddress As %String = "") As %Status\n'})}),"\n",(0,a.jsx)(s.p,{children:"Attaches the current InterSystems IRIS instance to a specified cluster as a compute node."}),"\n",(0,a.jsxs)(s.p,{children:["This method automatically and transparently performs all steps needed to enable this instance as a compute node of the specified cluster (subject to these ",(0,a.jsx)(s.a,{href:"#Prerequisites",children:"prerequisites"}),"), including:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Enables the ECP and sharding services, and sets these services' lists of allowed connections to match the lists on the node specified by pClusterURL."}),"\n",(0,a.jsx)(s.li,{children:"Creates the cluster namespace if it doesn't already exist, configuring it to match the settings on the node specified by pClusterURL."}),"\n",(0,a.jsx)(s.li,{children:"Associates this compute node with a data node that previously had the minumum number of associated compute nodes, so as to automatically balance compute nodes across data nodes."}),"\n",(0,a.jsx)(s.li,{children:"Creates all necessary mappings from the cluster namespace to the globals and routines databases of the master namespace on node 1, and to the shard database on the the associated data node."}),"\n",(0,a.jsx)(s.li,{children:"Propagates any user-defined mappings from the master namespace on node 1 to the cluster namespace on the current instance."}),"\n",(0,a.jsx)(s.li,{children:"Sets all SQL configuration options to match their settings on the node specified by pClusterURL."}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"This method returns an error if the current InterSystems IRIS instance is already a node of a sharded cluster."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pClusterURL"})}),"\n",(0,a.jsxs)(s.p,{children:['Identifies the cluster to which to attach, by specifying the address of any existing node of the cluster, in the format "IRIS://',(0,a.jsx)(s.em,{children:"host"}),":",(0,a.jsx)(s.em,{children:"port"}),"/",(0,a.jsx)(s.em,{children:"cluster-namespace"}),'". Namespace may optionally be omitted, since there can be at most one cluster namespace in an InterSystems IRIS instance.']}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pHostIPAddress"})}),"\n",(0,a.jsx)(s.p,{children:"IP address other nodes of this cluster should use to connect to this node. Specify a value for for this parameter if the default hostname known to InterSystems IRIS does not resolve to an appropriate address, or no hostname is available. Default: Default hostname will be used for inter-node connections."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(s.p,{children:"Status code reporting success or failure of this API call."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:'A cluster namespace, with same name as on all other nodes of this cluster, is created if a namespace of that name doesn\'t already exist. Note that if it does already exist, its globals database is "orphaned", as the global database of the cluster namespace is mapped to the globals database of the master namespace on node 1, and a compute node does not need to reuse this database as a shard database.'}),"\n",(0,a.jsx)(s.li,{children:"If the cluster namespace doesn't exist, it is created with interoperability enabled or not according to whether it is enabled for the cluster namespace on the node specified by pClusterURL."}),"\n",(0,a.jsx)(s.li,{children:"All SQL configuration settings are set to match those on the node specified by pClusterURL."}),"\n",(0,a.jsx)(s.li,{children:"Compute nodes are assigned a numeric id, in sequence starting from 1001, in the order they are attached to the cluster. Nodes are listed by id by ListNodes and GetMetadata."}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"attachasmirrorednode",children:"AttachAsMirroredNode"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod AttachAsMirroredNode(pClusterURL As %String, pMemberRole As %String, pHostIPAddress As %String = "", pArbiterIP As %String = "", pArbiterPort As %Integer = 0, pSSLDirectory As %String = "", pMirrorName As %String = "", pMemberName As %String = "") As %Status\n'})}),"\n",(0,a.jsx)(s.p,{children:"Attaches the current InterSystems IRIS instance to a specified cluster as a mirrored data node."}),"\n",(0,a.jsxs)(s.p,{children:["This method automatically and transparently performs all steps needed to enable this instance as a data node of the specified cluster (subject to these ",(0,a.jsx)(s.a,{href:"#Prerequisites",children:"prerequisites"}),"), including:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Enables the ECP and sharding services, and sets the sharding services' lists of allowed connections to match the lists on the node specified by pClusterURL."}),"\n",(0,a.jsxs)(s.li,{children:["If the current instance is not already a member of a mirror, performs mirror configuration according to role specified by pMemberRole:\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:'"primary"'})," Creates a new mirror set, and configures the current instance as its first failover member."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:'"backup"'})," Configures the current instance as the backup failover member of the mirror set whose primary failover member is specified by pClusterURL."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:'"drasync"'})," Configures the current instance as a DR async member of the mirror set whose primary failover member is specified by pClusterURL."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["Creates the cluster namespace and shard database if they don't already exist, configuring them to match the settings on the node specified by pClusterURL. If pMemberRole is ",(0,a.jsx)(s.em,{children:'"backup"'})," and pClusterURL specifies node 1 of this cluster, also creates the master namespace and master database if they don't already exist."]}),"\n",(0,a.jsx)(s.li,{children:'Creates all necessary mappings from the cluster namespace to the globals and routines databases of the master namespace on node 1, and to the shard database on the current instance. (Mappings are not created when pMemberRole is "drasync".)'}),"\n",(0,a.jsx)(s.li,{children:'Propagates any user-defined mappings from the master namespace on node 1 to the cluster namespace on the current instance. (Mappings are not propagated when pMemberRole is "drasync".)'}),"\n",(0,a.jsx)(s.li,{children:"Sets all SQL configuration options to match their settings on the node specified by pClusterURL."}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["If a mirrored node has been flagged for pending removal by calling Detach while sharded tables exist, and the node's removal has not yet been completed by calling the %SYSTEM.Sharding ",(0,a.jsx)(s.strong,{children:"Rebalance"})," method, the pending removal can be cancelled by calling ",(0,a.jsx)(s.strong,{children:"AttachAsMirroredNode"}),". In that case, all parameters except pClusterURL and pMemberRole are ignored. pMemberRole may be specified as either ",(0,a.jsx)(s.em,{children:'"primary"'})," or ",(0,a.jsx)(s.em,{children:'"backup"'}),", regardless of the current instance's current failover role, but if ",(0,a.jsx)(s.em,{children:'"backup"'})," is specified, then an error is returned if pClusterURL does not specify the other failover member of this mirror. Call ListNodes to determine whether a node is flagged for pending removal."]}),"\n",(0,a.jsx)(s.p,{children:"This method returns an error in any of the following cases:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"The current InterSystems IRIS instance is already a node of a sharded cluster."}),"\n",(0,a.jsx)(s.li,{children:"The specified cluster namespace already exists, and its globals database is not mirrored."}),"\n",(0,a.jsxs)(s.li,{children:["pMemberRole is ",(0,a.jsx)(s.em,{children:'"backup"'}),", pClusterURL specifies node 1 of this cluster, and a namespace with the same name as the master namespace already exists, and is not mirrored."]}),"\n",(0,a.jsx)(s.li,{children:"The node specified by pClusterURL is not mirrored."}),"\n",(0,a.jsxs)(s.li,{children:["pMemberRole is ",(0,a.jsx)(s.em,{children:'"backup"'}),", and the node specified by pClusterURL belongs to a mirror set which already has two failover members."]}),"\n",(0,a.jsx)(s.li,{children:"The current instance is a member of an existing mirror set, in a role different from the one specified by pMemberRole."}),"\n",(0,a.jsx)(s.li,{children:"The current instance is a backup or DR async member of a different mirror set than the node specified by pClusterURL."}),"\n",(0,a.jsxs)(s.li,{children:["pMemberRole is ",(0,a.jsx)(s.em,{children:'"backup"'}),', and one of the backup databases created by this method could be caught up within two minutes. This is rare, and is most likely due to a delay in this instance becoming an active mirror backup member (check messages.log for possible causes). In this event, the error message "Cannot catch up database ',(0,a.jsx)(s.em,{children:"dbname"}),', manual catchup required" is returned. The method CatchupDB can be used to perform manual catchup.']}),"\n",(0,a.jsx)(s.li,{children:"The current instance is a node of a sharded cluster, flagged for pending removal, and the node specified by pClusterURL is not a node of the same cluster."}),"\n",(0,a.jsxs)(s.li,{children:["The current instance is a node of a sharded cluster, flagged for pending removal, and pMemberRole is ",(0,a.jsx)(s.em,{children:'"backup"'}),", but pClusterURL does not specify a node of the same cluster."]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pClusterURL"})}),"\n",(0,a.jsxs)(s.p,{children:['Identifies the cluster to which to attach, by specifying the address of am existing node of the cluster, in the format "IRIS://',(0,a.jsx)(s.em,{children:"host"}),":",(0,a.jsx)(s.em,{children:"port"}),"/",(0,a.jsx)(s.em,{children:"cluster-namespace"}),'". Namespace may optionally be omitted, since there can be at most one cluster namespace in an InterSystems IRIS instance. If pMemberRole is ',(0,a.jsx)(s.em,{children:'"primary"'}),", pClusterURL may specify any existing node. If pMemberRole is ",(0,a.jsx)(s.em,{children:'"backup"'}),", pClusterURL must specify the node which is the primary failover member of the mirror set for which the current instance will be attached as the backup failover member."]}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.em,{children:"pMemberRole"})," This node's role as a mirror member:"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:'"primary"'})," Attach as primary failover member."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:'"backup"'})," Attach as backup failover member of mirror whose primary failover member is specified by pClusterURL."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:'"drasync"'})," Attach as DR async member of mirror whose primary failover member is specified by pClusterURL."]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pHostIPAddress"})}),"\n",(0,a.jsx)(s.p,{children:"IP address other nodes of this cluster should use to connect to this node. Specify a value for for this parameter if the default hostname known to InterSystems IRIS does not resolve to an appropriate address, or no hostname is available. Default: Default hostname will be used for inter-node connections."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pArbiterIP"})}),"\n",(0,a.jsxs)(s.p,{children:["Arbiter's hostname or IP address. Specify a non-null value to configure this mirror to use an arbiter, overriding the value inherited from the node specified by ",(0,a.jsx)(s.em,{children:"pClusterURL"}),". Ignored when attaching a backup failover member."]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pArbiterPort"})}),"\n",(0,a.jsxs)(s.p,{children:["Arbiter's port. Specify a non-zero value to configure this mirror to use an arbiter, overriding the value inherited from the node specified by ",(0,a.jsx)(s.em,{children:"pClusterURL"}),". Ignored when attaching a backup failover member."]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pSSLDirectory"})}),"\n",(0,a.jsxs)(s.p,{children:["SSL/TLS keys directory. Specify a non-null value to configure this mirror to use SSL/TLS, overriding the value inherited from the node specified by ",(0,a.jsx)(s.em,{children:"pClusterURL"}),'. Directory is expected to contain three files named "CAFile.pem", "CertificateFile.pem, and "PrivateKeyFile.pem".']}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pMirrorName"})}),"\n",(0,a.jsxs)(s.p,{children:["Name of mirror set to create. Default: IRISMIRROR_N_, where ",(0,a.jsx)(s.em,{children:"N"})," is a mirror naming sequence number unique within this cluster (usually the same as the node id)."]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pMemberName"})}),"\n",(0,a.jsx)(s.p,{children:"Name by which this instance is known to the mirror. Default: The mirror name, with the letter 'A' appended for the primary failover member, or 'B' for the backup failover member."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(s.p,{children:"Status code reporting success or failure of this API call."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["Mirrored data nodes are always paired, and both members of a pair are assigned the same node id. Each instance of the pair is attached by a separate call to AttachAsMirroredNode, specifying pMemberRole as ",(0,a.jsx)(s.em,{children:'"primary"'})," for the first node attached, and as ",(0,a.jsx)(s.em,{children:'"backup"'})," for the second node attached. These specify the initial roles, which are swapped when the mirror fails over. Use ListNodes to determine the current member roles of all mirrored nodes."]}),"\n",(0,a.jsx)(s.li,{children:"If the current instance is already a mirror member, the mirror configuration parameters (pArbiterIP, pArbiterPort, pSSLDirectory, pMirrorName, and pMemberName) are ignored, and the mirror configuration is not modified."}),"\n",(0,a.jsx)(s.li,{children:"If any of the arguments pArbiterIP, pArbiterPort, or pSSLDirectory is not specified, the values configured for the node specified by pClusterURL are used."}),"\n",(0,a.jsx)(s.li,{children:"Recommended best practice is to attach both failover members of a mirror set, before storing any data in the cluster database. In the case of creating a new mirror set, data stored in the primary member is not backed up until the backup member has been attached. In the case of attaching the failover members of an existing mirror set, if only the primary failover member has been attached, and the mirror fails over, sharded operations on the cluster cannot access data on other failover member that has been promoted from backup to primary, until it has been attached to the cluster."}),"\n",(0,a.jsx)(s.li,{children:"When attaching the failover members of an existing mirrored set, attach the current primary member first, then the current backup member. The node being attached as primary must actually be primary at the time it is attached, and the node being attached as backup must actually be backup at the time it is attached."}),"\n",(0,a.jsx)(s.li,{children:"A cluster namespace, with same name as on all other nodes of this cluster, is created if a namespace of that name doesn't already exist. If it does already exist, its globals database becomes the shard database for this node."}),"\n",(0,a.jsx)(s.li,{children:"If the node specified by pClusterURL is a data node, it is used as the template for configuration settings on this node. If the specified node is a compute node, the corresponding data node is used as the template."}),"\n",(0,a.jsx)(s.li,{children:"If the cluster namespace doesn't exist, it is created with interoperability enabled or not according to whether it is enabled for the cluster namespace on the template node, and with its globals database settings, including directory path, matching those of the shard database on the template node."}),"\n",(0,a.jsx)(s.li,{children:"All SQL configuration settings are set to match those on the template node."}),"\n",(0,a.jsx)(s.li,{children:"Data nodes are assigned a numeric id, in sequence starting from 1, in the order they are attached to the cluster. A data node's id is the same as its shard number. Nodes are listed by id by ListNodes and GetMetadata."}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"attach",children:"Attach"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod Attach(pNodeType As %String = "", pClusterURL As %String, pHostIPAddress As %String = "", pMemberRole As %String = "primary", pArbiterIP As %String = "", pArbiterPort As %Integer = 0, pSSLDirectory As %String = "", pMirrorName As %String = "", pMemberName As %String = "") As %Status [ Internal, Private ]\n'})}),"\n",(0,a.jsx)(s.h3,{id:"swapdatabases",children:"SwapDatabases"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod SwapDatabases(pNamespace1 As %String, pNamespace2 As %String) As %Status [ Internal, Private ]\n"})}),"\n",(0,a.jsx)(s.h3,{id:"createorreusedatabase",children:"CreateOrReuseDatabase"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod CreateOrReuseDatabase(pDbNameSubscript As %String, pDbNameDefault As %String, ByRef pDbName As %String, ByRef pTemplateProperties) As %Status [ Internal, Private ]\n"})}),"\n",(0,a.jsx)(s.h3,{id:"catchupdbinternal",children:"CatchupDBInternal"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod CatchupDBInternal(pDbName As %String, pPath As %String = "", pPass = 1) As %Status [ Internal, Private ]\n'})}),"\n",(0,a.jsx)(s.h3,{id:"catchupdb",children:"CatchupDB"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod CatchupDB(pDbName As %String) As %Status\n"})}),"\n",(0,a.jsxs)(s.p,{children:['Catches up the database specified by pDbName. Call this method if AttachAsMirroredNode returns the error message "Cannot catch up database ',(0,a.jsx)(s.em,{children:"dbname"}),', manual catchup required".']}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pDbName"})}),"\n",(0,a.jsx)(s.p,{children:"The name of the database to catch up."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(s.p,{children:"Status code reporting success or failure of this API call."}),"\n",(0,a.jsx)(s.h3,{id:"getdbpropsfornamespace",children:"GetDbPropsForNamespace"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod GetDbPropsForNamespace(pNamespace As %String, pDbNameSubscript As %String, pDbNameDefault As %String, ByRef pProperties, ByRef pNamespaceExists As %Boolean, ByRef pNamespaceIsInteropEnabled As %Boolean) As %Status [ Internal, Private ]\n"})}),"\n",(0,a.jsx)(s.h3,{id:"clusternamespace",children:"ClusterNamespace"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod ClusterNamespace() As %String\n"})}),"\n",(0,a.jsx)(s.p,{children:"Gets the name of the cluster namespace on the current InterSystems IRIS instance."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(s.p,{children:"Name of the cluster namespace, or empty string if this instance is not a node in a cluster."}),"\n",(0,a.jsx)(s.h3,{id:"listnodes",children:"ListNodes"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod ListNodes(pOutputFile As %String = "") As %Status\n'})}),"\n",(0,a.jsx)(s.p,{children:"Lists the nodes of the cluster to which the current InterSystems IRIS instance belongs, to the console or to a specified output file."}),"\n",(0,a.jsx)(s.p,{children:"The list contains a row for each node, with information in columns under the following headings:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"NodeId - a numeric id. For data nodes, this is identical to the shard number."}),"\n",(0,a.jsx)(s.li,{children:'NodeType - "Data" or "Compute".'}),"\n",(0,a.jsx)(s.li,{children:"DataNodeId - for compute nodes only, the id of the corresponding data node."}),"\n",(0,a.jsx)(s.li,{children:"Host - the hostname or IP address of the machine hosting the node's InterSystems IRIS instance."}),"\n",(0,a.jsx)(s.li,{children:"Port - the default port (Super Server port) of the InterSystems IRIS instance."}),"\n",(0,a.jsx)(s.li,{children:"Mirror - the mirror name, if the node is mirrored."}),"\n",(0,a.jsx)(s.li,{children:'Failover - for mirrored nodes only, the type of failover member, either "Primary" or "Backup".'}),"\n",(0,a.jsxs)(s.li,{children:["VIP - for mirrored nodes only, the VIP, if one is configured.\n",(0,a.jsx)(s.strong,{children:"Parameters:"})]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pOutputFile"})}),"\n",(0,a.jsx)(s.p,{children:"The pathname of a file to which output is written. Default: Prints output to the console."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(s.p,{children:"Status code reporting success or failure of this API call."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:'Nodes which are pending removal, because they have been detached but the cluster has not yet been rebalanced to moved sharded data from them to other shards, are listed with their shard number in brackets and followed by two asterisks, for example "[25**]".'}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"getmetadata",children:"GetMetadata"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod GetMetadata(ByRef pMetadata) As %Status\n"})}),"\n",(0,a.jsx)(s.p,{children:"Retrieves an overview of the metadata of the cluster to which the current InterSystems IRIS instance belongs."}),"\n",(0,a.jsx)(s.p,{children:"The metadata is returned in an array, passed by reference, under the following subscripts:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"ClusterNamespace - the name of the cluster namespace, visible on all nodes."}),"\n",(0,a.jsx)(s.li,{children:"MasterNamespace - the name of the master namespace on node 1."}),"\n",(0,a.jsx)(s.li,{children:"MasterGlobalsDatabase - the name of the globals database of the master namespace."}),"\n",(0,a.jsx)(s.li,{children:"MasterRoutinesDatabase - the name of the routines database of the master namespace."}),"\n",(0,a.jsxs)(s.li,{children:['Node - information specific to individual nodes, stored under two additional subscripts: the node\'s numeric id (with ":Primary" or ":Backup" appended for mirrored nodes), and one of the following:\n',(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:'NodeType - "Data" or "Compute".'}),"\n",(0,a.jsx)(s.li,{children:"DataNodeId - for compute nodes only, the id of the corresponding data node."}),"\n",(0,a.jsx)(s.li,{children:"ShardDatabase - for data nodes only, the name of the database containing this node's portion of sharded data."}),"\n",(0,a.jsx)(s.li,{children:"Host - the hostname or IP address of the machine hosting the node's InterSystems IRIS instance."}),"\n",(0,a.jsx)(s.li,{children:"SuperServerPort - the default port (Super Server port) of the InterSystems IRIS instance."}),"\n",(0,a.jsx)(s.li,{children:"WebServerPort - the web server port of the InterSystems IRIS instance."}),"\n",(0,a.jsx)(s.li,{children:"IRISVersion - the InterSystems IRIS version number."}),"\n",(0,a.jsxs)(s.li,{children:["ShardingVersion - the sharding manager version number.\n",(0,a.jsx)(s.strong,{children:"Parameters:"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.em,{children:"pMetadata"})}),"\n",(0,a.jsx)(s.p,{children:"Array in which metadata is returned, passed by reference."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(s.p,{children:"Status code reporting success or failure of this API call."}),"\n",(0,a.jsx)(s.h3,{id:"createmirror",children:"CreateMirror"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod CreateMirror(pMirrorSetName As %String = "", pPrimaryName As %String = "", pPrimaryIP As %String = "", pBackupName As %String = "", pBackupIP As %String = "", pAgentPort As %Integer = "", pNodeType As %String = "", pInstance As %String = "", pArbiterIP As %String = "", pArbiterPort As %Integer = 0, pSSLdir As %String = "") As %String [ Internal, Private ]\n'})}),"\n",(0,a.jsxs)(s.p,{children:["Create a mirror member on the designated instance",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"pMirrorSetName"})," Mirror Set name",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"pPrimaryName"})," Primary member name",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"pPrimaryIP"})," Primary member IP address",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"pBackupName"})," Backup member name",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"pBackupIP"})," Backup member IP address",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"pAgentPort"})," ISC Agent Port",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"pNodeType"}),' "primary" | "backup" | "async"',(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"pInstance"})," Instance name",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"pArbiterIP"})," Arbiter Node IP address",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"pArbiterPort"})," Arbiter Node port number",(0,a.jsx)(s.br,{}),"\n",(0,a.jsx)(s.strong,{children:"pSSLdir"})," SSL/TLS keys directory"]}),"\n",(0,a.jsx)(s.h3,{id:"isnodeready",children:"IsNodeReady"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:'ClassMethod IsNodeReady(pClusterURL As %String = "") As %Status\n'})}),"\n",(0,a.jsx)(s.h3,{id:"detach",children:"Detach"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-objectscript-class",children:"ClassMethod Detach() As %Status\n"})}),"\n",(0,a.jsx)(s.p,{children:"Detaches the current InterSystems IRIS instance from the cluster to which it is currently attached. This removes the instance from the cluster's set of nodes."}),"\n",(0,a.jsx)(s.p,{children:"This API call can be used to detach a data node (either mirrored on non-mirrored) or a compute node."}),"\n",(0,a.jsx)(s.p,{children:"If the current instance is a data node, and any sharded tables exist, the instance is not immediately detached, but is flagged for pending removal. In that case, the next call to the Rebalance method of %SYSTEM.Sharding moves any sharded data from this node to other nodes of the cluster, and completes the process of detaching this instance. Node 1 of a cluster may not be detached."}),"\n",(0,a.jsx)(s.p,{children:"If the current instance is a compute node, it is always immediately detached."}),"\n",(0,a.jsxs)(s.p,{children:["Calling ",(0,a.jsx)(s.strong,{children:"Detach"})," on either failover member of a mirrored data node detaches both failover members"]}),"\n",(0,a.jsx)(s.p,{children:"Detaching a data node automatically detaches any compute nodes that are associated with that data node. This method returns an error in any of the following cases:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"The current InterSystems IRIS instance is not a node of a sharded cluster."}),"\n",(0,a.jsx)(s.li,{children:"The current instance is node 1 of a sharded cluster."}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Returns:"})}),"\n",(0,a.jsx)(s.p,{children:"Status code reporting success or failure of this API call."}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Notes:"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Detaching a node removes mappings that were created when the node was attached. It does not remove the cluster namespace, but causes that namespace to no longer serve as a cluster namespace. If the instance is mirrored, detaching does not remove the instance from the mirror."}),"\n",(0,a.jsxs)(s.li,{children:["When a data node is flagged for pending removal, due to calling ",(0,a.jsx)(s.strong,{children:"Detach"})," while sharded tables exist, the pending removal can be cancelled by calling AttachAsDataNode (for a non-mirrored data node), AttachAsMirroredNode (for a mirrored data node), or AttachAsComputeNode (for a compute node). Call ListNodes to determine whether a node is currently flagged for pending removal."]}),"\n",(0,a.jsxs)(s.li,{children:["When a node is detached, the node numbers of any higher-numbered nodes are decremented to maintain an unbroken numeric sequence. If the node is flagged for pending removal, the numbers of higher-numbered nodes aren't changed until the process of detaching the node is completed during the next call to the %SYSTEM.Sharding ",(0,a.jsx)(s.strong,{children:"Rebalance"})," method."]}),"\n"]})]})}function c(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>i,x:()=>o});var a=t(96540);const n={},r=a.createContext(n);function i(e){const s=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(r.Provider,{value:s},e.children)}}}]);