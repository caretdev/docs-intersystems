"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[33296],{37935:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>i,default:()=>d,frontMatter:()=>s,toc:()=>o});var r=n(74848),a=n(28453);const s={pagination_prev:null,pagination_next:null},i="%iFind.Transformation.Abstract",o=[{value:"Methods",id:"methods",level:2},{value:"Transform",id:"transform",level:3},{value:"TransformObject",id:"transformobject",level:3}];function c(e){const t={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"ifindtransformationabstract",children:"%iFind.Transformation.Abstract"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Class %iFind.Transformation.Abstract Extends %RegisteredObject [ Abstract, System = 4 ]\n"})}),"\n",(0,r.jsx)(t.p,{children:'This class abstracts a Word Transformation, an operation that translates a given actual word (as found in a document to be indexed) in some more "normalized" form. For example, stemming normalizes verbs, nouns and other conjugated words by transforming them into their base form (= normalized form). When a user then wants to search for a conjugated word, the search query will be processed by the same transformation used at indexing time and any conjugated form that maps to the same base form will be considered a match.'}),"\n",(0,r.jsx)(t.p,{children:"The transformation(s) to be applied at indexing time can be supplied through the TRANSFORMATIONSPEC index parameter (see %iFind.Index.Basic). At search time, the search option argument can be used to identify which transformation to apply to the search string. This can be either one of these transformation specification strings defined in the index parameter, an asterisk (*) to identify the default transformation of the index parameter or 0 to do an exact search on the non- transformed string."}),"\n",(0,r.jsx)(t.p,{children:"Custom transformations can be created by implementing this class and implementing the Transform method. This class can then be referred in the TRANSFORMATIONSPEC index parameter as described above."}),"\n",(0,r.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(t.h3,{id:"transform",children:"Transform"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:'ClassMethod Transform(Output pTransformed As %String, ByRef pString As %String, pArguments As %String = "", pLanguage As %String = "") As %Status [ Abstract ]\n'})}),"\n",(0,r.jsxs)(t.p,{children:['This method transforms pString into a "normalized" form pTransformed, based on the language context pLanguage.',(0,r.jsx)(t.br,{}),"\nImplementations of this class can optionally be parameterized through the pArguments string, which can be supplied through the TRANSFORMATIONSPEC index parameter. Transformations in this method should match the transformations in TransformObject(), notwithstanding the use of wildcards, or unexpected behavior can occur."]}),"\n",(0,r.jsx)(t.h3,{id:"transformobject",children:"TransformObject"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:'ClassMethod TransformObject(Output pTransformed, ByRef pString As %DynamicObject, pArguments As %String = "", pLanguage As %String = "") As %Status [ Abstract ]\n'})}),"\n",(0,r.jsxs)(t.p,{children:['This method transforms pStringinto a "normalized" form pTransformed, based on the language context pLanguage.',(0,r.jsx)(t.br,{}),'\nImplementations of this class can optionally be parameterized through the pArguments string, which can be supplied through the TRANSFORMATIONSPEC index parameter. This method takes in pString as a %DynamicObject, with the search string contained in pString.query. pString also contains a mask in pString.mask, where $c(0) in a character\'s slot represents a wildcard. For example, if pString.query = "?ab?" and pString.mask = "?ab_$c(0)", the first ? is a literal character, and the second is a wildcard. Unlike the Transform() method, pString may contain wildcards/ pTransformed may contain wildcards, but if so the user must implement pTransformed as a %DynamicObject, with the transformed search string stored in the "query" key. Note that a user MUST implement a mask for each transformaton in pTransformed that they wish to include wildcards with, or the wildcards in the transformations will be treated as escaped literals. Transformations in this method should match the transformations in Transform(), notwithstanding the use of wildcards, or unexpected behavior can occur.']})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var r=n(96540);const a={},s=r.createContext(a);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);