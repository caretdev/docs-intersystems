"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[4701],{80171:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>s,default:()=>a,frontMatter:()=>r,toc:()=>c});var o=n(74848),i=n(28453);const r={pagination_prev:null,pagination_next:null},s="%SYSTEM.Socket",c=[{value:"Methods",id:"methods",level:2},{value:"Export",id:"export",level:3},{value:"Fork",id:"fork",level:3},{value:"Import",id:"import",level:3},{value:"Publish",id:"publish",level:3},{value:"Select",id:"select",level:3},{value:"SelectInterrupt",id:"selectinterrupt",level:3}];function d(e){const t={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"systemsocket",children:"%SYSTEM.Socket"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-objectscript-class",children:"Class %SYSTEM.Socket Extends Help [ System = 4 ]\n"})}),"\n",(0,o.jsx)(t.p,{children:"The %SYSTEM.Socket class provides an interface for multiplexing TCP devices."}),"\n",(0,o.jsx)(t.p,{children:"You could use Fork and Select methods to have one job handle accepting new connection and reading data from connected TCP device at the same time."}),"\n",(0,o.jsx)(t.p,{children:"After a listening TCP device receives a connection, we could use Fork to create a new TCP device for reading data. The original listening TCP device could continue to accept an incoming connection. Then you could use the Select method to wait for both listening and connected TCP device. When a new connect request arrives or incoming data becomes available, the Select will return with the device name which was signaled."}),"\n",(0,o.jsxs)(t.p,{children:['`` Set ListenDev="|TCP|1" Open ListenDev:(:9999:"SA") Set SelectDev=$LB(ListenDev),DevNameIndex=1 While (1) { Set ReturnDev=$SYSTEM.Socket.Select(SelectDev) For i=1:1:$ListLength(ReturnDev) { Set Dev=$Li(ReturnDev) If Dev=ListenDev { /* This is the listening device, so it is a new connection. ',(0,o.jsx)(t.em,{children:'/ Set ConnectedDev="|TCP|"_$Increment(DevNameIndex) If \'$SYSTEM.Socket.Fork(Dev,ConnectedDev) { /'})," Failed to create new device, log error here and continue ",(0,o.jsx)(t.em,{children:"/ Continue } /"})," Put this new device in the select list. ",(0,o.jsx)(t.em,{children:"/ Set SelectDev=SelectDev_$LB(ConnectedDev) } Else { /"})," This is a connected device, so data is available to read. ",(0,o.jsx)(t.em,{children:"/ /"})," Note that if remote closed the connection, this read command would get a  error. ",(0,o.jsx)(t.em,{children:"/ /"})," And you need to close this device and remove it from the 'SelectDev' list */ Use Dev Read Data Continue } } }"]}),"\n",(0,o.jsxs)(t.p,{children:["Use Select, Publish, Export and Import methods to have a listener job accepting incoming connection and pass the connected device to worker job so the worker job could communicate with the remote client. The listener job could pass more than one connected devices to the worker job and the worker job could use Select to handle more than one connected devices.",(0,o.jsx)(t.br,{}),"\nThe example code for listener job:",(0,o.jsx)(t.code,{children:"/* Assume we already know the process ID of the worker job 'WorkerPID'. */ /* Note that you could have more than one worker jobs to handle incoming connections. */ S ListenDev=\"|TCP|1\",WorkerPID=\"A Process' PID\" Open ListenDev:(:9999:\"SA\") While (1) { Use ListenDev Read Data /* A new connection came in, create the Token to be passed to the worker. */ Set Token=$SYSTEM.Socket.Publish(ListenDev,WorkerPID) /* Pass the 'Token' to the worker job through the ^TCPConnect(WorkerPID) nodes. */ Set ^TCPConnect(WorkerPID,$Increment(^TCPConnect(WorkerPID)))=Token /* Wake up the worker job in case it is waiting in $SYSTEM.Socket.Select(). */ Set RC=$SYSTEM.Socket.SelectInterrupt(WorkerPID) /* Oops, the worker job is gone. Close it and continue. */ if 'RC { /* Disconnect the connection. */ Use ListenDev Write *-2 Continue } /* An important note for VMS platform, you need to call Export() method */ /* after you are sure the worker already called the Import() method(). */ /* Otherwise the Import() call on worker job will fail. */ Set RC=$SYSTEM.Socket.Export(ListenDev) /* Oops, could not export the device. Close it and continue. */ if 'RC { /* Disconnect the connection. */ Use ListenDev Write *-2 Continue } }"}),(0,o.jsx)(t.br,{}),"\nThe example code for worker job: /* Assume the worker job already have a TCP device (FirstDev) passed from listener job through JOB command. ",(0,o.jsx)(t.em,{children:'/ Set SelectDev=$LB(FirstDev),DevNameIndex=0,MyPID=$P($J,":") While (1) { /'})," Wait for the read to be read with 10 seconds time out. ",(0,o.jsx)(t.em,{children:'/ Set ReturnDev=$SYSTEM.Socket.Select(SelectDev,10) If ReturnDev="" { /'})," The Select() must be timed out. Do whatever it needs to do then continue to read. ",(0,o.jsx)(t.em,{children:"/ Continue } If ReturnDev=-1 { /"})," The Select() was interrupted, there must be a new connection passed from listener job ",(0,o.jsx)(t.em,{children:'/ Set Index=$O(^TCPConnect(MyPID,""),1,Token) /'})," If no device in the global then this might be a false alarm, continue. ",(0,o.jsx)(t.em,{children:'/ If Index="" Continue Set ConnectedDev="|TCP|"_$Increment(DevNameIndex) Set RC=$SYSTEM.Socket.Import(ConnectedDev,Token) If \'RC { /'})," Failed to import the device, clean up and continue. ",(0,o.jsx)(t.em,{children:"/ Kill ^TCPConnect(MyPID,Index) Continue } /"})," Put this new device in the select list and continue to read. ",(0,o.jsx)(t.em,{children:"/ Set SelectDev=SelectDev_$LB(ConnectedDev) Kill ^TCPConnect(MyPID,Index) /"})," Important note that for VMS platform, you need to signal listener job that ",(0,o.jsx)(t.em,{children:"/ /"})," you have called Import() method so it could call Export(). ",(0,o.jsx)(t.em,{children:"/ Continue } For i=1:1:$ListLength(ReturnDev) { Set Dev=$Li(ReturnDev) /"})," This is a connected device, so data is available to read. ",(0,o.jsx)(t.em,{children:"/ /"})," Note that if remote closed the connection, this read command would get  error. ",(0,o.jsx)(t.em,{children:"/ /"})," And you need to close this device and remove it from the 'SelectDev' list */ Use Dev Read Data Continue } }  ``"]}),"\n",(0,o.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,o.jsx)(t.h3,{id:"export",children:"Export"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Export(AcceptedDevice As %String) As %Boolean\n"})}),"\n",(0,o.jsx)(t.p,{children:"Export a socket handle of an accepted TCP device."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Parameters:"}),(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"AcceptedDevice"})," - The name of a TCP device that has accepted an incoming connection."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Return:"}),(0,o.jsx)(t.br,{}),"\nThis method returns 1 if succeeds, otherwise returns 0."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Usage:"}),(0,o.jsx)(t.br,{}),"\nThis method is called by a donor after a published token is passed to the recipient job.",(0,o.jsx)(t.br,{}),"\nIt cleaned up the socket handle in the accepted TCP device so it could go back to accept another incoming connection.",(0,o.jsx)(t.br,{}),"\nFor Windows platform, this method does not interact with the recipient job. For UNIX platform, internally it waits for the recipient job to connect to it through UNIX domain so the socket handle could be passed to the recipient job through it.",(0,o.jsx)(t.br,{}),"\nFor OpenVMS platform, it is needed to make sure the Import method is called by the recipient job before this method is called, otherwise the Import will fail on the recipient job."]}),"\n",(0,o.jsx)(t.h3,{id:"fork",children:"Fork"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Fork(AcceptedDevice As %String, NewDevice As %String) As %Boolean\n"})}),"\n",(0,o.jsx)(t.p,{children:"Create another TCP device from an accepted TCP device within the same job."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Parameters:"}),(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"AcceptedDevice"})," - The name of a TCP device that has accepted an incoming connection.",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"NewDevice"})," - The name of a TCP device that is created and a socket handle is passed to it from the AcceptedDevice."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Return:"}),(0,o.jsx)(t.br,{}),"\nThis method returns 1 if succeeds, otherwise returns 0."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Usage:"}),(0,o.jsx)(t.br,{}),"\nCombined with the Select method, one job could handle more than one incoming TCP connection while accepting new connection to arrive.",(0,o.jsx)(t.br,{}),"\nThe NewDevice must not be opened before this call. After this call the remote end will communicate with the NewDevice."]}),"\n",(0,o.jsx)(t.h3,{id:"import",children:"Import"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Import(NewDevice As %String, Token As %String) As %Boolean\n"})}),"\n",(0,o.jsx)(t.p,{children:"Create a TCP device with a token passed from the donor job."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Parameters:"}),(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"NewDevice"})," - The name of a TCP device that is created and a socket handle is generated from the Token.",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"Token"})," - A token passed from the donor job to create a TCP device. It was generated from the Publish method by the donor job."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Return:"}),(0,o.jsx)(t.br,{}),"\nThis method returns 1 if succeeds, otherwise returns 0."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Usage:"}),(0,o.jsx)(t.br,{}),"\nThis method is called by a recipient after it received a published token from the donor job.",(0,o.jsx)(t.br,{}),"\nIt creates the NewDevice TCP device by using the socket handle generated from the Token.",(0,o.jsx)(t.br,{}),"\nThe NewDevice must not be opened before this call. After this call the remote end will communicate with the NewDevice."]}),"\n",(0,o.jsx)(t.p,{children:"For Windows platform, this method does not interact with the donor job."}),"\n",(0,o.jsx)(t.p,{children:"For UNIX platform, internally it connects to the donor job through UNIX domain to get the socket handle."}),"\n",(0,o.jsx)(t.p,{children:"For OpenVMS platform, it is needed to make sure the Export method is called by the donor job after this method is called, otherwise the Import will fail."}),"\n",(0,o.jsx)(t.h3,{id:"publish",children:"Publish"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Publish(AcceptedDevice As %String, RecipientPID As %Integer) As %String\n"})}),"\n",(0,o.jsx)(t.p,{children:"Publish a token from an accepted TCP device."}),"\n",(0,o.jsxs)(t.p,{children:["If the TCP device was opened with the /SSL option and data has been exchanged in this device then this Publish method will get an  error. If there is no data exchanged yet then the Import on the recipient will open the device with /SSL option implicitly.",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"Parameters:"}),(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"AcceptedDevice"})," - The name of a TCP device that has accepted an incoming connection.",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"RecipientPID"})," - Process ID of the recipient job. Only Windows platform uses this value."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Return:"}),(0,o.jsx)(t.br,{}),"\nReturn a Token for this accepted TCP device."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Usage:"}),(0,o.jsx)(t.br,{}),"\nThe Token generated by this Publish method is passed to a recipient job to create a TCP device to communicate with the remote end."]}),"\n",(0,o.jsx)(t.h3,{id:"select",children:"Select"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Select(DeviceList As %List, Timeout As %Decimal) As %List\n"})}),"\n",(0,o.jsx)(t.p,{children:"Check a list of TCP devices whether any devices are ready for read, it includes the listening TCP device."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Parameters:"}),(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"DeviceList"})," - A list of TCP devices (in ",(0,o.jsx)(t.a,{href:"/csp/docbook/Doc.View.cls?FIND=OBJECTSCRIPT+$LIST+FUNCTION",children:"$LIST"})," format) to be checked, the devices have to be either connected or in the listening state.",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"Timeout"})," - A timeout value in seconds for this method to wait. It can be integer or decimal values, it can be down to 100th seconds. A negative value or omit this parameter will be treated as no timeout."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Return:"}),(0,o.jsx)(t.br,{}),"\nReturn a list of TCP devices (in $LIST format) that are ready to read.",(0,o.jsx)(t.br,{}),"\nReturn a null string if it is timed out.",(0,o.jsx)(t.br,{}),"\nReturn -1 if it is interrupted by SelectInterrupt",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"Usage:"}),(0,o.jsx)(t.br,{}),"\nThe devices in the list could be a TCP device which has been connected or a TCP device in the listening state and waiting for incoming connection.",(0,o.jsx)(t.br,{}),"\nWhen a listening TCP device is returned then this device is ready to receive data from remote end, but there might be no data to read. Internally the accept task is performed.",(0,o.jsx)(t.br,{}),"\nFor a connected TCP device, the next read command should return some data.",(0,o.jsx)(t.br,{}),"\nThe caller should check for null string and -1 for timed out or interruption before you could use the devices returned from the list.",(0,o.jsx)(t.br,{}),"\nThe limit of the total number of TCP device in the list is 64. But for Windows platform one slot is reserved for interrupting the waiting. For a device waiting for accepting an incoming connection it might take two slots if IPV6 is enabled."]}),"\n",(0,o.jsx)(t.h3,{id:"selectinterrupt",children:"SelectInterrupt"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod SelectInterrupt(ProcessID As %Integer) As %Integer\n"})}),"\n",(0,o.jsx)(t.p,{children:"Interrupt a process waiting in %SYSTEM.Socket.Select()."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Parameters:"}),(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"ProcessID"})," - The process's PID to be interrupted."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Return:"}),(0,o.jsx)(t.br,{}),"\nReturn one if succeed, zero if failed.",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"Usage:"}),(0,o.jsx)(t.br,{}),"\nThis function is used to make a process break out of Select method so it could continue to do other works.",(0,o.jsx)(t.br,{}),"\nIf the process is not waiting in Select method while it is interrupted then when the process calls Select method it would return null string if it has to wait in Select method.",(0,o.jsx)(t.br,{}),"\nThe interrupted Select method could return null string if no device is ready to read data."]})]})}function a(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>c});var o=n(96540);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);