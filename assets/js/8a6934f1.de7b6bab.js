"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[98859],{43954:(e,t,s)=>{s.r(t),s.d(t,{contentTitle:()=>a,default:()=>l,frontMatter:()=>n,toc:()=>i});var o=s(74848),r=s(28453);const n={pagination_prev:null,pagination_next:null},a="%DeepSee.ListingGroupProjection",i=[{value:"Methods",id:"methods",level:2},{value:"CreateProjection",id:"createprojection",level:3},{value:"RemoveProjection",id:"removeprojection",level:3}];function c(e){const t={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"deepseelistinggroupprojection",children:"%DeepSee.ListingGroupProjection"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-objectscript-class",children:"Class %DeepSee.ListingGroupProjection Extends %Projection.AbstractProjection [ System = 3 ]\n"})}),"\n",(0,o.jsx)(t.p,{children:"Projection class used by the %DeepSee.ListingGroupDefinition class. This class takes care of any work that needs to happen when a listing group definition is created (compiled) or deleted. This class should be considered INTERNAL."}),"\n",(0,o.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,o.jsx)(t.h3,{id:"createprojection",children:"CreateProjection"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod CreateProjection(pClassName As %String, ByRef parameters As %String, modified As %String, qstruct) As %Status\n"})}),"\n",(0,o.jsxs)(t.p,{children:['This method is called by the Class Compiler whenever an associated class has finished compiling. classname contains the name of the associated class while parameters contains an array of the projection parameters subscripted by parameter name. Also the special parameter value parameters("%qstruct") contains a merge of the qstruct array this projection is being compiled with. The modified for an incremental compile will contain a comma separated list of the methods that were modified and it will be blank for a full compile',(0,o.jsx)(t.br,{}),"\nAny errors reported by this method are reported by the Class Compiler but do not effect class compilation in any way."]}),"\n",(0,o.jsx)(t.h3,{id:"removeprojection",children:"RemoveProjection"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod RemoveProjection(pClassName As %String, ByRef parameters As %String, recompile As %Boolean, modified As %String, qstruct) As %Status\n"})}),"\n",(0,o.jsxs)(t.p,{children:['This method is called by the Class Compiler whenever an associated class is either a) about to be recompiled, or b) about to be deleted. classname contains the name of the associated class while parameters contains an array of the projection parameters subscripted by parameter name. Also the special parameter value parameters("%qstruct") contains a merge of the qstruct array this projection is being compiled with. recompile is true (1) if the associated class is about to be recompiled. The modified for an incremental compile will contain the comma separated list of methods that were modified and will be blank for a full compiler.',(0,o.jsx)(t.br,{}),"\nAny errors reported by this method are reported by the Class Compiler but do not effect class compilation in any way."]})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>i});var o=s(96540);const r={},n=o.createContext(r);function a(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);