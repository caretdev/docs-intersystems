"use strict";(self.webpackChunkdocs_intersystems=self.webpackChunkdocs_intersystems||[]).push([[38247],{56772:(e,t,s)=>{s.r(t),s.d(t,{contentTitle:()=>c,default:()=>l,frontMatter:()=>n,toc:()=>a});var r=s(74848),o=s(28453);const n={pagination_prev:null,pagination_next:null},c="%Monitor.Process",a=[{value:"Methods",id:"methods",level:2},{value:"Enable",id:"enable",level:3},{value:"Disable",id:"disable",level:3},{value:"Clear",id:"clear",level:3},{value:"Report",id:"report",level:3},{value:"Metrics",id:"metrics",level:3},{value:"Status",id:"status",level:3}];function i(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"monitorprocess",children:"%Monitor.Process"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"Class %Monitor.Process [ Abstract, System = 4 ]\n"})}),"\n",(0,r.jsx)(t.p,{children:"The methods here control the Process Monitor which allow a programmer to capture metrics for the current process. The metrics are the same counters as captured by the PERFMON utility, but they are only captured for the current process and stored in the process local memory. This ensures that it has minimal effect on the rest of the system."}),"\n",(0,r.jsx)(t.p,{children:"Application programmers can embed the methods in their code, so that the Process Monitor can be enabled and metrics reported by user processes, allowing them to analyze trouble spots on live systems."}),"\n",(0,r.jsx)(t.p,{children:"Note that all of the counters are either 32 or 64-bit counters, according to the word length of the platform, and follow the SNMP Counter32 and Counter64 semantics defined in RFC1442. Application code which subtracts a previous value from the current value must take into account the possible wrap around back to zero. All counters for a process may be initialized to zero using Clear()."}),"\n",(0,r.jsx)(t.h2,{id:"methods",children:"Methods"}),"\n",(0,r.jsx)(t.h3,{id:"enable",children:"Enable"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Enable() As %Status\n"})}),"\n",(0,r.jsx)(t.p,{children:"Start the Process Monitor for the current process. The counters from any previous collections are cleared when the Process Monitor is enabled."}),"\n",(0,r.jsx)(t.h3,{id:"disable",children:"Disable"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Disable() As %Status\n"})}),"\n",(0,r.jsx)(t.p,{children:"Stop the Process Monitor for the current process. The current values for all metrics remain in memory until they are zeroed using the Clear() method or the Process Monitor is enabled again."}),"\n",(0,r.jsx)(t.h3,{id:"clear",children:"Clear"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Clear() As %Status\n"})}),"\n",(0,r.jsx)(t.p,{children:"Set all Process Monitor counters for the current process to zero."}),"\n",(0,r.jsx)(t.h3,{id:"report",children:"Report"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Report() As %String\n"})}),"\n",(0,r.jsx)(t.p,{children:"Returns a comma-delimited list of all Process Monitor counters for the current process. The Metrics() method provides a list of the names for the metrics."}),"\n",(0,r.jsx)(t.p,{children:"Note that only the current process can report its counters. To be viewed by other processes they must be written to a global or file."}),"\n",(0,r.jsx)(t.h3,{id:"metrics",children:"Metrics"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Metrics() As %String\n"})}),"\n",(0,r.jsx)(t.p,{children:'Returns a comma-delimited list of all the Process Monitor metrics. These are in the same order as the metric counters returned by the Report() method. Although the list of metrics and the order of these metrics should be fairly static, it is possible that new metrics might be added or the order changed for some reason in future versions. Use this method to "name" the metrics when reporting them.'}),"\n",(0,r.jsx)(t.p,{children:"The metrics are the same as those reported by ^PERFMON, and the documentation for PERFMON gives a brief description of each metric."}),"\n",(0,r.jsx)(t.h3,{id:"status",children:"Status"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-objectscript-class",children:"ClassMethod Status() As %Integer\n"})}),"\n",(0,r.jsx)(t.p,{children:"Shows the current status of the Process Monitor for this process. Returns a '1' for enabled and a '0' for disabled."})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>c,x:()=>a});var r=s(96540);const o={},n=r.createContext(o);function c(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);